\documentclass[11pt,twoside,a4paper]{article}
%{book}

% This is an automatically generated file.
% Do not edit it.
% Changes to this file are not preserved!

\usepackage{tocloft}
\usepackage{hyperref}
\usepackage{listings}
\lstset{
basicstyle=\small\ttfamily,
columns=flexible,
breaklines=true
}
\setlength{\cftsubsecnumwidth}{3.5em}

\title{Manual for Package:
root\protect\\Revision 6:11M
}
\author{Karl K\"astner}
%\date{}

\begin{document}

\maketitle

\tableofcontents

% licence
% abstract


\section{root}
\begin{lstlisting}
Root folder of the source code belonging to the doctoral thesis:

"Multi-Scale Monitoring and Modelling of the Kapuas River Delta", Karl K\"aster, 2019,

and master thesis:

"Computing the Spectrum of the Confined Hydrogen Atom", Karl K\"astner, 2012.

Copyright (C) 2010-2019 Karl K\"astner

Installation instructions:
	
1) Install Matlab
2) Install subversion (svn) and add subversion to the search path, so that
   it can be called from Matlab
3) Checkout this umbrella-project:
   svn checkout https://github.com/karlkastner/root/trunk root/
4) Start Matlab
5) Change into this directory ('root/')
6) Run the Matlab script "startup" located in this directory

The script then fetches the sub-repositories and adds them to the
Matlab search path
	
Note:

The code upload is work in progress, more parts will be subsequently
documented, added and tested.

This is experimental code. Use it wisely and at your own risk.

Licence:

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <https://www.gnu.org/licenses/>.


\end{lstlisting}
\subsection{ROOTFOLDER}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{addpath\_recursive}
${}$
\begin{lstlisting}
 recursively add a directory and sub-directories to the Matlab search path
 call restoredefaultpath to undo this

\end{lstlisting}
\section{lib/auxiliar}
\subsection{Expanding\_Double}
${}$
\begin{lstlisting}

\end{lstlisting}
\section{lib/auxiliar/adaptor}
\begin{lstlisting}
adators for backward compatibility for renamed files


\end{lstlisting}
\subsection{Keller}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{MMesh}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{SMesh}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{Slg}
${}$
\begin{lstlisting}

\end{lstlisting}
\section{lib/auxiliar}
\subsection{arabic2roman}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{autocat}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{bplus}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{btimes}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{centre\_axis}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{circshift\_fractional}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{cmap\_rolling}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{colormap3}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{colormap\_byr}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{copy\_fields}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{copyfields\_deep}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{count\_occurence}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{cummax}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{cummean}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{cumstd}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{cumvar}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{cvec}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{diag3}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{down}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{dspace}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{field\_range}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{finite}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{flat}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{frac}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{getfield\_deep}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{getout}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{hashcode}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{imagesc\_}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{innerspace}
${}$
\begin{lstlisting}

\end{lstlisting}
\section{lib/auxiliar/io/@IniFile}
\subsection{IniFile}
${}$
\begin{lstlisting}

\end{lstlisting}
\section{lib/auxiliar/io}
\subsection{Stream}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{catXML}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{csv2cell}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{filewrite}
${}$
\begin{lstlisting}

\end{lstlisting}
\section{lib/auxiliar/io/netcat}
\subsection{nc}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{nc\_read\_row}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{nc\_read\_sequential}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{nc\_read\_sequential\_column}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{nc\_readall}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{nc\_writeall}
${}$
\begin{lstlisting}

\end{lstlisting}
\section{lib/auxiliar/io}
\subsection{parseXML}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{printdef}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{printf}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{save\_}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{xml2struct}
${}$
\begin{lstlisting}

\end{lstlisting}
\section{lib/auxiliar}
\subsection{isfield\_deep}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{isprop\_deep}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{issym}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{iterate\_cell}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{jmemory}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{leftdiff}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{leftmean}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{limits}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{linspace\_man}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{linspace\_man2}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{logspace\_trimmed}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{matlab\_messages}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{maxid}
${}$
\begin{lstlisting}
 index of maximum
 if value is not required (e.g. use in other functions such as accummarray)

\end{lstlisting}
\subsection{memsize}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{mlint\_all}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{myhot}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{none}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{objcopy}
${}$
\begin{lstlisting}

\end{lstlisting}
\section{lib/auxiliar/plot}
\subsection{addx}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{addy}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{adjust\_quiver\_arrowhead\_size}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{area\_man}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{arrow}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{axis\_equal\_man}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{candlestick\_man}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{circle}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{cmap}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{colormap\_man}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{colormap\_man2}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{colormap\_man\_old}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{columnlegend}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{copyaxes}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{datetick\_man}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{daytick}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{dcolormap}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{dots}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{errorarea}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{errorarea2}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{errorbar\_man}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{errorlines}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{fetchsubplot}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{fillmarker}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{freezeColors}
${}$
\begin{lstlisting}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 getCDataHandles -- get handles of all descendents with indexed CData
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 getParentAxes -- return handle of axes object to which a given object belongs
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 checkArgs -- Validate input arguments
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\end{lstlisting}
\subsection{get\_coordinates}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{hatch}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{hline}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{hold\_color}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{hourspace}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{hourtick}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{interpplot}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{legendtitle}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{line\_fewer\_markers}
${}$
\begin{lstlisting}
 find marker spec in varargin and remove it; extract special params: LockOnMax,Spacing
 input size check
 a) once only the line with all points with the style                                                                
 b) last time the markers, using fewer points with style                                                             
 c) once with a visible handle, only the first point, using the complete style you specified                         
'x' -> marker delta-x constant; 'curve' : spacing constant along the curve length

\end{lstlisting}
\subsection{monthspace}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{monthtick}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{mycolourmap}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{namedfigure}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{nansurf}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{nmcolormap}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{patch\_man}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{pdfprint}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{percenttick}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{plot2svg}
${}$
\begin{lstlisting}
" height="100%%" viewBox="0 0 %0.3f %0.3f" ',paperpos(3),paperpos(4));
            fprintf(fid,'  <filter x="%0.3f%%" y="%0.3f%%" width="%0.3f%%" height="%0.3f%%" id="%s">\n', 0, 0, 100, 100, filterId);
            %    fprintf(fid,'  <filter x="%0.3f%%" y="%0.3f%%" width="%0.3f%%" height="%0.3f%%" id="%s">\n', -(offset * 100), -(offset * 100), 100 + (offset * 200), 100 + (offset * 200), filterId);
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% SUBFUNCTIONS %%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 Octave keeps s, d, p and h in the HandleGraphics object, for the square, diamond, pentagram, and hexagram markers, respectively -- Jakob Malm
 Octave keeps s, d, p and h in the HandleGraphics object, for the square, diamond, pentagram, and hexagram markers, respectively -- Jakob Malm
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\end{lstlisting}
\subsection{plot\_ellipse}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{plot\_style}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{plotshaded}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{ploty4}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{plotyyy}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{quadsurf}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{quadsurf2}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{quadsurf3}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{quiver3\_man}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{quiver\_man}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{quiver\_man2}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{quiver\_man3}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{rectangles}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{scaleplot}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{setfontsize}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{shade\_night}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{splitfigure}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{turtle}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{velplot}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{vline}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{vline\_man}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{weekspace}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{weektick}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{xtick}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{xticklabel}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{ytick}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{yticklabel}
${}$
\begin{lstlisting}

\end{lstlisting}
\section{lib/auxiliar}
\subsection{relpos}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{rightdiff}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{rmfield\_optional}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{rvec}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{select}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{setfield\_deep}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{setfields}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{sign2str}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{signs}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{simplifyignore}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{str\_cell\_reverse\_index}
${}$
\begin{lstlisting}

\end{lstlisting}
\section{lib/auxiliar/strings}
\subsection{chomp}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{chomp1}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{num2str\_log10}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{num2str\_power\_10}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{strjoin}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{strsplit\_man}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{suffix}
${}$
\begin{lstlisting}

\end{lstlisting}
\section{lib/auxiliar}
\subsection{struct2obj}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{struct\_avg}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{struct\_flat}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{structcopy\_deep}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{structfun\_deep}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{sub2ind\_man}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{subsall}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{swap}
${}$
\begin{lstlisting}

\end{lstlisting}
\section{lib/auxiliar/system}
\begin{lstlisting}
emulate POSIX and BASH functions


\end{lstlisting}
\subsection{alloc}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{basename}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{cbrt}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{dirname}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{head}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{head\_str}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{tail}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{tail\_str}
${}$
\begin{lstlisting}

\end{lstlisting}
\section{lib/auxiliar}
\subsection{toInt32}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{unique\_columnwise}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{unpack\_struct}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{unwrap\_periodic}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{up}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{zoomaxis}
${}$
\begin{lstlisting}

\end{lstlisting}
\section{lib/gis}
\subsection{GPX}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{batavia\_zero}
${}$
\begin{lstlisting}

\end{lstlisting}
\section{lib/gis/centreline/@Centreline}
\subsection{Centreline}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{channel\_planimetry}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{clip}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{connect\_graph}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{curvature}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{cut}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{determine\_width}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{distance}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{export\_cross\_section}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{export\_node}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{export\_shp}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{find\_nearest\_segment}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{from\_polygon}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{from\_shp}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{get}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{init}
${}$
\begin{lstlisting}
obj.seg_S(id(end)) = NaN;

\end{lstlisting}
\subsection{init\_connect}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{init\_node\_D}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{link\_centreline}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{plot}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{plot\_connection}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{prune}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{prune\_leaves}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{prune\_manually}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{reachable}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{remove\_duplicate\_points}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{resample}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{routing}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{routing2}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{shp\_resample\_simple}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{snmesh}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{squeeze}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{trim\_ends}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{weighed\_connection\_matrix}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{xy2sn}
${}$
\begin{lstlisting}

\end{lstlisting}
\section{lib/gis/centreline/@Segment}
\subsection{Segment}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{build\_inverse\_index}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{connectivity\_matrix}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{init\_seg\_id}
${}$
\begin{lstlisting}

\end{lstlisting}
\section{lib/gis/centreline}
\subsection{sn2xy\_quadratic}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{thalweg}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{xy2sn\_quadratic}
${}$
\begin{lstlisting}

\end{lstlisting}
\section{lib/gis}
\subsection{gpx\_export\_csv}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{hgt\_plot}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{hgt\_read}
${}$
\begin{lstlisting}
% [ floor(mednan(z(kk))) meannan(z(kk)) min(z(kk)) max(z(kk)) ]

\end{lstlisting}
\subsection{hgt\_read\_all}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{hgt\_resample}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{nmeatime}
${}$
\begin{lstlisting}

\end{lstlisting}
\section{lib/gis/shapefile/@Shp}
\subsection{Shp}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{area}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{buffer}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{cat}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{clip}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{clip\_rect}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{close\_polygon}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{concat}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{connect\_network}
${}$
\begin{lstlisting}
 TODO make unique
 attach segments to 
XY = [cvec(shp.X),shp.;
 knnsearch for nearest n neighbours
 for each segment

\end{lstlisting}
\subsection{contour}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{cp}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{create}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{curvature}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{cut}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{diameter}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{edges}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{export\_geo}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{export\_gpx}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{export\_gpx\_track}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{export\_ldb}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{export\_poly}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{export\_sdf}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{export\_spline}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{extract\_coastline}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{first\_point}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{flat}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{generate\_four\_colour\_index}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{import\_geo}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{import\_poly}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{join\_lines}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{last\_point}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{length}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{length2}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{line2point}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{link\_lines}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{make\_clockwise}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{merge}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{merge2}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{padd\_nan}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{plot}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{points}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{polygon\_boundary}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{read}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{readZ}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{remove\_duplicate\_points}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{remove\_leaves}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{remove\_nan}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{remove\_polygon\_closure}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{remove\_short\_elements}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{renumber}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{resample}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{resample\_2}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{resample\_min}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{resample\_quick}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{scale}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{segment}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{select\_for\_refinement}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{set\_geometry}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{set\_resolution}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{skip}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{smooth}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{split\_jump}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{split\_line}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{split\_nan}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{swap\_hemisphere}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{translate}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{write}
${}$
\begin{lstlisting}

\end{lstlisting}
\section{lib/gis/shapefile}
\subsection{astar\_multi}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{astar\_recursive}
${}$
\begin{lstlisting}
 astar path finding algorithm

\end{lstlisting}
\subsection{edge\_chain}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{edge\_from\_bnd}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{preload\_shp}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{read\_gpx}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{shapewrite\_\_}
${}$
\begin{lstlisting}
 Copyright (C) 2014,2015 Philip Nienhuis
 
 This program is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by
 the Free Software Foundation; either version 3 of the License, or
 (at your option) any later version.
 
 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.
 
 You should have received a copy of the GNU General Public License
 along with this program.  If not, see <http://www.gnu.org/licenses/>.
 -*- texinfo -*- 
 @deftypefn {Function File} {@var{status} =} shapewrite (@var{shpstr}, @var{fname})
 Write contents of map- or geostruct to a GIS shape file.

 @var{shpstr} must be a valid mapstruct or geostruct, a struct array with an
 entry for each shape feature, with fields Geometry, BoundingBox, and X and Y
 (mapstruct) or Lat and Lon (geostruct).  For geostructs, Lat and Lon field
 data will be written as X and Y data.  Field Geometry can have data values
 of 'Point', 'MultiPoint', 'Line', or 'Polygon', all case-insensitive.  For
 each shape feature, field BoundingBox should contain the minimum and maximum
 (X,Y) coordinates in a 2x2 array [minX, minY; maxX, maxY].  The X and Y
 fields should contain X (or Latitude) and Y (or Longitude) coordinates for
 each point or vertex as row vectors; for polylines and polygons vertices of
 each subfeature (if present) should be separated by NaN entries.

 @var{fname} should be a valid shape file name, optionally with a '.shp'
 suffix.

 shapewrite produces 2 or 3 files, i.e. a .shp file (the actual shape file),
 a .shx file (index file), and if @var{shpstr} contained additional fields,
 a .dbf file (dBase type 3) with the contents of those additional fields.

 @var{status} is 1 if the shape file set was written successfully, 0
 otherwise.

 @seealso{shaperead, shapeinfo}
 @end deftypefn
 Author: Philip Nienhuis <prnienhuis@users.sf.net>
 Created: 2014-12-30
 Input validation
 Assess shape variable type (oct or ml/geo ml/map)
 Yep. Find out what type
 Assume it is an Octave-style struct read by shaperead
 Assume it is a Matlab-style mapstruct
 Assume it is a Matlab-style geostruct
 Not a supported struct type
 Check file name
 Later on bname.shx and bname.dbf will be read
 Prepare a few things
 Change Lat/Lon fields into X/Y
 Only now (after input checks) open .shp and .shx files & rewind just to be sure
 Write headers in .shp & .shx (identical). First magic number 9994 + 5 zeros
 In between here = filelength in 16-bit words (single). For .shx it's known
 Next, shp file version
 Shape feature type
 Bounding box. Can be run later for ML type shape structs. Fill with zeros
 Skip to start of first record position
 Write shape features one by one
 Write record start pos to .shx file
 Write record contents
 Point
 Record index number
 Record length (fixed)
 Shape type
 Simply write XY cordinates
 MultiPoint
 Record index number
 Record length
 Shape type
 Bounding box
 Nr of points
 Polyline/-gon
 Record index number
 Prepare multipart polygons
 Augment idx for later on, & this trick eliminates trailing NaN rows
 Record length
 Shape type
 Bounding box
 Number of parts, number of points, part pointers
 Write file length into .shp header
 Close files
 Check for dbfwrite function
 Write rest of attributes
 Attributes + shp data in mapstruct
 Attributes + shp data in geostruct

\end{lstlisting}
\subsection{shapewrite\_man}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{shp2geo}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{shp2kml}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{shp\_plot\_attribute}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{split\_section}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{write\_polygon}
${}$
\begin{lstlisting}

\end{lstlisting}
\section{lib/instrumentation/adcp/@ADCP}
\subsection{ADCP}
${}$
\begin{lstlisting}
 ADCP superclass
 converts ADCP fixed integer raw data to floats with SI units
 provides functions for ADCP data manipulation
 calculated from the water temperature and sound frequency

\end{lstlisting}
\subsection{Ds}
${}$
\begin{lstlisting}
 depth of bin, distance between water surface (z_s) and (z_i)

 Ds = z_s - z_bin

 does not correct for tilts

\end{lstlisting}
\subsection{Dt}
${}$
\begin{lstlisting}
 projected distance from transducer to cell centres
 if the instrument is not tilted, this is the vertical distance (depth)
 between the transducer and cell centres
 does not account for transducer depth

\end{lstlisting}
\subsection{R}
${}$
\begin{lstlisting}
 unprojected (slanted) distance between the transducer and cell centres

\end{lstlisting}
\subsection{adc\_current\_slope}
${}$
\begin{lstlisting}
 instrument type specific slope for converting raw current to Ampere
 c.f WorkHorse Commands and Output Data Format, March 2014
 c.f. XMT Voltage and Current Channels
 originally undoccumented by RDI, and taken from Shields 2010

\end{lstlisting}
\subsection{adc\_voltage\_slope}
${}$
\begin{lstlisting}
 instrument series specific conversion factors for voltage
 c.f. WorkHorse Commands and Output Data Format, March 2014
 c.f. XMT Voltage and Current Channels
 originally undoccumented by RDI, and taken from Shields 2010

\end{lstlisting}
\subsection{assign\_file}
${}$
\begin{lstlisting}
 ensemble indices of each file

\end{lstlisting}
\subsection{assign\_water\_level}
${}$
\begin{lstlisting}
 assign water level to adcp ensembles (combine gauge with boat data)

\end{lstlisting}
\subsection{average\_profile}
${}$
\begin{lstlisting}
 average backscatter for each sample within an specific interval

\end{lstlisting}
\subsection{backscatter2ssc}
${}$
\begin{lstlisting}
 wrapper for backscatter conversion

\end{lstlisting}
\subsection{binsize}
${}$
\begin{lstlisting}
 bin size (vertical distance between two bins)

\end{lstlisting}
\subsection{blnk}
${}$
\begin{lstlisting}
 blanking range, range from transduce to centre of first bin

\end{lstlisting}
\subsection{btrange}
${}$
\begin{lstlisting}
 convert raw btrange to vertical distance (projected distance) of the bed
 level below the transducer, when the transducer is looking vertically down
 this is the depth less the transducer depth

\end{lstlisting}
\subsection{calc\_backscatter}
${}$
\begin{lstlisting}
 backscatter from echo intensity

\end{lstlisting}
\subsection{clock\_offset\_STATIC}
${}$
\begin{lstlisting}
 dt : median difference between adcp clock and UTC
 sd_dt : standard error of dt

\end{lstlisting}
\subsection{convert\_raw\_binprops\_STATIC}
${}$
\begin{lstlisting}
 convert the raw bin properties to si-units

\end{lstlisting}
\subsection{convert\_raw\_serial\_STATIC}
${}$
\begin{lstlisting}
 convert bytes of serial number into single number
 big endian system

\end{lstlisting}
\subsection{convert\_raw\_time\_STATIC}
${}$
\begin{lstlisting}
 convert measurement time stamps into matlab internal format

\end{lstlisting}
\subsection{convert\_raw\_velocity}
${}$
\begin{lstlisting}
 convert scaled integer raw velocity to float SI (m/s)

\end{lstlisting}
\subsection{convert\_raw\_velocity\_STATIC}
${}$
\begin{lstlisting}
 convert raw velocity to SI units (m/s)

\end{lstlisting}
\subsection{copy}
${}$
\begin{lstlisting}
 copy constructor

\end{lstlisting}
\subsection{distmidbin1}
${}$
\begin{lstlisting}
 convert raw distance to first bin centre to SI

\end{lstlisting}
\subsection{file\_ensemble\_index}
${}$
\begin{lstlisting}
 ensemble index eid_f with respect to file for ensemble eid

\end{lstlisting}
\subsection{file\_index}
${}$
\begin{lstlisting}
 first and last ensemble index of of a file

\end{lstlisting}
\subsection{filetime\_min}
${}$
\begin{lstlisting}
 start time of each file

\end{lstlisting}
\subsection{fill\_coordinate\_gaps}
${}$
\begin{lstlisting}
 fill gaps in ensemble coordinates

\end{lstlisting}
\subsection{filter\_range}
${}$
\begin{lstlisting}
 filter HADCP velocity by detecting the last valid bin
 if the bacscatter does not decreas over 10 bins, than obtstacle or intersection

\end{lstlisting}
\subsection{heading\_rad}
${}$
\begin{lstlisting}
 convert raw instrument heading angle to [rad]

\end{lstlisting}
\subsection{instrument\_depth\_m}
${}$
\begin{lstlisting}
 depth of instrument (for submerged deployments)

\end{lstlisting}
\subsection{instrument\_to\_ship\_STATIC}
${}$
\begin{lstlisting}
 transform velocities from instrument reference to ship reference
 by correcting for pitch_rad and roll_rad

 input
 vel   : float [arbitrary unit] instrument reference
 btvel : float [arbitrary unit] instrument reference
 pitch_rad : float [radians] true pitch_rad, not measured pitch_rad
 roll_rad  : float [radians]
 
 output
 vel and btvel [input unit] ship reference

\end{lstlisting}
\subsection{lngthtranspulse}
${}$
\begin{lstlisting}
 convert raw transmit pulse length to SI units (m)

\end{lstlisting}
\subsection{load\_RSSI\_values\_STATIC}
${}$
\begin{lstlisting}
 load instrument specific backscatter conversion parameters

\end{lstlisting}
\subsection{nbins}
${}$
\begin{lstlisting}
 number of bins for each file

\end{lstlisting}
\subsection{near\_field\_correction}
${}$
\begin{lstlisting}
 new fiel correction of the acoustic backscatter
 c.f. wall 2006
 Psi : (nr,1)  near field correction factor

\end{lstlisting}
\subsection{nens}
${}$
\begin{lstlisting}
 number of ensembles

\end{lstlisting}
\subsection{pitch\_rad}
${}$
\begin{lstlisting}
 convert raw pitch to radians

\end{lstlisting}
\subsection{pressure\_bar}
${}$
\begin{lstlisting}
 convert raw pressure to bar

\end{lstlisting}
\subsection{range2binid}
${}$
\begin{lstlisting}
 convert distance to transducer to bin index

\end{lstlisting}
\subsection{roll\_rad}
${}$
\begin{lstlisting}
 convert raw instrument roll angle to [rad]

\end{lstlisting}
\subsection{rotate\_velocity}
${}$
\begin{lstlisting}
 rotate the velocity in the horizontal plane with respect to the directional
 vector dir
 dir : direction of the transect

\end{lstlisting}
\subsection{rotate\_velocity\_sw}
${}$
\begin{lstlisting}
 rotate velocity to local streamwise reference
 input velocity can have arbitrary reference

\end{lstlisting}
\subsection{ship\_to\_earth\_STATIC}
${}$
\begin{lstlisting}
 converts velocity from ship to earth coordinate reference
 expects input arguments informat:
 vel    : float arbitrary unit
 btvel  : float same unit as vel
 heading_rad: float [radians]


\end{lstlisting}
\subsection{sort\_STATIC}
${}$
\begin{lstlisting}
 sort files by start time

\end{lstlisting}
\subsection{squeeze\_STATIC}
${}$
\begin{lstlisting}
 cut ensembles, skip ensembles or average ensembles in time

 adcp : adcp structure
 dt   : time between output ensembles in seconds
 mode : {'average', 'skip'}
 mask : selection of ensembles to keep (computed from dt if not provided)
				fprintf(1,'Progress: %g\n%% %gs\n',idx/nt,tlast);

\end{lstlisting}
\subsection{temperature\_offset\_C}
${}$
\begin{lstlisting}
 instrument specific temperature offset

\end{lstlisting}
\subsection{to\_abs}
${}$
\begin{lstlisting}
 velocity magnitude

\end{lstlisting}
\subsection{transducer\_temperature\_C}
${}$
\begin{lstlisting}
 convert raw transducer temperature to SI units [Celsius]
 T   : (1,nt)  water temperature

\end{lstlisting}
\subsection{verify\_pc\_time}
${}$
\begin{lstlisting}
 verify the time stored in the data file

\end{lstlisting}
\section{lib/instrumentation/adcp/@Ensemble}
\subsection{Ensemble}
${}$
\begin{lstlisting}
 container for ADCP ensemble data and properties

\end{lstlisting}
\subsection{calc\_beamcoords}
${}$
\begin{lstlisting}
 claculate positions in world coordinates where the individual beams hit the bottom

\end{lstlisting}
\section{lib/instrumentation/adcp/@HADCP}
\subsection{HADCP}
${}$
\begin{lstlisting}
 coverts raw data of horizontal ADCPs into physical quantities
 and provides functions for data processing

\end{lstlisting}
\subsection{beam\_to\_instrument\_STATIC}
${}$
\begin{lstlisting}
 transform the 3 beam velocities into a set of 2 orthogonal velocities
 and 1 error velocity
 This uses always three beams (no two beam solutions)

 input
 vel       : float [arbitrary unit] beam reference system
 btvel     : float [arbitrary unit] beam reference system
 beamangle : float [radians]

 output
 vel and btvel [input unit] instrument reference system

\end{lstlisting}
\subsection{bootstrap\_backscatter}
${}$
\begin{lstlisting}
 bootstrap uncertainty of the backscatter parameters

\end{lstlisting}
\subsection{calc\_beam\_spreading\_cone}
${}$
\begin{lstlisting}
 beam spreading
 Note: beams spread in the form of bessel functions
       this is the engineering approach as cones, which is however not
       a good approximation, it is better to approximate it as a gaussian

\end{lstlisting}
\subsection{calc\_bin\_coordinates}
${}$
\begin{lstlisting}
 get the cartesian (world) coordinates of the HADCP central beam bins

\end{lstlisting}
\subsection{calibrate\_backscatter}
${}$
\begin{lstlisting}
 calibrate backscatter to sediment concentration by the method of Sassi

\end{lstlisting}
\subsection{filter\_velocity}
${}$
\begin{lstlisting}
 filter outliers in velocity data

\end{lstlisting}
\subsection{firmware\_fix\_STATIC}
${}$
\begin{lstlisting}
 correct RDI HADCP firmware bug (2014)
 this bug successively invalids data every 4th-bin, which led to 3-beam solutions
 and consequentially jumps of the transformed velocities
			vel_s(:,fdx,:) = vel(:,fdx,:);
			vel_b(:,fdx,:) = vel(:,fdx,:);

\end{lstlisting}
\subsection{fixnan}
${}$
\begin{lstlisting}
 interpolate invalid bin-samples from last and next ensemble

\end{lstlisting}
\subsection{instrument\_to\_beam\_STATIC}
${}$
\begin{lstlisting}
 transform the 3 beam velocities into a set of 2 orthogonal velocities
 and 1 error velocity
 This uses always three beams (no two beam solutions)

 input
 vel       : float [arbitrary unit] beam reference system
 btvel     : float [arbitrary unit] beam reference system
 beamangle : float [radians]

 output
 vel and btvel [input unit] instrument reference system

 mode : beams used for all transformations
        123, 12, 23, 13

\end{lstlisting}
\subsection{reorder\_velocity\_STATIC}
${}$
\begin{lstlisting}
 reorder the HADCP velocity data into the first three slots, the HADCP
 has just three beams, but the software stores data for
 four beams, similar to the four beam VADCPs

\end{lstlisting}
\subsection{to\_beam\_STATIC}
${}$
\begin{lstlisting}
 wrapper for conversion to beam velocity
 Note that back-conversion to beam velocity is not unique in case of 3 beam
 solutions (as RDI instruments doe not store which beams were used) and
 if instrument internal bin-mapping is used (whichs precise algorithm remains
 an RDI secret)

\end{lstlisting}
\subsection{to\_earth\_STATIC}
${}$
\begin{lstlisting}
 wrappter to transform velocities to world coordinate reference

\end{lstlisting}
\subsection{to\_instrument\_STATIC}
${}$
\begin{lstlisting}
 wrapper to convert velocity to instrument coordinate reference

\end{lstlisting}
\subsection{to\_ship\_STATIC}
${}$
\begin{lstlisting}
 wrapper for conversion to ship velocity

\end{lstlisting}
\section{lib/instrumentation/adcp/@RDI\_mmt}
\subsection{RDI\_mmt}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{read}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{write}
${}$
\begin{lstlisting}

\end{lstlisting}
\section{lib/instrumentation/adcp/@VADCP}
\subsection{VADCP}
${}$
\begin{lstlisting}
 coverts raw data of vertical ADCPs into physical quantities

\end{lstlisting}
\subsection{assign\_transect}
${}$
\begin{lstlisting}
 assign transect index to ensembles

\end{lstlisting}
\subsection{backscatter\_report}
${}$
\begin{lstlisting}
 human readable output of calibration properties
%	fprintf(['Parameters and uncertainty with respect to 95%% confidence\n']);

\end{lstlisting}
\subsection{beam\_to\_instrument\_STATIC}
${}$
\begin{lstlisting}
 transform the 4 beam velocities into a set of 3 orthogonal velocities
 and 1 error velocity

 input
 vel       : float [arbitrary unit] beam reference system
 btvel     : float [arbitrary unit] beam reference system
 beamangle : float [radians]

 output
 vel and btvel [input unit] instrument reference system

 TODO account for NaNs either by three beam solution or interpolation


\end{lstlisting}
\subsection{bottom\_track\_STATIC}
${}$
\begin{lstlisting}
 compute bottom track coordinates

\end{lstlisting}
\subsection{bscalibrate}
${}$
\begin{lstlisting}
 backscatter to sediment calibration

 calibtation subroutine
 M_ref : sediment concentration calibration values 
 d_k   : depth of virtual reference value K
         (choose close to receiver, but out of near field, e.g. within 2m .. 4m)
 TODO : better documentation of input values
 TODO : rename nk into ik, bacause it is an index and not a length
 TODO rename r_ref and d_k into r_1 and r_2

\end{lstlisting}
\subsection{bsgrid}
${}$
\begin{lstlisting}
 evaluate the objective function at the selected points

\end{lstlisting}
\subsection{bsinvert}
${}$
\begin{lstlisting}
 backscatter inversion


\end{lstlisting}
\subsection{bsjackknife}
${}$
\begin{lstlisting}
 compute the jackknife estimates of the parameters and their covariances

\end{lstlisting}
\subsection{bsjointcalibration}
${}$
\begin{lstlisting}
 calibrate backscatter

\end{lstlisting}
\subsection{btvel\_from\_position}
${}$
\begin{lstlisting}
 determine boat velocity from bottom track, inverse of bottom track

\end{lstlisting}
\subsection{calc\_ssc}
${}$
\begin{lstlisting}
 calculate the backscatter

\end{lstlisting}
\subsection{cdf}
${}$
\begin{lstlisting}
 compute and plot cumulative distribution (cdf) of the velocity components

\end{lstlisting}
\subsection{convert\_nFiles}
${}$
\begin{lstlisting}
 convert coordinates of NMEA-nFiles

\end{lstlisting}
\subsection{correct\_coordinates}
${}$
\begin{lstlisting}
 correct the bottom coordinates for pitch and roll

\end{lstlisting}
\subsection{correct\_for\_platform\_velocity\_STATIC}
${}$
\begin{lstlisting}
 correct for platform (boat) velocity, this is the negative bed velocity

\end{lstlisting}
\subsection{depth\_average\_velocity}
${}$
\begin{lstlisting}
 average the velocity over depth

\end{lstlisting}
\subsection{depth\_integrate}
${}$
\begin{lstlisting}
 depth integrate the velocity to obtain specific discharge

\end{lstlisting}
\subsection{depth\_integrate\_sediment\_discharge}
${}$
\begin{lstlisting}
 depth integrated sediment discharge

\end{lstlisting}
\subsection{filter\_velocity}
${}$
\begin{lstlisting}
 filter the velocity data

\end{lstlisting}
\subsection{fit\_sediment\_concentration\_profile}
${}$
\begin{lstlisting}
 fit_suspended_sediment_concentration_profile(obj,profile_cls,ensmask,nwin)

\end{lstlisting}
\subsection{fit\_velocity\_profile}
${}$
\begin{lstlisting}
 fit velocity profile to the streamwise velocity

\end{lstlisting}
\subsection{map\_z}
${}$
\begin{lstlisting}
 z-mapping, i.e. correct for roll and pitch of instrument

\end{lstlisting}
\section{lib/instrumentation/adcp/@VADCP/old}
\subsection{assign\_crossing}
${}$
\begin{lstlisting}

\end{lstlisting}
\section{lib/instrumentation/adcp/@VADCP}
\subsection{optstr}
${}$
\begin{lstlisting}
 string of arguments, for file name generation

\end{lstlisting}
\subsection{plot\_track}
${}$
\begin{lstlisting}
 plot the boat track

\end{lstlisting}
\subsection{plot\_velocity\_components}
${}$
\begin{lstlisting}
 plot the velocity components

\end{lstlisting}
\subsection{process}
${}$
\begin{lstlisting}
 process VADCP data

\end{lstlisting}
\subsection{range2depth}
${}$
\begin{lstlisting}
 depth below transducer for individual bins of the beams

\end{lstlisting}
\subsection{rangemask}
${}$
\begin{lstlisting}
 mask all bins in range

\end{lstlisting}
\subsection{to}
${}$
\begin{lstlisting}
 transform velocity to given reference

\end{lstlisting}
\subsection{to\_beam\_STATIC}
${}$
\begin{lstlisting}
 convert velocity data to beam reference

\end{lstlisting}
\subsection{to\_cs}
${}$
\begin{lstlisting}
 transform velocity to cross section references
 cs-velocity is here defined as the velocity orthogonal to the cs 
	% [ 0  1][c -s]=[-s  c]
	% [ 1  0][s  c] [ c  s]

\end{lstlisting}
\subsection{to\_earth\_STATIC}
${}$
\begin{lstlisting}
 transform coordinates to cartesian world reference system (earth)

\end{lstlisting}
\subsection{to\_sw}
${}$
\begin{lstlisting}
 transform velocity with respect to depth averaged streamwise velocity

\end{lstlisting}
\subsection{velocity\_near\_bed}
${}$
\begin{lstlisting}
 velocity near the bed

\end{lstlisting}
\subsection{xy2nts}
${}$
\begin{lstlisting}
 project coordinates onto a single cross section and assign them nz-coordinates at a single cross section
 TODO this should be part of transect

\end{lstlisting}
\section{lib/instrumentation/adcp}
\begin{lstlisting}
adcp : processing of Acoustic Doppler Current Profiler (ADCP) data

Processing in 3 Levels:

Level 0 : Read in of raw-data (externally provided by ADCPtools, Vermeulen et al.)

Level 1 : VADCP, HADCP, SPADCP
	- convert raw data to CI units (m,s,kg)
	- transform velocities to arbitrary coordinate references
	- depth averaging and integration
	- fit velocity profiles
	- convert backscatter to suspended sediment concentration

Level 2 : CrossSection
	- interpolate and integrate for cross sections

Instruction:
	see and run saggau/sanggau_process_discharge for a working example
	to process VADCP discharge at a non-tidal station


\end{lstlisting}
\subsection{ADCP\_Bin}
${}$
\begin{lstlisting}
 ADCP bin (single velocity values)

\end{lstlisting}
\subsection{SPADCP}
${}$
\begin{lstlisting}
 stream pro acoutic current doppler profiler

\end{lstlisting}
\section{lib/instrumentation/adcp/backscatter/@Backscatter}
\subsection{Backscatter}
${}$
\begin{lstlisting}
 acoustic backscatter processing

\end{lstlisting}
\subsection{backscatter2ssc}
${}$
\begin{lstlisting}
 convert backscatter to suspended sediment concentration
 c.f lee hanes / sassi, with linear relation for reference concentration

\end{lstlisting}
\subsection{backscatter2ssc\_implicit}
${}$
\begin{lstlisting}
 convert backscatter to suspended sediment concentration

 this is the methog called "implicit" by hanes, though it is here still
 implemented in an explicit way, as "explicit/imlicit" in hanes only
 mean euler forward or trapezoidal integration

\end{lstlisting}
\subsection{backscatter2ssc\_implicit\_sample}
${}$
\begin{lstlisting}
 convert backscatter to suspended sediment concentration, implicit method

\end{lstlisting}
\subsection{backscatter2ssc\_sample}
${}$
\begin{lstlisting}
 convert backscatter 2 suspended sediment concentration

\end{lstlisting}
\subsection{backscatter2ssc\_sassi}
${}$
\begin{lstlisting}
 convert backscatter to suspended sediment concentration
 c.f. sassi

\end{lstlisting}
\subsection{backscatter2ssc\_sassi\_sample}
${}$
\begin{lstlisting}
 convert backscatter to suspended sediment concentration
 c.f. sassi

\end{lstlisting}
\subsection{fit}
${}$
\begin{lstlisting}
 fit backscatter coefficients

 function [res, leverage, w, obj] = fit(obj,ssc0,R0,R,bs,last,param0)

 ssc0		- ns x 1, reference concentration
 R0            - ns x 1, distance to sample along beam
 bs            - ns x nbin, backscatter profile per sample
 R             - ns x nbin, distance to bin from transducer along beam
 last          - last : index last valid bin
 param0        - initial value for parameters

\end{lstlisting}
\subsection{regmat}
${}$
\begin{lstlisting}
 regression matrix

\end{lstlisting}
\section{lib/instrumentation/adcp/backscatter}
\subsection{attenuation\_coefficient}
${}$
\begin{lstlisting}

 accoustic attenuation coefficient of suspended particles

 hanes 2012

 [d_mm] = mm
 [f]    = Hz = 1/s
 [as]   = 1/m (neper)
 for db : chi_db  = 8.7 chi_neper
 [M]    = kg/m^3 = mg/l
 
 for normalization : chis = as(M=2650)
 
 function [as,asnu,ass,X,chi] = attenuation_coefficient(d_mm,f,M,mode)


\end{lstlisting}
\subsection{backscatter\_coefficient}
${}$
\begin{lstlisting}
 analytic determination of the backscatter coefficient

\end{lstlisting}
\subsection{backscatter\_coefficient\_2}
${}$
\begin{lstlisting}
 analytic basckatter coefficient
 thorne 2002
 thorne 2012

\end{lstlisting}
\subsection{backscatter\_form\_function}
${}$
\begin{lstlisting}
 acoustic backscatter form function

\end{lstlisting}
\subsection{backscatter\_to\_concentration}
${}$
\begin{lstlisting}
 convert acoustic backscatter to suspended sediment mass concentration
 backscatter S has to be corrected for attenuation

\end{lstlisting}
\subsection{backscatter\_to\_concentration2}
${}$
\begin{lstlisting}
 convert acoustic backscatter to sediment concentration

\end{lstlisting}
\subsection{derive\_attenuation\_coefficient}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{normalized\_particle\_radius}
${}$
\begin{lstlisting}
 normalized particle radius

\end{lstlisting}
\subsection{scattering\_cross\_section\_general}
${}$
\begin{lstlisting}

 acoustic cross sectin ? of sediment particles
 Medwin, ch. 7.5.3
 Axially Symmetric Spherical Mode Solutions

\end{lstlisting}
\subsection{sigma\_geometric}
${}$
\begin{lstlisting}
 differential cross section
 geometrical backscattering for spherical bodies
 ka >> 1, large particles or high frequencies
 k : wave number
 a : radius of the particle

\end{lstlisting}
\subsection{sigma\_rayleigh}
${}$
\begin{lstlisting}
 Rayleigh scattering for a sphere (ka << 1)
 small particles or low frequencies
 Medwin 7.5.2 Rayleigh Scatter From a Sphere (ka << 1)

\end{lstlisting}
\subsection{ssc2backscatter}
${}$
\begin{lstlisting}
 convert suspended sediment concentration to backscatter
 function bs = ssc2backscatter(ssc,d_mm,f,varargin)

 ssc : mass concentration of sediment [ssc] = g/l = kg/m^3
 d_mm : grain size diameter [d_mm] = mm
 f : frequency [f] = Hz = 1/2

\end{lstlisting}
\section{lib/instrumentation/adcp/cross-section/@ADCP\_Transect}
\subsection{ADCP\_Transect}
${}$
\begin{lstlisting}
 zero dimensional processing of ADCP data
 no resampling, meshing or gridding

\end{lstlisting}
\subsection{assign\_to\_transect}
${}$
\begin{lstlisting}
 assign ensemble to respective transects
 this has a side-effect (writes to) the adcp object,
 but values of induvidial cross sections remain unaffected by each other

\end{lstlisting}
\subsection{compare}
${}$
\begin{lstlisting}
 discharge summary

\end{lstlisting}
\subsection{detect\_crossings}
${}$
\begin{lstlisting}
 detect consecutive navigation of transects (channel crossings)

\end{lstlisting}
\subsection{detect\_crossings\_circling}
${}$
\begin{lstlisting}
 separatate individual navigation of transects,
 for cases when the boat goes in circles and crosses the branches one after
 the other before returning to the original cross section,
 thus the boat does not turn at the other bank to return across the same section
 and always navigates the cross section in the same direction

\end{lstlisting}
\subsection{detect\_crossings\_returning}
${}$
\begin{lstlisting}
 groups the ensembles into transects,
 one transect is defined as all ensembles recorded during the time the boat
 moved from one bank to the other (return is defined as separate transect)

\end{lstlisting}
\subsection{detect\_rounds}
${}$
\begin{lstlisting}
 detect rounds, i.e. when boat returns to initial position

\end{lstlisting}
\subsection{export\_mmt}
${}$
\begin{lstlisting}
 export RDI mmt

\end{lstlisting}
\subsection{extrapolate\_to\_bank}
${}$
\begin{lstlisting}
 extrapolate values to bank

\end{lstlisting}
\subsection{fit}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{integrate\_discharge}
${}$
\begin{lstlisting}
 integrate discharge

 Q  = sum q
 q  = A_n*u_s = h dn us
    = h * [dx, dy]*[-v; u]
    = h * dt * [-ub, -vb] * [-v; u]

 note that uvb * dt is usually more accurate than dx of GPS position,
 if uvb determined by doppler shift of ADCP bottom echo,
 except when the GPS position (or velocity) is determined from the carrier frequency

 note that projection can be left out, if cs is defined with transect individual end points,
 but not recommended, if there are strong secondary currents as encountered at
 bends or bifurcations


\end{lstlisting}
\subsection{plot}
${}$
\begin{lstlisting}
 plot the transect as a line in cartesian coordinates

\end{lstlisting}
\subsection{plot2d}
${}$
\begin{lstlisting}
 plot transects

\end{lstlisting}
\subsection{plot\_rounds}
${}$
\begin{lstlisting}
 plot rounds (consecutiver transects) navigated with the boat

\end{lstlisting}
\section{lib/instrumentation/adcp/cross-section/@CrossSection}
\subsection{CrossSection}
${}$
\begin{lstlisting}
 Level-3 ADCP data processing, projection to cross section and integration/averaging

\end{lstlisting}
\subsection{calc\_auxiliary\_quant}
${}$
\begin{lstlisting}
 compute auxiliary quantities

\end{lstlisting}
\subsection{compare}
${}$
\begin{lstlisting}
 interpolate for all cross-sections the values to the same time-slot
 for comparison

\end{lstlisting}
\subsection{determine\_time\_slots}
${}$
\begin{lstlisting}
 split data set into specific time slots

\end{lstlisting}
\subsection{discharge}
${}$
\begin{lstlisting}
 integrate the discharge over all finite elements of the cross section

\end{lstlisting}
\subsection{extrapolate\_S}
${}$
\begin{lstlisting}
 extrapolate missing values along the vertical

\end{lstlisting}
\subsection{extrapolate\_backscatter}
${}$
\begin{lstlisting}
 extrapolate the backscatter

\end{lstlisting}
\subsection{extrapolate\_backscatter\_2d\_STATIC}
${}$
\begin{lstlisting}
 extrapolate backscatter to bed, surface and banks

\end{lstlisting}
\subsection{extrapolate\_bed\_profile}
${}$
\begin{lstlisting}
 extrapolate bed profile to channel banks

\end{lstlisting}
\subsection{extrapolate\_n}
${}$
\begin{lstlisting}
 extrapolate value beyond end of cross section

\end{lstlisting}
\subsection{extrapolate\_velocity}
${}$
\begin{lstlisting}
 extrapolate the velocity to the bank, bed, and surface

\end{lstlisting}
\subsection{extrapolate\_velocity\_1d\_STATIC}
${}$
\begin{lstlisting}
 extrapolate depth averaged velocity

\end{lstlisting}
\subsection{extrapolate\_velocity\_2d\_STATIC}
${}$
\begin{lstlisting}
 extrapolate velocity to banks, surface and bottom
 TODO, this is only applicable for Grid2

\end{lstlisting}
\subsection{fit\_bathymetry\_2d}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{fit\_bed\_profile}
${}$
\begin{lstlisting}
 fit the bed profile, has to precede n-z meshing of the cross-section

\end{lstlisting}
\subsection{fit\_cross\_section}
${}$
\begin{lstlisting}
 fit the optimal cross section as the main axis of the transect
 by regressing a line through the measurement points in the x-y plane

 y = c0 + c1 x

\end{lstlisting}
\subsection{fit\_vertical\_profile\_of\_velocity}
${}$
\begin{lstlisting}
 fit vertical profile of the streamwise velocity

 this function will work with both ensenble data, eg. U_bin taken from ensembles,
 as well as gridded data, (U_bin taken from the velocity grid)

 input
 cs    : struct        : cross section averaged data
 U_bin : [nrow x ncol] : vertical profiles of stream wise velocity
 Z_bin : [nrow x ncol] : positions of bin above bottom for each element in U_bin
 ens.N : [ncolx1]      : position of each column of U in along the cross section
 ens.H : [ncolx1]      : depth of each column of U
 ens.sH  : [ncolx1]     : std of depth at each colum of U
 ens.ldx : [ncolx1]    : last valid sample in column of U
 dw_z0   : scalar    : grid cell size for grid_n
 obj.roughnessmethod           : method to use for the computation
 output:
 grid_n : struct       : function of u_s and z_0 along cross section
 us_ens, ln_z0_ens, U_ens : local estimates for input ensembles/grid columns
            not returned by every obj.roughnessmethod

\end{lstlisting}
\subsection{fit\_water\_level}
${}$
\begin{lstlisting}
 fit water level from depth measurement
 this works only if the ADCP is stationary

\end{lstlisting}
\subsection{generate\_mesh\_tn}
${}$
\begin{lstlisting}
 generate 1+1D mesh over time and across section

\end{lstlisting}
\subsection{generate\_mesh\_tnz}
${}$
\begin{lstlisting}
 generate a t-n-z mesh

\end{lstlisting}
\subsection{optstr}
${}$
\begin{lstlisting}
 string of options, for file name generation

\end{lstlisting}
\subsection{plot\_n\_quiver}
${}$
\begin{lstlisting}
 plot quiver across section

\end{lstlisting}
\subsection{plot\_nz}
${}$
\begin{lstlisting}
 plot along n and z

\end{lstlisting}
\subsection{plot\_nz\_quiver}
${}$
\begin{lstlisting}
 quiver plot of velocity across section

\end{lstlisting}
\subsection{plot\_tn}
${}$
\begin{lstlisting}
 plot over time and across channel

\end{lstlisting}
\subsection{plot\_xyz}
${}$
\begin{lstlisting}
 plot values in "val" in the 2D cross section, where the cartesian
 rather than the local coordinates of the cross-section are used

\end{lstlisting}
\subsection{process\_backscatter}
${}$
\begin{lstlisting}
 process backscatter, i.e. fit to cross-section grid from bin-values

\end{lstlisting}
\subsection{process\_backscatter\_tn}
${}$
\begin{lstlisting}
	process depth integrated backscatter over time t and acrross section N
 note: backscatter is processed as flux
	 due to high concentration and backscatter near the bottom,
	the inner rpoduct of the discharge and concentration
	\bar u \bar c_s is not a good estimate of the 
       depth averaged sediment flux \bar{u c_s} 

\end{lstlisting}
\subsection{process\_backscatter\_tnz}
${}$
\begin{lstlisting}
 process the backscatter in 2+1D (time, across channel and along vertical)

\end{lstlisting}
\subsection{process\_discharge}
${}$
\begin{lstlisting}
 process the discharge

\end{lstlisting}
\subsection{process\_velocity\_tn}
${}$
\begin{lstlisting}
 process the velocity data

\end{lstlisting}
\subsection{process\_velocity\_tnz}
${}$
\begin{lstlisting}
 process velocity data in 2+1D (time, across-section and along vertical)

\end{lstlisting}
\subsection{summarise}
${}$
\begin{lstlisting}
 summarize discharge of cross section

\end{lstlisting}
\subsection{var\_n}
${}$
\begin{lstlisting}
 return value stored in field "fieldname" at position "N" in the cross section

\end{lstlisting}
\subsection{var\_t}
${}$
\begin{lstlisting}
 return value stored in filed "fieldname" at time t
 cross sectionally integrated or averaged value

\end{lstlisting}
\subsection{var\_tn}
${}$
\begin{lstlisting}
 return values of field "fieldname" at time t and position N along cross section
 typically depth integrated or averaged values

\end{lstlisting}
\subsection{var\_tnz}
${}$
\begin{lstlisting}
 generically return value stored in field "fieldname" at time t and position N

\end{lstlisting}
\section{lib/instrumentation/adcp/cross-section}
\subsection{complete\_profiles}
${}$
\begin{lstlisting}
 fill gaps in profiles
 assumes profile to be constant in time, this is not true
 for tidal flow in compound cross sections and near banks

\end{lstlisting}
\subsection{define\_transect}
${}$
\begin{lstlisting}
 gui user selection of cross-section end points

\end{lstlisting}
\subsection{discharge\_division}
${}$
\begin{lstlisting}
 discharge division ratio

\end{lstlisting}
\subsection{discharge\_summary}
${}$
\begin{lstlisting}
 compute and store discharge summary
		q_tn = cs.q_tn(ti);
		ndx       = abs(N)<=Nlim;
		Qi        = cs.dw*sum(q_tn)';
		Qi_centre = cs.dw*sum(q_tn(ndx,:))';
		Q = [Q; Qi];
		Q_centre = [Q_centre; Qi_centre];

\end{lstlisting}
\subsection{load\_vadcp\_discharge}
${}$
\begin{lstlisting}
 load previously computed vadcp discharge (auxiliary function for plotting)
 this function stacks data from several vadcp reference measurements into one structure
 This assumes that all data sets where processed with the same settings

\end{lstlisting}
\subsection{split\_transect2}
${}$
\begin{lstlisting}

\end{lstlisting}
\section{lib/instrumentation/adcp/hadcp/@HADCP\_Discharge}
\subsection{HADCP\_Discharge}
${}$
\begin{lstlisting}
 superclass for HADCP discharge estimation methods

\end{lstlisting}
\subsection{fit}
${}$
\begin{lstlisting}
 fit the model parameter for HADCP discharge prediction,
 estimate errors with the Jacknife method

\end{lstlisting}
\section{lib/instrumentation/adcp/hadcp/@HDischarge}
\subsection{Hbin}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{calc\_specific\_discharge\_weights}
${}$
\begin{lstlisting}
 calculate unite discharge weights

\end{lstlisting}
\subsection{estimate\_discharge}
${}$
\begin{lstlisting}
 integrate and scale specifc discharge to total discharge for each ensemble

\end{lstlisting}
\section{lib/instrumentation/adcp/hadcp/@HIVM}
\subsection{HIVM}
${}$
\begin{lstlisting}
 Index velocity method of Horizontal ADCP data

\end{lstlisting}
\section{lib/instrumentation/adcp/hadcp/@IVM}
\subsection{IVM}
${}$
\begin{lstlisting}
 index velocity method

\end{lstlisting}
\section{lib/instrumentation/adcp/hadcp}
\subsection{ESM}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{ESM\_individual}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{SDM}
${}$
\begin{lstlisting}
 Specific Discharge Method
 upscale specific discharge to cross sectionally integrate discharge,
  than average
 this method is provenly less accurate than averaging before upscaling

\end{lstlisting}
\subsection{VPM}
${}$
\begin{lstlisting}
 velocity profile method
 correct individual bin velocities for vertical velocity profile variation,
 then averagem, then upscale to cross sectionally integrated discharge

\end{lstlisting}
\subsection{hadcp\_homogenize\_profile}
${}$
\begin{lstlisting}
 homogenize the hadcp profile

\end{lstlisting}
\subsection{hadcp\_homogenize\_profile2}
${}$
\begin{lstlisting}
 homogenise the horizontal velocity profile

\end{lstlisting}
\subsection{wavg}
${}$
\begin{lstlisting}
 weighted average ?

\end{lstlisting}
\subsection{wavg\_mean}
${}$
\begin{lstlisting}
 weighted average

\end{lstlisting}
\subsection{wopt}
${}$
\begin{lstlisting}
 optimal weights for averaging (lumped) velocities that are each associated
 with error variance s2

\end{lstlisting}
\section{lib/instrumentation/adcp}
\begin{lstlisting}
adcp : processing of Acoustic Doppler Current Profiler (ADCP) data

Processing in 3 Levels:

Level 0 : Read in of raw-data (externally provided by ADCPtools, Vermeulen et al.)

Level 1 : VADCP, HADCP, SPADCP
	- convert raw data to CI units (m,s,kg)
	- transform velocities to arbitrary coordinate references
	- depth averaging and integration
	- fit velocity profiles
	- convert backscatter to suspended sediment concentration

Level 2 : CrossSection
	- interpolate and integrate for cross sections

Instruction:
	see and run saggau/sanggau_process_discharge for a working example
	to process VADCP discharge at a non-tidal station


\end{lstlisting}
\subsection{smooth\_track}
${}$
\begin{lstlisting}
 smooth a repeatedly navigated (circular) track to produce and idealized
 average track

\end{lstlisting}
\subsection{streawise\_velocity}
${}$
\begin{lstlisting}
 rotate ensembles in stream direction (transverse velocity integrates to zero)

\end{lstlisting}
\section{lib/instrumentation/adcp/test}
\subsection{example\_backscatter\_coefficient\_2}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{test\_backscatter\_coefficient}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{test\_bedslope}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{test\_delta\_z\_correction}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{test\_depth\_range}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{test\_linearisation}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{test\_procTrans\_vele}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{test\_rotvel}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{test\_sanggau\_load\_bed\_level\_2016}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{test\_sanggau\_rc}
${}$
\begin{lstlisting}

\end{lstlisting}
\section{lib/instrumentation/adcp}
\begin{lstlisting}
adcp : processing of Acoustic Doppler Current Profiler (ADCP) data

Processing in 3 Levels:

Level 0 : Read in of raw-data (externally provided by ADCPtools, Vermeulen et al.)

Level 1 : VADCP, HADCP, SPADCP
	- convert raw data to CI units (m,s,kg)
	- transform velocities to arbitrary coordinate references
	- depth averaging and integration
	- fit velocity profiles
	- convert backscatter to suspended sediment concentration

Level 2 : CrossSection
	- interpolate and integrate for cross sections

Instruction:
	see and run saggau/sanggau_process_discharge for a working example
	to process VADCP discharge at a non-tidal station


\end{lstlisting}
\subsection{zztransform}
${}$
\begin{lstlisting}
 non-linear mapping for bin coordinates when depth averages between ensembles
 for avaraging several ensembles

	preserve discharge w int u_avg dz = int int u dz dn = Q
	perserve shear stress is the same (u_avg)^2_s = mean((u_s)^2)
	preserve sediment transport w int u_avg c_avg dz = int int u c dz dn
      preserve rouse number

	alternative : correct parameters for effects of averaging

 several approaches :
 s-transform : z_1' = H0/H1 z_1, perserves u_bar
                                 does not preserve u_* (du/dz|_0)
 clipping    : z_1' = z_1, z_1 < H0, does not preserve u_bar
				       unclear if H0>H1
                                     perserves (du/dz)_0 (u_*)
 zz-transform : perserve both u_bar and u_
 TODO this is non-monotoneous when difference in H0 and H1 is large

\end{lstlisting}
\section{lib/instrumentation/pressure-gauge/@PressureGauge}
\subsection{PressureGauge}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{apply\_corrections}
${}$
\begin{lstlisting}
			obj.time(fdx)  = NaN;

\end{lstlisting}
\subsection{assign\_upstream\_km}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{check\_filetime}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{estimate\_altitude\_transducer}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{export\_csv}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{filter}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{merge}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{readIDC}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{readTxt}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{resample}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{stft}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{wavelet\_transform}
${}$
\begin{lstlisting}

\end{lstlisting}
\section{lib/instrumentation/sonar/@Sonar}
\subsection{Sonar}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{cat}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{compare}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{complete}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{equalise\_echo}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{export\_shp}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{export\_table}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{export\_xyz}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{from\_data}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{from\_dep}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{from\_sl2}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{from\_slg}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{from\_slg2txt}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{remove}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{select}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{to\_metric}
${}$
\begin{lstlisting}

\end{lstlisting}
\section{lib/instrumentation/sonar}
\subsection{DEP}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{DGPS}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{sortfiles}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{test\_loadSLG}
${}$
\begin{lstlisting}

\end{lstlisting}
\section{lib/mathematics/calendar}
\subsection{days\_per\_month}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{isnight}
${}$
\begin{lstlisting}

\end{lstlisting}
\section{lib/mathematics}
\begin{lstlisting}
mathematical functions of various kind

\end{lstlisting}
\subsection{cast\_byte\_to\_integer}
${}$
\begin{lstlisting}
 cast byte to integer

\end{lstlisting}
\section{lib/mathematics/complex-analysis}
\begin{lstlisting}
operations on complex numbers


\end{lstlisting}
\subsection{complex\_exp\_product\_im\_im}
${}$
\begin{lstlisting}
  product of the imaginary part of two complex exponentials

 the product has two frequency components

 input :
 	c : complex amplitudes
	o : frequencies
 output :
	cp : amplitude of the product
	op : frequencies of the product

\end{lstlisting}
\subsection{complex\_exp\_product\_im\_re}
${}$
\begin{lstlisting}
  product of the imaginary part of one and the real part of a second
  complex exponential

 the product has two frequency components

 input :
 	c : complex amplitudes
	o : frequencies
 output :
	cp : amplitude of the product
	op : frequencies of the product

\end{lstlisting}
\subsection{complex\_exp\_product\_re\_im}
${}$
\begin{lstlisting}

 the product has two frequency components

  product of the imaginary part of one and the real part of a second
  complex exponential

 input :
 	c : complex amplitudes
	o : frequencies
 output :
	cp : amplitude of the product
	op : frequencies of the product

\end{lstlisting}
\subsection{complex\_exp\_product\_re\_re}
${}$
\begin{lstlisting}

  product of the real part of two complex exponentials

 re(c1 exp(io1x))*re(c2 exp(io2x)) = 
	1/2*(     real(c1*c2*exp(i*(n1+n2)*o*x)) ...                            
               + real(conj(c1)*c2*exp(i*(n2-n1)*o*x)) )

 the product has two frequency components

 input :
 	c : complex amplitudes
	o : frequencies
 output :
	cp : amplitude of the product
	op : frequencies of the product

\end{lstlisting}
\subsection{croots}
${}$
\begin{lstlisting}
 nth-roots of a complex number

 input:
 c : complex number
 n : order of root
     n must be rational, to obtain n solutions
     otherwise no finite set of solutions exists

 r : roots of the complex number

\end{lstlisting}
\subsection{root\_complex}
${}$
\begin{lstlisting}
 root of a complex number

\end{lstlisting}
\subsection{test\_imroots}
${}$
\begin{lstlisting}

\end{lstlisting}
\section{lib/mathematics/derivation}
\begin{lstlisting}
derivation of several functions by means of symbolic computation


\end{lstlisting}
\subsection{derive\_acfar1}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{derive\_ar2param}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{derive\_arc\_length}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{derive\_fourier\_power}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{derive\_fourier\_power\_exp}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{derive\_laplacian\_curvilinear}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{derive\_laplacian\_fourier\_piecewise\_linear}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{derive\_logtripdf}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{derive\_smooth1d\_parametric}
${}$
\begin{lstlisting}

\end{lstlisting}
\section{lib/mathematics/derivation/master}
\subsection{derive\_bc\_one\_sided}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{derive\_convergence}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{derive\_error\_fdm}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{derive\_fdm\_poly}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{derive\_fdm\_power}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{derive\_fdm\_taylor}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{derive\_fdm\_vargrid}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{derive\_fem\_2d\_mass}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{derive\_fem\_error\_2d}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{derive\_fem\_error\_3d}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{derive\_fem\_sym\_2d}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{derive\_grid\_constants}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{derive\_interpolation}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{derive\_laplacian}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{derive\_limit}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{derive\_nc\_1d}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{derive\_nc\_1d\_}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{derive\_nc\_2d}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{derive\_nonuniform\_symmetric}
${}$
\begin{lstlisting}
%

\end{lstlisting}
\subsection{derive\_richardson}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{derive\_sum}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{nn}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{test\_derive}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{test\_derive\_fdm\_poly}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{test\_filter}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{test\_vargrid}
${}$
\begin{lstlisting}

\end{lstlisting}
\section{lib/mathematics/derivation}
\begin{lstlisting}
derivation of several functions by means of symbolic computation


\end{lstlisting}
\subsection{simplify\_atan}
${}$
\begin{lstlisting}
 symbolic simplification of the arcus tangent

\end{lstlisting}
\section{lib/mathematics}
\begin{lstlisting}
mathematical functions of various kind

\end{lstlisting}
\subsection{exp10}
${}$
\begin{lstlisting}

\end{lstlisting}
\section{lib/mathematics/finance}
\subsection{derive\_skewrnd\_walsh\_paramter}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{gbm\_cdf}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{gbm\_fit}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{gbm\_fit\_old}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{gbm\_inv}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{gbm\_mean}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{gbm\_median}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{gbm\_pdf}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{gbm\_simulate}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{gbm\_skewness}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{gbm\_std}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{gbm\_transform\_time\_step}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{put\_price\_black\_scholes}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{skewgbm\_simulate}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{skewrnd\_walsh}
${}$
\begin{lstlisting}

\end{lstlisting}
\section{lib/mathematics/finance/test}
\subsection{test\_gbm}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{test\_gbm\_pdf}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{test\_skewrnd\_walsh}
${}$
\begin{lstlisting}

\end{lstlisting}
\section{lib/mathematics/fourier/@STFT}
\subsection{STFT}
${}$
\begin{lstlisting}
 class for short time fourier transform

 Note: the interval Ti should be set to at leat 2*max(T), as otherwise coefficients
       tend to oscillate in the presence of noise
 Note: for convenience, the independent variable is labeled as time (t),
       but the independent variable is arbitrary, so it works likewise in space

\end{lstlisting}
\subsection{itransform}
${}$
\begin{lstlisting}
 inverse of the short time fourier transform

\end{lstlisting}
\subsection{stft\_}
${}$
\begin{lstlisting}
 static wrapper for STFT

\end{lstlisting}
\subsection{stftmat}
${}$
\begin{lstlisting}
 transformation matrix for the short time fourier transform

\end{lstlisting}
\subsection{transform}
${}$
\begin{lstlisting}
 short time fourier transform

\end{lstlisting}
\section{lib/mathematics/fourier}
\begin{lstlisting}
support and analysis functions both for the discrete (fast) fourier transform (dft/fft)
and continuous fourier analysis (fourier series)


\end{lstlisting}
\subsection{amplitude\_from\_peak}
${}$
\begin{lstlisting}
 amplitude and standard deviation of the amplitude of a frequency component
 represented by a peak in the fourier domain
 input :
 h : peak height
 w : peak width at half height

 output:
 a : amplitude in real space
 s : standard deviation of the frequency (!)

\end{lstlisting}
\subsection{dftmtx\_man}
${}$
\begin{lstlisting}
 fourier matrix in matlab style with a limited number of rows,
 columns of higher frequencies are omitted

 input :
 n  : number of samples
 nr : number of columns

 output :
 F : fourier matrix

\end{lstlisting}
\subsection{example\_fourier\_window}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{fft\_derivative}
${}$
\begin{lstlisting}
 derivative by fourier transform
 exponential convergence for periodic functions
 results in spurious oscillations for aperiodic functions

 input:
 x : data, sampled in equal intervals 
 k : order of the derivative

 dx : kth-derivative of x

\end{lstlisting}
\subsection{fft\_man}
${}$
\begin{lstlisting}
 fast fourier transform for complex input data

 input:
 F : data in real space

 output :

 F : fourier transformation of F


\end{lstlisting}
\subsection{fftsmooth}
${}$
\begin{lstlisting}
 smooth the fourier transform and determine upper and lower bound confidence intervals

 input :
 f :
 sfunc  : a smoothing function (for example fir convolution with rectangular window)
          returns filtered (mean) value and normalized fir window
 nf     : window length
 nsigma : number of standard deviations for confidnce intervals


 output :
 ff : filtered fourier transform
 l : lower bound
 u : upper bound

\end{lstlisting}
\subsection{fix\_fourier}
${}$
\begin{lstlisting}
 fill gaps (missing data) by means of fourier extrapolation

 fix periodic data series with fourier interpolation
 longest gap should not exceed 1/2 of the shortest time span of interest (1/cutoff frequency)
  note: this limit equals the position of first side lobe of the ft of a rectangular window with gap length

\end{lstlisting}
\subsection{fourier\_axis}
${}$
\begin{lstlisting}
 return axis of frequencies and periods for the discrete fourier transform
 as computed by fft (matlab-style)

 input:
 X : sample locations (equal interval)
 L : length of samples
 n : number of samples

 output :
 f    : frequencies
 T    : periods
 mask : mask for 1/2 of the fourier transform
        (as both halves are complex conjugates)
 N    : frequency id

\end{lstlisting}
\subsection{fourier\_cesaro\_correction}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{fourier\_coefficient\_piecewise\_linear}
${}$
\begin{lstlisting}
 fourier series coefficients of a piecewise linear function
 (not coefficient of discrete fourier transform)
 function can be discontinuous between intervals
 scales domain length to 2pi

 input :
 l,r : end points of piecewise linear function
 lval, rval : values at end points
 L : length of domain
 n : number of samples/highest frequency   

 output :
 a, b : coefficients for frequency components

\end{lstlisting}
\subsection{fourier\_coefficient\_piecewise\_linear\_1}
${}$
\begin{lstlisting}
 fourier series coefficients of a piecewise linear function
 (not coefficient of discrete fourier transform)
 function can be discontinuous between intervals
 scales domain length to 2pi

 input :
 X : end points of piecewise linear function
 Y : values at end points
 
 output :
 ab : coefficients for frequency components

\end{lstlisting}
\subsection{fourier\_coefficient\_ramp3}
${}$
\begin{lstlisting}
 fourier series coefficient of a ramp

\end{lstlisting}
\subsection{fourier\_coefficient\_ramp\_pulse}
${}$
\begin{lstlisting}
 fourier series coefficient of a ramp pules

\end{lstlisting}
\subsection{fourier\_coefficient\_ramp\_step}
${}$
\begin{lstlisting}
 fourier coefficient of a ramp-step

\end{lstlisting}
\subsection{fourier\_coefficient\_square\_pulse}
${}$
\begin{lstlisting}
 fourier series coefficients of a square pulse

\end{lstlisting}
\subsection{fourier\_cubic\_interaction\_coefficients}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{fourier\_derivative}
${}$
\begin{lstlisting}
 coefficients of the derivative of a fourier series
 not of discrete fourier transform (fft) 

\end{lstlisting}
\subsection{fourier\_expand}
${}$
\begin{lstlisting}
 expand values of fourier series

\end{lstlisting}
\subsection{fourier\_fit}
${}$
\begin{lstlisting}
 fit a fourier series to a set of sample points that are not spaced in
 equal intervals

\end{lstlisting}
\subsection{fourier\_interpolate}
${}$
\begin{lstlisting}
 interpolate samples y sampled at moments (location) t to locations ti

\end{lstlisting}
\subsection{fourier\_matrix}
${}$
\begin{lstlisting}
 transformation matrix for a continuous fourier series
 (not for the discrete dft/fft)

\end{lstlisting}
\subsection{fourier\_matrix2}
${}$
\begin{lstlisting}
 transformation matrix for a continuous fourier series
 (not for the discrete dft/fft)

\end{lstlisting}
\subsection{fourier\_matrix3}
${}$
\begin{lstlisting}
 transformation matrix for the continous fourier transform
 this is a matrix with (2*n+1) real columns

\end{lstlisting}
\subsection{fourier\_matrix\_exp}
${}$
\begin{lstlisting}
 transformation matrix for a continuous fourier series
 (not for the discrete dft/fft)

\end{lstlisting}
\subsection{fourier\_multiplicative\_interaction\_coefficients}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{fourier\_power}
${}$
\begin{lstlisting}
 powers of a continuous fourier series in sin/cos form

 powers of a^p = (ur + u1 sin(ot) + u2 sin(ot+dp))^p
 phase of first component assumed 0

 frequencies higher than 2-omega ignored in input
 frequencies higher than 3-omega not computed

\end{lstlisting}
\subsection{fourier\_power\_exp}
${}$
\begin{lstlisting}
 powers of the continuous fourier series 
 	a^p = (ur + u1 sin(ot) + u2 sin(ot+dp))^p
 phase of first component assumed 0
 
 higher orders than 2 ignored input
 higher order than 3 not computed in output

 y = a_0 + sum (a_j sin(jot) + b_j cos(jot))
   = Real(sum_{i=0}^inf c_i exp(1i*omega), c_i = a_i + b_i

 NOT the alternative sum_{i=-inf}^inf \tilde c_i, tile c_j = 1/2 a_j + 1/2i b_j

\end{lstlisting}
\subsection{fourier\_predict}
${}$
\begin{lstlisting}
 expand a continous fourier series at times t

\end{lstlisting}
\subsection{fourier\_quadratic\_interaction\_coefficients}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{fourier\_range}
${}$
\begin{lstlisting}
 approximate range of a continous Fourier series with 2 components
 range(y) = max(y) - min(y)

\end{lstlisting}
\subsection{fourier\_regress}
${}$
\begin{lstlisting}
 fit a continous fourier series to a set of sample points not sampled
 at equal intervals

\end{lstlisting}
\subsection{fourier\_resampled\_fit}
${}$
\begin{lstlisting}
 fits coefficients of a continuous fourier transform,
 but stores them as resampled values

\end{lstlisting}
\subsection{fourier\_resampled\_predict}
${}$
\begin{lstlisting}
 interpolates a continuous fourier series that has been stored as values
 at their support points

\end{lstlisting}
\subsection{fourier\_signed\_square}
${}$
\begin{lstlisting}
 coefficients of the fourier series of | cos a + cos t | (cos a + cos t)
 in general
            cos a is midrange
            cos t is tidal variation
 c.f Dronkers

\end{lstlisting}
\subsection{fourier\_transform}
${}$
\begin{lstlisting}
 continuous fourier transformation of y
 (not discrete fourier transformation dft/fft)

 input:
	b : data sampled at equal intervals
	T : length of data in time or space, i.e. position of last sample if
	    position of first sample is 0
       T_max : maximum period to include
 
 output :
	A  : fourier matrix
       p  : fourier transformation of b
	tt : TODO 

\end{lstlisting}
\subsection{hyperbolic\_fourier\_box}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{idftmtx\_man}
${}$
\begin{lstlisting}
 inverse matrix for the discrete fourier transform in matlab style
 with a limited number of columns, thus ignoring higher frequencies
 keep 2nc+1 columns (mean and conj-complex pairs of nc frequencies)

\end{lstlisting}
\subsection{laplace\_2d\_pwlinear}
${}$
\begin{lstlisting}
 solution to the Laplacian in two dimensions for a finite rectangular domain
 with piecewise constant boundary conditions
 linear system with 4 unknowns per freqency component
 these are coefficients of s,c,sh,ch
	(pu*(s + c) + qu*(s' + c'))*(shu + chu) = ru		% upper bc
	(pd*(s + c) + qd*(s' + c'))*(shd + chd) = rd		% lower bc
	( (sl + cl)*( pl*(shl + chl) + ql*(shl' + chl')) = rl	% left bc
	( (sr + cr)*( pr*(shr + chr) + qr*(shr' + chr')) = rr	% right bc

  least squares with piecewise integration
 [x0,p,q,r] piecewise linear polynomials at the boundaries

\end{lstlisting}
\subsection{nanfft}
${}$
\begin{lstlisting}
 discrete fourier transform of a data series with gaps

\end{lstlisting}
\subsection{peaks}
${}$
\begin{lstlisting}
 peaks of the power spectrum of a disctrete fourier transform

 rule for peaks: there is no higher value left or right of the "peak"
                 until the signal drops to p*y_peak, p = 0.5

 works best, when spectrum has been smoothened

 input :
 f : frequency
 y : absolute value of fourier transform (power spectrum)
 L : length in space or time of series

 output :

 a0 : amplitude
 s0 : standard deviation (error?) of amplitude
 w0 : width of peak
 lambda = wave length (period?)
 pdx : index of peak
 f : frequency (if not given as input) 

\end{lstlisting}
\subsection{roots\_fourier}
${}$
\begin{lstlisting}
 zeros of continuous fourier series series

	f  = a_0 + sum_j=^n a_i cos(j x) + b_i sin(j x)

\end{lstlisting}
\subsection{spectral\_density}
${}$
\begin{lstlisting}
 spectral density

\end{lstlisting}
\subsection{test\_complex\_exp\_product}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{test\_fourier\_filter}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{test\_idftmtx}
${}$
\begin{lstlisting}

\end{lstlisting}
\section{lib/mathematics/geometry/@Geometry}
\subsection{Geometry}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{arclength}
${}$
\begin{lstlisting}
 arc length of a two dimensional curve

 8th order accurate
 does not require the segments length to vary smoothly

 note: the curve can be considered parametric, e.g. x = x(t), y=y(t) and
 	and t = t(s), but the error term contains derivatives of t,
      thus a non smooth t (strongly varying distance between points)
      requires the scaling as done below

\end{lstlisting}
\subsection{arclength\_old}
${}$
\begin{lstlisting}
 arc length of a two dimensional function

\end{lstlisting}
\subsection{arclength\_old2}
${}$
\begin{lstlisting}
 arc length of a two dimensional function

\end{lstlisting}
\subsection{base\_point}
${}$
\begin{lstlisting}
 base point (fusspunkt), i.e. point on a line with shortest distance
 to another point

\end{lstlisting}
\subsection{base\_point\_limited}
${}$
\begin{lstlisting}
 base point (Fusspunkt) of a point on a line

\end{lstlisting}
\subsection{centroid}
${}$
\begin{lstlisting}
 centroid pf a polygone

\end{lstlisting}
\subsection{cosa\_min\_max}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{cross2}
${}$
\begin{lstlisting}
 cross product in two dimensions

\end{lstlisting}
\subsection{curvature}
${}$
\begin{lstlisting}
 curvature of a function in two dimensions

\end{lstlisting}
\subsection{ddot}
${}$
\begin{lstlisting}
 sum of squares of cos of inner angles of triangle

\end{lstlisting}
\subsection{distance}
${}$
\begin{lstlisting}
 equclidan distance between two points

\end{lstlisting}
\subsection{distance2}
${}$
\begin{lstlisting}
 euclidean distance between two points
 this function requires a and be of equal dimensions, or the least the first pair or second pair to be a scalar

\end{lstlisting}
\subsection{dot}
${}$
\begin{lstlisting}
 dot product

\end{lstlisting}
\subsection{edge\_length}
${}$
\begin{lstlisting}
 edge length

\end{lstlisting}
\subsection{enclosed\_angle}
${}$
\begin{lstlisting}
 angle enclosed between two lines

\end{lstlisting}
\subsection{enclosing\_triangle}
${}$
\begin{lstlisting}
 smallest enclosing equilateral triangle with bottom site paralle to X axis

\end{lstlisting}
\subsection{hexagon}
${}$
\begin{lstlisting}
 coordinates of a hexagon, scaled and rotated

\end{lstlisting}
\subsection{inPolygon}
${}$
\begin{lstlisting}
 flag points contained in a polygon
 much faster than matlab internal function

\end{lstlisting}
\subsection{inTetra}
${}$
\begin{lstlisting}
 flag points contained in tetrahedron

\end{lstlisting}
\subsection{inTetra2}
${}$
\begin{lstlisting}
 flag points contained in tetrahedron

\end{lstlisting}
\subsection{inTriangle}
${}$
\begin{lstlisting}
 flag points contained in triangle
 function [flag, c] = inTriangle(P1,P2,P3,P0)

\end{lstlisting}
\subsection{intersect}
${}$
\begin{lstlisting}
 intersect between two lines

\end{lstlisting}
\subsection{lineintersect}
${}$
\begin{lstlisting}
 intersect of two lines

\end{lstlisting}
\subsection{lineintersect1}
${}$
\begin{lstlisting}
 intersect of two lines

\end{lstlisting}
\subsection{minimum\_distance\_lines}
${}$
\begin{lstlisting}
 minimum distance of two lines in three dimensions

\end{lstlisting}
\subsection{mittenpunkt}
${}$
\begin{lstlisting}
 mittenpunkt of a triangle

\end{lstlisting}
\subsection{nagelpoint}
${}$
\begin{lstlisting}
 nagelpoint of a triangle

\end{lstlisting}
\subsection{onLine}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{orthocentre}
${}$
\begin{lstlisting}
 orthocentre of triangle

\end{lstlisting}
\subsection{plumb\_line}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{poly\_area}
${}$
\begin{lstlisting}
 area of a polygon
 function A = poly_area(x,y)

\end{lstlisting}
\subsection{poly\_edges}
${}$
\begin{lstlisting}
 edges of a polygon

\end{lstlisting}
\subsection{poly\_set}
${}$
\begin{lstlisting}
 associate point at arbitary location with a polygon it is contained in
 and assign the value of the polygon to it

\end{lstlisting}
\subsection{poly\_width}
${}$
\begin{lstlisting}
 width of polygon width holes by surface normals
 holes / islands separated with NaN
 order of points of outer boundary must be cw
 order of points of holes must be ccw
 note that this function does not give the true width for expanding sections
 use voronoi polygons for this

\end{lstlisting}
\subsection{polyxpoly}
${}$
\begin{lstlisting}
 intersections of two polygons

\end{lstlisting}
\subsection{project\_to\_curve}
${}$
\begin{lstlisting}
 closest point on a curve with respect to a point at distance to the curve

\end{lstlisting}
\subsection{quad\_isconvex}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{random\_disk}
${}$
\begin{lstlisting}
 draw random points on the unit disk

\end{lstlisting}
\subsection{random\_simplex}
${}$
\begin{lstlisting}
 random point inside of a triangle

\end{lstlisting}
\subsection{sphere\_volume}
${}$
\begin{lstlisting}
 volume of a sphere

\end{lstlisting}
\subsection{tetra\_volume}
${}$
\begin{lstlisting}
 volume of a tetrahedron

\end{lstlisting}
\subsection{tobarycentric}
${}$
\begin{lstlisting}
 cartesian to barycentric coordinates

\end{lstlisting}
\subsection{tobarycentric1}
${}$
\begin{lstlisting}
 cartesian to barycentric coordinates

\end{lstlisting}
\subsection{tobarycentric2}
${}$
\begin{lstlisting}
 cartesian to barycentric coordinates

\end{lstlisting}
\subsection{tobarycentric3}
${}$
\begin{lstlisting}
 cartesian to barycentric coordinates

\end{lstlisting}
\subsection{tri\_angle}
${}$
\begin{lstlisting}
 cos of angles of a triangle

\end{lstlisting}
\subsection{tri\_area}
${}$
\begin{lstlisting}
 angle of a triangle

\end{lstlisting}
\subsection{tri\_centroid}
${}$
\begin{lstlisting}
 centroid of a triangle

\end{lstlisting}
\subsection{tri\_distance\_opposit\_midpoint}
${}$
\begin{lstlisting}
 distance between corner of a triangle and its opposing mid-point

\end{lstlisting}
\subsection{tri\_edge\_length}
${}$
\begin{lstlisting}
 edge length of a triangle

\end{lstlisting}
\subsection{tri\_edge\_midpoint}
${}$
\begin{lstlisting}
 mid point of a triangle

\end{lstlisting}
\subsection{tri\_excircle}
${}$
\begin{lstlisting}
 excircle of a triangle

\end{lstlisting}
\subsection{tri\_height}
${}$
\begin{lstlisting}
 height of a triangle

\end{lstlisting}
\subsection{tri\_incircle}
${}$
\begin{lstlisting}
 incircle of a triangle

\end{lstlisting}
\subsection{tri\_isacute}
${}$
\begin{lstlisting}
 flag acute triangles

\end{lstlisting}
\subsection{tri\_isobtuse}
${}$
\begin{lstlisting}
 flag obntuse triangles

\end{lstlisting}
\subsection{tri\_semiperimeter}
${}$
\begin{lstlisting}
 semiperimeter of a triangle

\end{lstlisting}
\subsection{tri\_side\_length}
${}$
\begin{lstlisting}
 edge lenght of triangle

\end{lstlisting}
\section{lib/mathematics/geometry}
\subsection{Polygon}
${}$
\begin{lstlisting}
 Simple 2D polygon class

   Polygon properties:
       x - x coordinates of polygon
       y - y coordinates of polygon
       nnodes - number of nodes in the polygon

   Polygon methods:
       in - checks whether given points lie inside, on the edge, or outside of the polygon
       area - returns the area of the polygon
       centerline - computes the centerline of the river
       iscw - check whether polygon is clockwise
       reverse - reverse the order of the polygon

\end{lstlisting}
\subsection{bounding\_box}
${}$
\begin{lstlisting}
 bounding box of X

\end{lstlisting}
\subsection{curvature\_1d}
${}$
\begin{lstlisting}
 curvature of a sampled parametric curve in two dimensions

\end{lstlisting}
\subsection{cvt}
${}$
\begin{lstlisting}
 centroidal voronoi tesselation

\end{lstlisting}
\subsection{deg\_to\_frac}
${}$
\begin{lstlisting}
 degree, minutes and seconds to fractions

\end{lstlisting}
\subsection{ellipse}
${}$
\begin{lstlisting}
 n-points on an ellipse

\end{lstlisting}
\subsection{ellipseX}
${}$
\begin{lstlisting}
 x-coordinates of y-coordinates of an ellipse

\end{lstlisting}
\subsection{ellipseY}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{first\_intersect}
${}$
\begin{lstlisting}
 get first intersection between lines in A and B

\end{lstlisting}
\subsection{golden\_ratio}
${}$
\begin{lstlisting}
 golden ratio

\end{lstlisting}
\subsection{hypot3}
${}$
\begin{lstlisting}
 hypothenuse in 3D

\end{lstlisting}
\subsection{meanangle}
${}$
\begin{lstlisting}
 weighted mean of angles

\end{lstlisting}
\subsection{meanangle2}
${}$
\begin{lstlisting}
 mean angle

\end{lstlisting}
\subsection{meanangle3}
${}$
\begin{lstlisting}
 mean angle

\end{lstlisting}
\subsection{meanangle4}
${}$
\begin{lstlisting}
 mean angle

\end{lstlisting}
\subsection{medianangle}
${}$
\begin{lstlisting}
 median angle
 angle, that has the smallest squared distance to all others

\end{lstlisting}
\subsection{medianangle2}
${}$
\begin{lstlisting}
 median angle

 input
 alpha : x*m, [rad] angle

 ouput
 ma    : 1*m, [rad] median angle
 sa    : 1*m, [rad] standard error of median angle for uncorrelated error

\end{lstlisting}
\subsection{pilim}
${}$
\begin{lstlisting}
 limit to +- pi

\end{lstlisting}
\subsection{streamline\_radius\_of\_curvature}
${}$
\begin{lstlisting}
 streamline radius of curvature
 simplifies when rotatate to streamwise coordinates to R = 1/dv/ds * u

\end{lstlisting}
\section{lib/mathematics/histogram/@Histogram}
\subsection{2x}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{Histogram}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{bimodes}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{cdf}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{cdfS}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{chi2test}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{cmoment}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{cmomentS}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{entropy}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{entropyS}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{iquantile}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{kstest}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{kurtosis}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{kurtosisS}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{mean}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{meanS}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{median}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{medianS}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{mode}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{modeS}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{moment}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{momentS}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{pdf}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{quantile}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{quantileS}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{setup}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{skewness}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{skewnessS}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{stairs}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{stairsS}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{std}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{stdS}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{var}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{varS}
${}$
\begin{lstlisting}

\end{lstlisting}
\section{lib/mathematics/histogram}
\subsection{hist\_man}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{histadapt}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{histconst}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{pdf\_poly}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{plotcdf}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{test\_histogram}
${}$
\begin{lstlisting}

\end{lstlisting}
\section{lib/mathematics/linear-algebra}
\subsection{averaging\_matrix\_2}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{colnorm}
${}$
\begin{lstlisting}
 norms of columns

\end{lstlisting}
\subsection{condest\_}
${}$
\begin{lstlisting}
 estimation of the condition number

\end{lstlisting}
\section{lib/mathematics/linear-algebra/coordinate-transformation}
\subsection{barycentric2cartesian}
${}$
\begin{lstlisting}
 barycentric to cartesian coordinates

\end{lstlisting}
\subsection{barycentric2cartesian3}
${}$
\begin{lstlisting}
 convert barycentric to cartesian coordinates

\end{lstlisting}
\subsection{cartesian2barycentric}
${}$
\begin{lstlisting}
 cartesian to barycentric coordinates

\end{lstlisting}
\subsection{cartesian\_to\_unit\_triangle\_basis}
${}$
\begin{lstlisting}
 transform coodinates into unit triangle

\end{lstlisting}
\subsection{ellipsoid2geoid}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{example\_approximate\_utm\_conversion}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{latlon2utm}
${}$
\begin{lstlisting}
 transform latitude and longitude to WGS84 UTM

\end{lstlisting}
\subsection{latlon2utm\_simple}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{lowrance\_mercator\_to\_wgs84}
${}$
\begin{lstlisting}
 convert lowrance coordinates to wgs84

 based on spreadsheet by D Whitney King and Patty B at Lowrance

\end{lstlisting}
\subsection{nmea2utm}
${}$
\begin{lstlisting}
 convert nmea messages to utm coordinates

\end{lstlisting}
\subsection{sn2xy}
${}$
\begin{lstlisting}
 convert sn to xy coordinates

\end{lstlisting}
\subsection{unit\_triangle\_to\_cartesian}
${}$
\begin{lstlisting}
 transform coordinates in unit triangle to cartesian coordinates

\end{lstlisting}
\subsection{utm2latlon}
${}$
\begin{lstlisting}
 convert wgs84 utm to latitute and longitude

\end{lstlisting}
\subsection{xy2nt}
${}$
\begin{lstlisting}
 project all points onto the cross section and assign them nz-coordinates

 transform coordinate into N-T reference
 rotate coordinate, so that cross section goes along x-axis
 then x and y are n and t respectively scaled by width
 N and T coordinates

\end{lstlisting}
\subsection{xy2sn}
${}$
\begin{lstlisting}
 convert cartesian to streamwise coordiantes

\end{lstlisting}
\subsection{xy2sn\_java}
${}$
\begin{lstlisting}
 use java port for speed up

\end{lstlisting}
\subsection{xy2sn\_old}
${}$
\begin{lstlisting}
 transform points from cartesian into streamwise coordinates

 NOTE : prefer the java version, this has some problems with round off

\end{lstlisting}
\section{lib/mathematics/linear-algebra}
\subsection{det2x2}
${}$
\begin{lstlisting}
 2x2 matrix inverse of 2x2 matrices stacked along dim 3

\end{lstlisting}
\subsection{det3x3}
${}$
\begin{lstlisting}
 determinant of stacked 3x3 matrices

\end{lstlisting}
\subsection{det4x4}
${}$
\begin{lstlisting}
 determinant of stacked 4x4 matrices

\end{lstlisting}
\subsection{diag2x2}
${}$
\begin{lstlisting}
 diagonal of stacked 2x2 matrices

\end{lstlisting}
\subsection{eig2x2}
${}$
\begin{lstlisting}
 eigenvalues of stacked 2x2 matrices

\end{lstlisting}
\section{lib/mathematics/linear-algebra/eigenvalue}
\subsection{eig\_bisection}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{eig\_inverse}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{eig\_inverse\_iteration}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{eig\_power\_iteration}
${}$
\begin{lstlisting}

\end{lstlisting}
\section{lib/mathematics/linear-algebra/eigenvalue/jacobi-davidson}
\subsection{afun\_jdm}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{davidson}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{jacobi\_davidson}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{jacobi\_davidson\_qr}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{jacobi\_davidson\_qz}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{jacobi\_davidson\_simple}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{jdqr}
${}$
\begin{lstlisting}
% Read/set parameters
% Initiate global variables
% Return if eigenvalueproblem is trivial
% Initialize V, W:
%   V,W orthonormal, A*V=W*R+Qschur*E, R upper triangular
% The JD loop (Standard)
%    V orthogonal, V orthogonal to Qschur
%    V*V=eye(j), Qschur'*V=0, 
%    W=A*V, M=V'*W
%
% Compute approximate eigenpair and residual
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%
%
%
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Check for convergence
% Expand the partial Schur form
 Rschur=[[Rschur;zeros(1,k)],Qschur'*MV(u)]; k=k+1; 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Expand preconditioned Schur matrix PinvQ
% Check for shrinking the search subspace
% Solve correction equation
% Expand the subspaces of the interaction matrix  
% The JD loop (Harmonic Ritz values)
%    Both V and W orthonormal and orthogonal w.r.t. Qschur
%    V*V=eye(j), Qschur'*V=0, W'*W=eye(j), Qschur'*W=0
%    (A*V-tau*V)=W*R+Qschur*E, E=Qschur'*(A*V-tau*V), M=W'*V
%
% Compute approximate eigenpair and residual
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%
%
%
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Check for convergence
% Expand the partial Schur form
 Rschur=[[Rschur;zeros(1,k)],Qschur'*MV(u)]; k=k+1;
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Expand preconditioned Schur matrix PinvQ
% Check for shrinking the search subspace
% Solve correction equation
% Expand the subspaces of the interaction matrix  
% The JD loop (Harmonic Ritz values)
%    V W AV.
%    Both V and W orthonormal and orthogonal w.r.t. Qschur, AV=A*V-tau*V
%    V*V=eye(j),  W'*W=eye(j), Qschur'*V=0, Qschur'*W=0, 
%    (I-Qschur*Qschur')*AV=W*R, M=W'*V; R=W'*AV;
%
% Compute approximate eigenpair and residual
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%
%
%
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Check for convergence
% Expand the partial Schur form
 Rschur=[[Rschur;zeros(1,k)],Qschur'*MV(u)]; k=k+1;
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Expand preconditioned Schur matrix PinvQ
% Check for shrinking the search subspace
% Solve correction equation
% Expand the subspaces of the interaction matrix  
% The JD loop (Harmonic Ritz values)
%    W orthonormal, V and W orthogonal to Qschur, 
%    W'*W=eye(j), Qschur'*V=0, Qschur'*W=0
%    W=(A*V-tau*V)-Qschur*E, E=Qschur'*(A*V-tau*V), 
%    M=W'*V
% Compute approximate eigenpair and residual
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%
%
%
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Check for convergence
% Expand the partial Schur form
 Rschur=[[Rschur;zeros(1,k)],Qschur'*MV(u)]; k=k+1;
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Expand preconditioned Schur matrix PinvQ
% Check for shrinking the search subspace
% Solve correction equation
% Expand the subspaces of the interaction matrix  
 W=V*Q; V=V(:,1:j)/R; E=E/R; R=eye(j); M=Q(1:j,:)'/R;
 W=V*H; V(:,j+1)=[];R=R'*R;   M=H(1:j,:)';
%======== ARNOLDI (for initializing spaces) ===============================
%=========== END ARNOLDI ============================================  
% not accurate enough M=Rw'\(M/Rv);
%=========== COMPUTE SORTED JORDAN FORM ==================================
% compute vectors and matrices for skew projection
% solve preconditioned system
% 0 step of bicgstab eq. 1 step of bicgstab
% Then x is a multiple of b
% HIST=[0,1]; 
 explicit preconditioning
% compute norm in l-space
%  HIST=[HIST;[nmv,rnrm/snrm]];
% sufficient accuracy. No need to update r,u
 implicit preconditioning
% collect the updates for x in l-space
% but, do the orth to Q implicitly
% compute norm in l-space
% HIST=[HIST;[nmv,rnrm/snrm]];
% sufficient accuracy. No need to update r,u
% Do the orth to Q explicitly
% In exact arithmetic not needed, but
% appears to be more stable.
%  plot(HIST(:,1),log10(HIST(:,2)+eps),'*'), drawnow, pause
% 0 step of gmres eq. 1 step of gmres
% Then x is a multiple of b
%======================================================================
% 0 step of gmres eq. 1 step of gmres
% Then x is a multiple of b
 HIST=1; 
% Lucky break-down
 HIST=[HIST;(gamma~=0)/sqrt(rho)]; 
% Lucky break-down
% solve in least square sense 
 HIST=log10(HIST+eps); J=[0:size(HIST,1)-1]';
 plot(J,HIST(:,1),'*'); drawnow,% pause
 r=r/rho; rho=1; 
%  HIST=rho;
%  HIST=[HIST;rho];
 HIST=log10(HIST+eps); J=[0:size(HIST,1)-1]';
 plot(J,HIST(:,1),'*'); drawnow,% pause
% HIST = rho;
%  HIST=[HIST;rho];
 HIST=log10(HIST+eps); J=[0:size(HIST,1)-1]';
 plot(J,HIST(:,1),'*'); drawnow, pause
% HIST = rho;
%  HIST=[HIST;rho];
 HIST=log10(HIST+eps); J=[0:size(HIST,1)-1]';
 plot(J,HIST(:,1),'*'); drawnow, pause
%------ compute schur form -------------
 A*Q=Q*S, Q'*Q=eye(size(A));
% transform real schur form to complex schur form
%------ find order eigenvalues ---------------
%------ reorder schur form ----------------
%------ compute qz form ----------------
%------ sort eigenvalues ---------------
%------ sort qz form -------------------
% i>j, move ith eigenvalue to position j 
% determine dimension
% defaults
%% 'v'

\end{lstlisting}
\subsection{jdqr\_sleijpen}
${}$
\begin{lstlisting}
% Read/set parameters
% Initiate global variables
% Return if eigenvalueproblem is trivial
% Initialize V, W:
%   V,W orthonormal, A*V=W*R+Qschur*E, R upper triangular
% The JD loop (Standard)
%    V orthogonal, V orthogonal to Qschur
%    V*V=eye(j), Qschur'*V=0, 
%    W=A*V, M=V'*W
%
% Compute approximate eigenpair and residual
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%
%
%
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Check for convergence
% Expand the partial Schur form
 Rschur=[[Rschur;zeros(1,k)],Qschur'*MV(u)]; k=k+1; 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Expand preconditioned Schur matrix PinvQ
% Check for shrinking the search subspace
% Solve correction equation
% Expand the subspaces of the interaction matrix  
% The JD loop (Harmonic Ritz values)
%    Both V and W orthonormal and orthogonal w.r.t. Qschur
%    V*V=eye(j), Qschur'*V=0, W'*W=eye(j), Qschur'*W=0
%    (A*V-tau*V)=W*R+Qschur*E, E=Qschur'*(A*V-tau*V), M=W'*V
%
% Compute approximate eigenpair and residual
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%
%
%
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Check for convergence
% Expand the partial Schur form
 Rschur=[[Rschur;zeros(1,k)],Qschur'*MV(u)]; k=k+1;
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Expand preconditioned Schur matrix PinvQ
% Check for shrinking the search subspace
% Solve correction equation
% Expand the subspaces of the interaction matrix  
% The JD loop (Harmonic Ritz values)
%    V W AV.
%    Both V and W orthonormal and orthogonal w.r.t. Qschur, AV=A*V-tau*V
%    V*V=eye(j),  W'*W=eye(j), Qschur'*V=0, Qschur'*W=0, 
%    (I-Qschur*Qschur')*AV=W*R, M=W'*V; R=W'*AV;
%
% Compute approximate eigenpair and residual
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%
%
%
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Check for convergence
% Expand the partial Schur form
 Rschur=[[Rschur;zeros(1,k)],Qschur'*MV(u)]; k=k+1;
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Expand preconditioned Schur matrix PinvQ
% Check for shrinking the search subspace
% Solve correction equation
% Expand the subspaces of the interaction matrix  
% The JD loop (Harmonic Ritz values)
%    W orthonormal, V and W orthogonal to Qschur, 
%    W'*W=eye(j), Qschur'*V=0, Qschur'*W=0
%    W=(A*V-tau*V)-Qschur*E, E=Qschur'*(A*V-tau*V), 
%    M=W'*V
% Compute approximate eigenpair and residual
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%
%
%
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Check for convergence
% Expand the partial Schur form
 Rschur=[[Rschur;zeros(1,k)],Qschur'*MV(u)]; k=k+1;
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Expand preconditioned Schur matrix PinvQ
% Check for shrinking the search subspace
% Solve correction equation
% Expand the subspaces of the interaction matrix  
 W=V*Q; V=V(:,1:j)/R; E=E/R; R=eye(j); M=Q(1:j,:)'/R;
 W=V*H; V(:,j+1)=[];R=R'*R;   M=H(1:j,:)';
%======== ARNOLDI (for initializing spaces) ===============================
%=========== END ARNOLDI ============================================  
% not accurate enough M=Rw'\(M/Rv);
%=========== COMPUTE SORTED JORDAN FORM ==================================
% compute vectors and matrices for skew projection
% solve preconditioned system
% 0 step of bicgstab eq. 1 step of bicgstab
% Then x is a multiple of b
% HIST=[0,1]; 
 explicit preconditioning
% compute norm in l-space
%  HIST=[HIST;[nmv,rnrm/snrm]];
% sufficient accuracy. No need to update r,u
 implicit preconditioning
% collect the updates for x in l-space
% but, do the orth to Q implicitly
% compute norm in l-space
% HIST=[HIST;[nmv,rnrm/snrm]];
% sufficient accuracy. No need to update r,u
% Do the orth to Q explicitly
% In exact arithmetic not needed, but
% appears to be more stable.
%  plot(HIST(:,1),log10(HIST(:,2)+eps),'*'), drawnow, pause
% 0 step of gmres eq. 1 step of gmres
% Then x is a multiple of b
%======================================================================
% 0 step of gmres eq. 1 step of gmres
% Then x is a multiple of b
 HIST=1; 
% Lucky break-down
 HIST=[HIST;(gamma~=0)/sqrt(rho)]; 
% Lucky break-down
% solve in least square sense 
 HIST=log10(HIST+eps); J=[0:size(HIST,1)-1]';
 plot(J,HIST(:,1),'*'); drawnow,% pause
 r=r/rho; rho=1; 
%  HIST=rho;
%  HIST=[HIST;rho];
 HIST=log10(HIST+eps); J=[0:size(HIST,1)-1]';
 plot(J,HIST(:,1),'*'); drawnow,% pause
% HIST = rho;
%  HIST=[HIST;rho];
 HIST=log10(HIST+eps); J=[0:size(HIST,1)-1]';
 plot(J,HIST(:,1),'*'); drawnow, pause
% HIST = rho;
%  HIST=[HIST;rho];
 HIST=log10(HIST+eps); J=[0:size(HIST,1)-1]';
 plot(J,HIST(:,1),'*'); drawnow, pause
%------ compute schur form -------------
 A*Q=Q*S, Q'*Q=eye(size(A));
% transform real schur form to complex schur form
%------ find order eigenvalues ---------------
%------ reorder schur form ----------------
%------ compute qz form ----------------
%------ sort eigenvalues ---------------
%------ sort qz form -------------------
% i>j, move ith eigenvalue to position j 
% determine dimension
% defaults
%% 'v'

\end{lstlisting}
\subsection{jdqr\_vorst}
${}$
\begin{lstlisting}
% Read/set parameters
% Initiate global variables
% Return if eigenvalueproblem is trivial
% Initialize V, W:
%   V,W orthonormal, A*V=W*R+Qschur*E, R upper triangular
% The JD loop (Standard)
%    V orthogonal, V orthogonal to Qschur
%    V*V=eye(j), Qschur'*V=0, 
%    W=A*V, M=V'*W
%
% Compute approximate eigenpair and residual
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%
%
%
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Check for convergence
% Expand the partial Schur form
 Rschur=[[Rschur;zeros(1,k)],Qschur'*MV(u)]; k=k+1; 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Expand preconditioned Schur matrix PinvQ
% Check for shrinking the search subspace
% Solve correction equation
% Expand the subspaces of the interaction matrix  
% The JD loop (Harmonic Ritz values)
%    Both V and W orthonormal and orthogonal w.r.t. Qschur
%    V*V=eye(j), Qschur'*V=0, W'*W=eye(j), Qschur'*W=0
%    (A*V-tau*V)=W*R+Qschur*E, E=Qschur'*(A*V-tau*V), M=W'*V
%
% Compute approximate eigenpair and residual
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%
%
%
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Check for convergence
% Expand the partial Schur form
 Rschur=[[Rschur;zeros(1,k)],Qschur'*MV(u)]; k=k+1;
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Expand preconditioned Schur matrix PinvQ
% Check for shrinking the search subspace
% Solve correction equation
% Expand the subspaces of the interaction matrix  
% The JD loop (Harmonic Ritz values)
%    V W AV.
%    Both V and W orthonormal and orthogonal w.r.t. Qschur, AV=A*V-tau*V
%    V*V=eye(j),  W'*W=eye(j), Qschur'*V=0, Qschur'*W=0, 
%    (I-Qschur*Qschur')*AV=W*R, M=W'*V; R=W'*AV;
%
% Compute approximate eigenpair and residual
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%
%
%
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Check for convergence
% Expand the partial Schur form
 Rschur=[[Rschur;zeros(1,k)],Qschur'*MV(u)]; k=k+1;
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Expand preconditioned Schur matrix PinvQ
% Check for shrinking the search subspace
% Solve correction equation
% Expand the subspaces of the interaction matrix  
% The JD loop (Harmonic Ritz values)
%    W orthonormal, V and W orthogonal to Qschur, 
%    W'*W=eye(j), Qschur'*V=0, Qschur'*W=0
%    W=(A*V-tau*V)-Qschur*E, E=Qschur'*(A*V-tau*V), 
%    M=W'*V
% Compute approximate eigenpair and residual
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%
%
%
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Check for convergence
% Expand the partial Schur form
 Rschur=[[Rschur;zeros(1,k)],Qschur'*MV(u)]; k=k+1;
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Expand preconditioned Schur matrix PinvQ
% Check for shrinking the search subspace
% Solve correction equation
% Expand the subspaces of the interaction matrix  
 W=V*Q; V=V(:,1:j)/R; E=E/R; R=eye(j); M=Q(1:j,:)'/R;
 W=V*H; V(:,j+1)=[];R=R'*R;   M=H(1:j,:)';
%======== ARNOLDI (for initializing spaces) ===============================
%=========== END ARNOLDI ============================================  
% not accurate enough M=Rw'\(M/Rv);
%=========== COMPUTE SORTED JORDAN FORM ==================================
% accepted separation between eigenvalues:
% no preconditioning
% solve left preconditioned system
% compute vectors and matrices for skew projection
% precondion and project r
% solve preconditioned system
% no preconditioning
% solve two-sided expl. precond. system
% compute vectors and matrices for skew projection
% precondion and project r
% solve preconditioned system
% "unprecondition" solution
%%%% u(:,j+1)=Atilde*u(:,j)
%%%% r(:,j+1)=Atilde*r(:,j)
%------ compute schur form -------------
 A*Q=Q*S, Q'*Q=eye(size(A));
% transform real schur form to complex schur form
%------ find order eigenvalues ---------------
%------ reorder schur form ----------------
%------ compute qz form ----------------
%------ sort eigenvalues ---------------
%------ sort qz form -------------------
% i>j, move ith eigenvalue to position j 
% determine dimension
% defaults

\end{lstlisting}
\subsection{jdqz}
${}$
\begin{lstlisting}
% Read/set parameters
% Return if eigenvalueproblem is trivial
% Initialize target, test space and interaction matrices
% V=RepGS(Qschur,V); [AV,BV]=MV(V); %%% more stability??
% W=RepGS(Zschur,eval(testspace));  %%% dangerous if sigma~lambda
% Solve the preconditioned correction equation
% Expand the subspaces and the interaction matrices
% Check for stagnation
% Solve projected eigenproblem
% Compute approximate eigenpair and residual
%=== an alternative, but less stable way of computing z =====
% display history
% save history
% check convergence 
% EXPAND Schur form
% Expand preconditioned Schur matrix MinvZ=M\Zschur
% check for conjugate pair
% To detect whether another eigenpair is accurate enough 
% restart if dim(V)> jmax
% Initialize target, test space and interaction matrices
% additional stabilisation. May not be needed
% V=RepGS(Zschur,V); [AV,BV]=MV(V); 
% end add. stab.
% Solve the preconditioned correction equation
% expand the subspaces and the interaction matrices
% Check for stagnation
% compute approximate eigenpair
% Compute approximate eigenpair and residual
% display history
% save history
% check convergence 
% expand Schur form
% ZastQ=Z'*Q0  
% the final Qschur
% check for conjugate pair
% t perp Zschur, t in span(Q0,imag(q)) 
% To detect whether another eigenpair is accurate enough
% restart if dim(V)> jmax
%======== END JDQZ ====================================================
%======================================================================
%======== PREPROCESSING ===============================================
%======================================================================
%======== ARNOLDI (for initial spaces) ================================        
%% then precond=I and target = 0: apply Arnoldi with A
%======== END ARNOLDI =================================================
%======================================================================
%======== POSTPROCESSING ==============================================
%======================================================================
%======== SORT QZ DECOMPOSITION INTERACTION MATRICES ==================
%======== COMPUTE SORTED JORDAN FORM ==================================
%======== END JORDAN FORM =============================================
%======== OUTPUT ======================================================
%======================================================================
%======== UPDATE PRECONDITIONED SCHUR VECTORS =========================
%======================================================================
%======================================================================
%======== SOLVE CORRECTION EQUATION ===================================
%======================================================================
% solve preconditioned system
%======================================================================
%======== LINEAR SOLVERS ==============================================
%======================================================================
% [At,Bt]=MV(x); At=theta(2)*At-theta(1)*Bt; 
% xtol=norm(r-At+Z*(Z'*At))/norm(r); 
%===== Iterative methods ==============================================
% 0 step of bicgstab eq. 1 step of bicgstab
% Then x is a multiple of b
% HIST=[0,1];
 explicit preconditioning
% compute norm in l-space
% HIST=[HIST;[nmv,rnrm/snrm]];
% sufficient accuracy. No need to update r,u
 implicit preconditioning
% collect the updates for x in l-space
% but, do the orth to Z implicitly
% compute norm in l-space
% HIST=[HIST;[nmv,rnrm/snrm]];
% sufficient accuracy. No need to update r,u
% Do the orth to Z explicitly
% In exact arithmetic not needed, but
% appears to be more stable.
% plot(HIST(:,1),log10(HIST(:,2)+eps),'*'), drawnow
% 0 step of gmres eq. 1 step of gmres
% Then x is a multiple of b
%======================================================================
% 0 step of gmres eq. 1 step of gmres
% Then x is a multiple of b
 HIST=1;
% Lucky break-down
 HIST=[HIST;(gamma~=0)/sqrt(rho)]; 
% Lucky break-down
% solve in least square sense 
 HIST=log10(HIST+eps); J=[0:size(HIST,1)-1]';
 plot(J,HIST(:,1),'*'); drawnow
%======== END SOLVE CORRECTION EQUATION ===============================       
%======================================================================
%======== BASIC OPERATIONS ============================================
%======================================================================
 y(1:5,1), pause
%======== COMPUTE r AND z =============================================
% E*u=Q*sigma, sigma(1,1)>sigma(2,2)
%======== END computation r and z =====================================
%======================================================================
%======== Orthogonalisation ===========================================
%======================================================================
%======== END  Orthogonalisation ======================================
%======================================================================
%======== Sorts Schur form ============================================
%======================================================================
    kappa=max(norm(A,inf)/max(norm(B,inf),1.e-12),1);
    kappa=2^(round(log2(kappa)));
%------ compute the qz factorization -------
%------ scale the eigenvalues --------------
%------ sort the eigenvalues ---------------
%------ swap the qz form -------------------
% repeat SwapQZ if angle is too small
%======================================================================
%======================================================================
% i>j, move ith eigenvalue to position j 
% compute q s.t. C*q=(t(i,1)*S-s(i,1)*T)*q=0
 C*P=Q*R
 check whether last but one diag. elt r nonzero
 C*q
% end computation q
%======== END sort QZ decomposition interaction matrices ==============
%======================================================================
%======== INITIALIZATION ==============================================
%======================================================================
%======================================================================
% defaults              %%%% search for 'xx' in fieldnames
%% 'ma'
%% 'sch'
%% 'to'
%% 'di'
% jmin=nselect+p0 %%%% 'jmi'
% jmax=jmin+p1    %%%% 'jma'
%% 'te'
%% 'pai'
%% 'av'
%% 'tr'
%% 'fix'
%% 'ns'
%% 'ch'
%% 'lso'
%% 'ls_m'
%% 'ls_t' 
%% 'ls_e'
%% 'ty'
%% 'l_'
%% 'u_'
%% 'p_'
%% 'sca'
%% 'v0'
 initiation
 'standard'
 'harmonic'
 'searchspace'
%======================================================================
% or Operator_Form=3 or Operator_Form=5???
%======================================================================
%========= DISPLAY FUNCTIONS ===========================================
%======================================================================
%======================================================================
%======================================================================
%======================================================================

\end{lstlisting}
\subsection{mfunc\_jdm}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{mgs}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{minres\_}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{mv\_jacobi\_davidson}
${}$
\begin{lstlisting}

\end{lstlisting}
\section{lib/mathematics/linear-algebra}
\subsection{first}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{gershgorin\_circle}
${}$
\begin{lstlisting}
 range of eigenvalues determined by the gershgorin circle theorem

\end{lstlisting}
\subsection{haussdorff}
${}$
\begin{lstlisting}
 haussdorf dimension
 box counting: count cectangles passed through by line (covered by polygon)

 Koch snow flake 3:4 -> 1.2619
 Kantor set      2:3, (4:9) ->  0.6309
 quadrat         4:2, 9:3, 16:4 -> 2


\end{lstlisting}
\subsection{ieig2x2}
${}$
\begin{lstlisting}
 reconstruct matrix from eigenvalue decomposition

\end{lstlisting}
\subsection{inv2x2}
${}$
\begin{lstlisting}
 2x2 inverse of stacked matrices

\end{lstlisting}
\subsection{inv3x3}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{inv4x4}
${}$
\begin{lstlisting}
 inverse of stacked 4x4 matrices

\end{lstlisting}
\section{lib/mathematics/linear-algebra/lanczos}
\subsection{arnoldi}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{arnoldi\_new}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{eigs\_lanczos\_man}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{lanczos}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{lanczos\_}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{lanczos\_biorthogonal}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{lanczos\_biorthogonal\_improved}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{lanczos\_ghep}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{mv\_lanczos}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{reorthogonalise}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{test\_lanczos}
${}$
\begin{lstlisting}

\end{lstlisting}
\section{lib/mathematics/linear-algebra/linear-systems}
\subsection{gmres\_man}
${}$
\begin{lstlisting}
 break on convergence

\end{lstlisting}
\subsection{minres\_recycle}
${}$
\begin{lstlisting}

\end{lstlisting}
\section{lib/mathematics/linear-algebra}
\subsection{lpmean}
${}$
\begin{lstlisting}
 mean of pth-power of a

\end{lstlisting}
\subsection{lpnorm}
${}$
\begin{lstlisting}
 norm of lth-power of a

\end{lstlisting}
\subsection{matvec3}
${}$
\begin{lstlisting}
 matrix-vector product of stacked matrices and vectors

\end{lstlisting}
\subsection{max2d}
${}$
\begin{lstlisting}
 maximum value and i-j index for matrix

\end{lstlisting}
\subsection{mpoweri}
${}$
\begin{lstlisting}
 approximation of A^p, where p is not integer by quadtratic interpolation

\end{lstlisting}
\subsection{mtimes2x2}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{mtimes3x3}
${}$
\begin{lstlisting}
 product of stacked 3x3 matrices

\end{lstlisting}
\subsection{nannorm}
${}$
\begin{lstlisting}
 norm of a vector, skips nan-values

\end{lstlisting}
\subsection{nanshift}
${}$
\begin{lstlisting}
 shift vector, but set out of range values to NaN

\end{lstlisting}
\subsection{nl}
${}$
\begin{lstlisting}
 number rows (lines) of a matrix

 analogue to unix nl command

\end{lstlisting}
\subsection{normalise}
${}$
\begin{lstlisting}
 normalise a vector or the columns of a matrix
 note that the columns are independently normalised, and hence not necessarily
 orthogonal to each other use the gram schmidt algorithm for this (qr or orth)

\end{lstlisting}
\subsection{normalize1}
${}$
\begin{lstlisting}
 normalize columns in x to [-1,1]

\end{lstlisting}
\subsection{normrows}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{orth2}
${}$
\begin{lstlisting}
 make matrix A orhogonal to B

\end{lstlisting}
\subsection{orth\_man}
${}$
\begin{lstlisting}
 orthogonalize the columns of A

\end{lstlisting}
\subsection{orthogonalise}
${}$
\begin{lstlisting}
 make x orthogonal to Y

\end{lstlisting}
\subsection{paddext}
${}$
\begin{lstlisting}
 padd values to vactor
 not suitable for noisy data
 order = 0 : constant extrapolation (hold)
 order = 1 : linear extrapolation

\end{lstlisting}
\subsection{paddval1}
${}$
\begin{lstlisting}
 padd values at end of x

\end{lstlisting}
\subsection{paddval2}
${}$
\begin{lstlisting}
 padd values to x

\end{lstlisting}
\section{lib/mathematics/linear-algebra/polynomial}
\subsection{chebychev}
${}$
\begin{lstlisting}
 chebycheff polynomials

\end{lstlisting}
\subsection{piecewise\_polynomial}
${}$
\begin{lstlisting}
 evaluate piecewise polynomial

\end{lstlisting}
\subsection{roots1}
${}$
\begin{lstlisting}
 roots of linear functions

\end{lstlisting}
\subsection{roots2}
${}$
\begin{lstlisting}
 roots of quadratic function
 c1 x^2 + c2 x + c3 = 0

\end{lstlisting}
\subsection{roots2poly}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{roots3}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{roots4}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{test\_roots4}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{vanderi\_1d}
${}$
\begin{lstlisting}
 vandermonde matrix of an integral

\end{lstlisting}
\section{lib/mathematics/linear-algebra}
\subsection{randrot}
${}$
\begin{lstlisting}
 random rotation matrix

\end{lstlisting}
\subsection{right}
${}$
\begin{lstlisting}
 get right column by shifting columns to left
 extrapolate rightmost column

\end{lstlisting}
\subsection{rot2}
${}$
\begin{lstlisting}
 rotation matrix from angle

\end{lstlisting}
\subsection{rot2dir}
${}$
\begin{lstlisting}
 rotation matrix from direction vector

\end{lstlisting}
\subsection{rot3}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{rotR}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{rownorm}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{simmilarity\_matrix}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{spnorm}
${}$
\begin{lstlisting}
 frobenius norm

\end{lstlisting}
\subsection{spzeros}
${}$
\begin{lstlisting}
 allocate a sparze matrix of zeros

\end{lstlisting}
\subsection{test\_roots3}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{transform\_minmax}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{transpose3}
${}$
\begin{lstlisting}
 transpose stacked 3x3 matrices

\end{lstlisting}
\subsection{transposeall}
${}$
\begin{lstlisting}

\end{lstlisting}
\section{lib/mathematics/logic}
\begin{lstlisting}
bitwise operations on integers


\end{lstlisting}
\subsection{bitor\_man}
${}$
\begin{lstlisting}
 bitwise OR of the numbers of the columns of A

 input:
	A (positive integer)

\end{lstlisting}
\section{lib/mathematics/master/plot}
\subsection{attach\_boundary\_value}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{cartesian\_polar}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{img\_vargrid}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{plot\_basis\_functions}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{plot\_convergence}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{plot\_dof}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{plot\_eigenbar}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{plot\_error\_estimation}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{plot\_error\_estimation\_2}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{plot\_error\_fem}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{plot\_fdm\_kernel}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{plot\_fdm\_vs\_fem}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{plot\_fem\_accuracy}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{plot\_function\_and\_grid}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{plot\_hat}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{plot\_hydrogen\_wf}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{plot\_mesh}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{plot\_mesh\_2}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{plot\_refine}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{plot\_refine\_3d}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{plot\_runtime}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{plot\_spectrum}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{plot\_wavefunction}
${}$
\begin{lstlisting}

\end{lstlisting}
\section{lib/mathematics/master/ported}
\subsection{assemble\_2d\_dphi\_dphi}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{assemble\_2d\_phi\_phi}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{assemble\_3d\_dphi\_dphi}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{assemble\_3d\_phi\_phi}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{dV\_2d\_}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{derivative\_2d}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{derivative\_3d}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{element\_neighbour\_2d}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{prefetch\_2d\_}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{promote\_2d\_3\_10}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{promote\_2d\_3\_15}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{promote\_2d\_3\_21}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{promote\_2d\_3\_6}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{promote\_3d\_4\_10}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{promote\_3d\_4\_20}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{promote\_3d\_4\_35}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{vander\_2d}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{vander\_3d}
${}$
\begin{lstlisting}

\end{lstlisting}
\section{lib/mathematics/master/sandbox}
\subsection{adapt}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{assoc\_laguerre}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{assoc\_legendre}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{c23}
${}$
\begin{lstlisting}

\end{lstlisting}
\section{lib/mathematics/master/sandbox/cg}
\subsection{cg}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{cg\_coef\_to\_poly}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{errmat}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{lanczos}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{laplacian\_2d}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{test\_cg\_eigs}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{test\_lanczos}
${}$
\begin{lstlisting}

\end{lstlisting}
\section{lib/mathematics/master/sandbox}
\subsection{condition\_number\_higher\_order}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{confinement\_dat}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{convergence\_2d\_3d}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{convergence\_matrix\_powers}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{cut\_out}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{derivative\_2d}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{derivative\_3d}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{dummy}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{eig\_error}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{eigs\_fix}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{energy\_level}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{equalise}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{example\_int64}
${}$
\begin{lstlisting}
 Basic operations
 

 

 

 

 Matrix multiplication
 Timing




\end{lstlisting}
\section{lib/mathematics/master/sandbox/fem-matlab}
\subsection{boundary\_circle}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{boundary\_rectangle}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{geometry\_circle\_with\_hole}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{geometry\_rectangle}
${}$
\begin{lstlisting}

\end{lstlisting}
\section{lib/mathematics/master/sandbox}
\subsection{fem\_2d\_estimate\_error}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{fem\_assemble\_scratch}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{fem\_s}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{fourier\_h}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{grad\_2d}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{grad\_3d}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{gradient}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{harmonic\_oscillator}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{hydrogen\_2d\_analytic}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{hydrogen\_boxed}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{hydrogen\_boxed\_old}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{hydrogen\_wave}
${}$
\begin{lstlisting}
% Hydrogen atom

\end{lstlisting}
\subsection{hydrogen\_wf}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{ichol\_man}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{known\_eigenvalue}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{kron\_man}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{laguerre}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{laplacian\_arbitrary\_order\_old}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{laplacian\_convergence}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{laplacian\_cut\_out}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{laplacian\_cylindrical}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{laplacian\_non\_uniform\_old}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{laplacian\_polar}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{laplacian\_simple}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{lderivative\_3d}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{list\_dat}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{matlab-horner}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{mesh\_to\_grid\_2d\_3}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{mg\_mat}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{mv}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{orth2}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{partial\_derivative\_2d}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{partition\_function}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{partition\_function\_old}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{poisson}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{poisson\_fem}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{potential}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{powerc}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{quick\_newihbour}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{radial}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{radial\_convergence}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{radial\_wafefunction}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{refine\_2d}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{refine\_3d}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{relerr}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{restore\_cw}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{runtime\_bm}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{rydberg}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{s\_old}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{snorm}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{spherical\_harmonic}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{split\_eig}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{sum1}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{sum3}
${}$
\begin{lstlisting}

\end{lstlisting}
\section{lib/mathematics/master/sandbox/summation}
\subsection{acc}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{add}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{ape}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{mmul\_accurately}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{sum\_kahan}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{sum\_pairwise}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{test\_sum}
${}$
\begin{lstlisting}

\end{lstlisting}
\section{lib/mathematics/master/sandbox}
\subsection{test\_convergence\_ill\_conditioned}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{test\_fem\_1d}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{test\_fem\_2d}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{test\_fem\_3d}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{test\_increase}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{test\_lanczos\_shift}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{test\_ldl}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{test\_power}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{trefethen\_p8\_fdm}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{wavefunc}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{xgrid}
${}$
\begin{lstlisting}

\end{lstlisting}
\section{lib/mathematics/number-theory}
\subsection{ceiln}
${}$
\begin{lstlisting}
 floor to leading n-digits

\end{lstlisting}
\subsection{digitsb}
${}$
\begin{lstlisting}
 number of digits with respect to specified base

\end{lstlisting}
\subsection{floorn}
${}$
\begin{lstlisting}
 floor to n-digits

\end{lstlisting}
\subsection{iseven}
${}$
\begin{lstlisting}
 true for even numbers in X

\end{lstlisting}
\subsection{multichoosek}
${}$
\begin{lstlisting}
 all combinations of lenght k from set values with repetitions
 c.f. nchoosek, combinations without repetition

 input :
 	x : scalar integer or vector of arbitrary numbers
	k : length of subsets
 output :
	if x scalar : number of combinations  
	if x vector : the exact combinations


\end{lstlisting}
\subsection{nchoosek\_man}
${}$
\begin{lstlisting}
 vecotrised binomial coefficient
 b = N!/K!(N-K)!

\end{lstlisting}
\subsection{pythagorean\_triple}
${}$
\begin{lstlisting}
 pythagorean triple

\end{lstlisting}
\subsection{roundn}
${}$
\begin{lstlisting}
 round to n digits

\end{lstlisting}
\section{lib/mathematics/numerical-methods/differentiation}
\subsection{derivative1}
${}$
\begin{lstlisting}
 first derivative on variable mesh
 second order accurate

\end{lstlisting}
\subsection{derivative2}
${}$
\begin{lstlisting}
 second derivative on a variable mesh

\end{lstlisting}
\section{lib/mathematics/numerical-methods/finite-difference}
\subsection{cdiff}
${}$
\begin{lstlisting}
 differences of columns of X
 degree  = 1 : central first order differences
 degreee = 2 : central second order differences

\end{lstlisting}
\subsection{cdiffb}
${}$
\begin{lstlisting}
 differences of columns of X
 degree  = 1 : central first order differences
 degreee = 2 : central second order differences
 TODO use difference matrix function for simplicity

\end{lstlisting}
\subsection{cmean}
${}$
\begin{lstlisting}
 single gaussian smoothing step with kernel 1/4*[1,2,1]

\end{lstlisting}
\subsection{derivative\_matrix\_1\_1d}
${}$
\begin{lstlisting}
 finite difference matrix of first derivative in one dimensions

\end{lstlisting}
\subsection{derivative\_matrix\_2\_1d}
${}$
\begin{lstlisting}
 finite derivative matrix of second derivative in one dimension

\end{lstlisting}
\subsection{derivative\_matrix\_2d}
${}$
\begin{lstlisting}
 finite difference derivative matrix in two dimensions

\end{lstlisting}
\subsection{derivative\_matrix\_curvilinear}
${}$
\begin{lstlisting}
 derivative matrix on a curvilinear grid

\end{lstlisting}
\subsection{derivative\_matrix\_curvilinear\_2}
${}$
\begin{lstlisting}
 derivative matrix on a two dimensional curvilinear grid
 the grid has not necessarily to be orthogonal

\end{lstlisting}
\subsection{difference\_kernel}
${}$
\begin{lstlisting}
 difference kernels for equispaced grids
 c.f. Computing the Spectrum of the Confined Hydrogen Atom, Kastner, 2012

\end{lstlisting}
\subsection{distmat}
${}$
\begin{lstlisting}
 distance matrix for a 2 dimensional rectangular matrix

\end{lstlisting}
\subsection{gradpde2d}
${}$
\begin{lstlisting}
 objective function gradiend on two dimensional regular grid
 numeric gradient for non-linear least squares optimisation
 of a PDE on a rectangular grid
 x_* = min(f(x))
 f = (v(x) - v(x_*))^2 = f(x) + A dx + O(dx^2)
 a_ij = df_i/dx_j
 

\end{lstlisting}
\subsection{laplacian}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{laplacian\_fdm}
${}$
\begin{lstlisting}
 finite difference matrix of the laplacian
 BC

\end{lstlisting}
\subsection{left}
${}$
\begin{lstlisting}
 left element of vector, leftmost column is extrapolated

\end{lstlisting}
\subsection{lrmean}
${}$
\begin{lstlisting}
 mean of the left and right element

\end{lstlisting}
\section{lib/mathematics/numerical-methods/finite-difference/master}
\subsection{fdm\_adaptive\_grid}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{fdm\_adaptive\_refinement\_old}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{fdm\_assemble\_d1\_2d}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{fdm\_assemble\_d2\_2d}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{fdm\_confinement}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{fdm\_d\_vargrid}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{fdm\_h\_unstructured}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{fdm\_hydrogen\_vargrid}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{fdm\_mark\_unstructured\_2d}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{fdm\_plot}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{fdm\_plot\_series}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{fdm\_refine\_2d}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{fdm\_refine\_3d}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{fdm\_refine\_unstructured\_2d}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{fdm\_schroedinger\_2d}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{fdm\_schroedinger\_3d}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{relocate}
${}$
\begin{lstlisting}

\end{lstlisting}
\section{lib/mathematics/numerical-methods/finite-difference}
\subsection{mid}
${}$
\begin{lstlisting}
 mid point between neighbouring vector elements

\end{lstlisting}
\subsection{pwmid}
${}$
\begin{lstlisting}
 segment end point to segment mid point transformation for regular 1d grids

\end{lstlisting}
\subsection{ratio}
${}$
\begin{lstlisting}
 ratio of two subsequent values

\end{lstlisting}
\subsection{steplength}
${}$
\begin{lstlisting}
 step length of a vector if it were equispaced

\end{lstlisting}
\subsection{swapoddeven}
${}$
\begin{lstlisting}
 swap odd and even elements in a vector

\end{lstlisting}
\subsection{test\_derivative\_matrix\_2d}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{test\_derivative\_matrix\_curvilinear}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{test\_difference\_kernel}
${}$
\begin{lstlisting}

\end{lstlisting}
\section{lib/mathematics/numerical-methods/finite-element}
\subsection{Mesh\_2d\_java}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{Tree\_2d\_java}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{assemble\_1d\_dphi\_dphi}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{assemble\_1d\_phi\_phi}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{assemble\_2d\_dphi\_dphi\_java}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{assemble\_2d\_phi\_phi\_java}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{assemble\_3d\_dphi\_dphi\_java}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{assemble\_3d\_phi\_phi\_java}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{boundary\_1d}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{boundary\_2d}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{boundary\_3d}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{check\_area\_2d}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{circmesh}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{cropradius}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{display\_2d}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{display\_3d}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{distort}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{err\_2d}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{estimate\_err\_2d\_3}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{example\_1d}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{example\_2d}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{explode}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{fem\_2d}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{fem\_2d\_heuristic\_mesh}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{fem\_get\_2d\_radial}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{fem\_interpolation}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{fem\_plot\_1d}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{fem\_plot\_1d\_series}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{fem\_plot\_2d}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{fem\_plot\_2d\_series}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{fem\_plot\_3d}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{fem\_plot\_3d\_series}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{fem\_plot\_confine\_series}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{fem\_radial}
${}$
\begin{lstlisting}
 adaptive grid
 constant grid

\end{lstlisting}
\subsection{flip\_2d}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{get\_mesh\_arrays}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{hashkey}
${}$
\begin{lstlisting}

\end{lstlisting}
\section{lib/mathematics/numerical-methods/finite-element/int}
\subsection{int\_1d\_gauss}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{int\_1d\_gauss\_1}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{int\_1d\_gauss\_2}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{int\_1d\_gauss\_3}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{int\_1d\_gauss\_4}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{int\_1d\_gauss\_5}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{int\_1d\_gauss\_6}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{int\_1d\_gauss\_lobatto}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{int\_1d\_nc\_2}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{int\_1d\_nc\_3}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{int\_1d\_nc\_4}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{int\_1d\_nc\_5}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{int\_1d\_nc\_6}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{int\_1d\_nc\_7}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{int\_1d\_nc\_7\_hardy}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{int\_2d\_gauss\_1}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{int\_2d\_gauss\_12}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{int\_2d\_gauss\_13}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{int\_2d\_gauss\_16}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{int\_2d\_gauss\_25}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{int\_2d\_gauss\_3}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{int\_2d\_gauss\_33}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{int\_2d\_gauss\_6}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{int\_2d\_gauss\_7}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{int\_2d\_gauss\_9}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{int\_2d\_nc\_10}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{int\_2d\_nc\_15}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{int\_2d\_nc\_21}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{int\_2d\_nc\_3}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{int\_2d\_nc\_6}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{int\_3d\_gauss\_1}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{int\_3d\_gauss\_11}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{int\_3d\_gauss\_14}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{int\_3d\_gauss\_15}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{int\_3d\_gauss\_24}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{int\_3d\_gauss\_4}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{int\_3d\_gauss\_45}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{int\_3d\_gauss\_5}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{int\_3d\_nc\_11}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{int\_3d\_nc\_4}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{int\_3d\_nc\_6}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{int\_3d\_nc\_8}
${}$
\begin{lstlisting}

\end{lstlisting}
\section{lib/mathematics/numerical-methods/finite-element}
\subsection{interpolation\_matrix}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{mark}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{mark\_1d}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{mesh\_1d\_uniform}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{mesh\_3d\_uniform}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{mesh\_interpolate}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{neighbour\_1d}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{old}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{pdeeig\_1d}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{pdeeig\_2d}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{pdeeig\_3d}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{polynomial\_derivative\_1d}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{potential\_const}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{potential\_coulomb}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{potential\_harmonic\_oscillator}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{project\_circle}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{project\_rectangle}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{promote\_1d\_2\_3}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{promote\_1d\_2\_4}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{promote\_1d\_2\_5}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{promote\_1d\_2\_6}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{quadrilaterate}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{recalculate\_regularity\_2d}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{refine\_1d}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{refine\_2d\_21}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{refine\_2d\_structural}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{regularity\_1d}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{regularity\_2d}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{regularity\_3d}
${}$
\begin{lstlisting}
{	T = [1 2 3 4];
}

\end{lstlisting}
\subsection{relocate\_2d}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{test\_circmesh}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{test\_hermite}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{tri\_assign\_points}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{triangulation\_uniform}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{vander\_1d}
${}$
\begin{lstlisting}
 van der Monde matrix

\end{lstlisting}
\subsection{vanderd\_1d}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{vanderi\_1d}
${}$
\begin{lstlisting}

\end{lstlisting}
\section{lib/mathematics/numerical-methods/finite-volume/@Advection}
\subsection{Advection}
${}$
\begin{lstlisting}
 FVM treatment of the Advection equation

\end{lstlisting}
\subsection{dot\_advection}
${}$
\begin{lstlisting}
 advection equation

\end{lstlisting}
\section{lib/mathematics/numerical-methods/finite-volume/@Burgers}
\subsection{burgers\_split}
${}$
\begin{lstlisting}
 viscous Burgers' equation,
 mixed analytic and numerical derivative in frequency space
 by splitting sheme
 u_t = -(0.5*u^2)_x + c*u_xx

\end{lstlisting}
\subsection{dot\_burgers\_fdm}
${}$
\begin{lstlisting}
 viscous burgers' equation
 u_t = -d/dx (1/2*u^2) + c d^2/dx^2 u_xx

\end{lstlisting}
\subsection{dot\_burgers\_fft}
${}$
\begin{lstlisting}
 viscous Burgers' equation in frequency space
 u_t + (0.5*u^2)_x = c*u_xx

\end{lstlisting}
\section{lib/mathematics/numerical-methods/finite-volume/@Finite\_Volume}
\subsection{Finite\_Volume}
${}$
\begin{lstlisting}
 finite volume method for partial differential equations 1+1 dimensions
 (time and space)


\end{lstlisting}
\subsection{apply\_bc}
${}$
\begin{lstlisting}

 apply boundary conditions

\end{lstlisting}
\subsection{solve}
${}$
\begin{lstlisting}
 solve the the PDE by successively stepping in time
 this is a trivial implmentation with constant step length
 severity of diffusive error depends on dt/dx-ratio
 stability depends on wave height
			printf('Progress %2.1f%% %2.1fs\n',100*(t-Ti(1))/(Ti(2)-Ti(1)),t_real);

\end{lstlisting}
\subsection{step\_split\_strang}
${}$
\begin{lstlisting}
 step in time, treat inhomogeneous part by Strang splitting 
 this scheme is not suitable for stationary solutions, for example
 steady shallow water flow

\end{lstlisting}
\subsection{step\_unsplit}
${}$
\begin{lstlisting}

 step in time, without splitting the inhomogeneous term

\end{lstlisting}
\section{lib/mathematics/numerical-methods/finite-volume/@Flux\_Limiter}
\subsection{Flux\_Limiter}
${}$
\begin{lstlisting}
 class of flux limiters

\end{lstlisting}
\subsection{beam\_warming}
${}$
\begin{lstlisting}
 beam warming sheme
 low resolution
 note: works only if sign of eigenvalues point into the same direction according to RL

\end{lstlisting}
\subsection{fromm}
${}$
\begin{lstlisting}
 fromme limiter
 low res

\end{lstlisting}
\subsection{lax\_wendroff}
${}$
\begin{lstlisting}
 lax wendroff scheme
 second order accurate, but no tvd
 this is effectively not a limiter
 eq. 6.39 in randall, leveque

\end{lstlisting}
\subsection{minmod}
${}$
\begin{lstlisting}
 min-mod schock limiter

\end{lstlisting}
\subsection{monotized\_central}
${}$
\begin{lstlisting}
 monotonized central flux limiter

\end{lstlisting}
\subsection{muscl}
${}$
\begin{lstlisting}
 muscl flux limiter

\end{lstlisting}
\subsection{superbee}
${}$
\begin{lstlisting}
 superbee limiter

\end{lstlisting}
\subsection{upwind}
${}$
\begin{lstlisting}
 godunov scheme
 godunov, first order accurate

\end{lstlisting}
\subsection{vanLeer}
${}$
\begin{lstlisting}
 van Leer limiter

\end{lstlisting}
\section{lib/mathematics/numerical-methods/finite-volume/@KDV}
\subsection{dot\_kdv\_fdm}
${}$
\begin{lstlisting}
 korteweg de vries equation
 u_t + (0.5*u^2)_x = c*u_xxx

\end{lstlisting}
\subsection{dot\_kdv\_fft}
${}$
\begin{lstlisting}
 korteweg de vries equation
 compute derivatives in frequency space
 u_t + (0.5*u^2)_x = c*u_xxx

\end{lstlisting}
\subsection{kdv\_split}
${}$
\begin{lstlisting}
 korteweg de vries equation in frequency space,
 derivative treated by splitting scheme

\end{lstlisting}
\section{lib/mathematics/numerical-methods/finite-volume/@Reconstruct\_Average\_Evolve}
\subsection{Reconstruct\_Average\_Evolve}
${}$
\begin{lstlisting}
 Reconstruct Average Evolve Finite Volume Method for treatment of 1+1D pdes

 McCronack Scheme
 err = O(dt^2) + O(dx^2), except as discontinuities
 error:
	h_xxx(3:end-2) = 1/dx^3*( -0.5*h(1:end-4) + h(2:end-3) - h(4:end-1)  + 0.5*h(5:end) );
	th = -1/6*dx^2*qh_.*(1 - (qh_*dt/dx).^2).*h_xxx;

\end{lstlisting}
\subsection{advect\_highres}
${}$
\begin{lstlisting}
 single time step for the reconstruct evolve algorithm

\end{lstlisting}
\subsection{advect\_lowress}
${}$
\begin{lstlisting}
 single time step
 low resolution

\end{lstlisting}
\section{lib/mathematics/numerical-methods/finite-volume}
\subsection{Godunov}
${}$
\begin{lstlisting}
 Godunov, upwind method for systems of pdes

\end{lstlisting}
\subsection{Lax\_Friedrich}
${}$
\begin{lstlisting}
 Lax-Friedrich-Method
 for hyperbolic conservation laws
 err = O(dt) + O(dx)
 |a dt/dx| < 1

\end{lstlisting}
\subsection{Measure}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{Roe}
${}$
\begin{lstlisting}
 non linear roe solver for the SWE (randall, leveque 15.3.1)

 The roe solver guarantess:
 - A is diagonalisable with real eigenvalues (15.12)
 - can be determined by a closed formula
 - is an efficient replacement for true Rieman solver

\end{lstlisting}
\subsection{fv\_swe}
${}$
\begin{lstlisting}
 wrapper for solving SWE

\end{lstlisting}
\subsection{staggered\_euler}
${}$
\begin{lstlisting}
 forward euler method with staggered grid

\end{lstlisting}
\subsection{staggered\_grid}
${}$
\begin{lstlisting}
 staggered grid approximation to the SWE

\end{lstlisting}
\section{lib/mathematics/numerical-methods}
\subsection{grid2quad}
${}$
\begin{lstlisting}
 extract rectangular elements of a structured grid
 in form of an unstructured quad-mesh format

\end{lstlisting}
\section{lib/mathematics/numerical-methods/integration}
\subsection{cumintL}
${}$
\begin{lstlisting}
 cumulative integral from left to right

\end{lstlisting}
\subsection{cumintR}
${}$
\begin{lstlisting}
 cumulative integral from right to left

\end{lstlisting}
\subsection{int\_trapezoidal}
${}$
\begin{lstlisting}
 integrate y along x with the trapezoidal rule

\end{lstlisting}
\section{lib/mathematics/numerical-methods/interpolation/@Kriging}
\subsection{Kriging}
${}$
\begin{lstlisting}
 class for Kriging interpolation

\end{lstlisting}
\subsection{estimate\_semivariance}
${}$
\begin{lstlisting}
 estimate the parameter of the semivariance model for Kriging interpolation
		% set up the regression matrix and solve for parameters

\end{lstlisting}
\subsection{interpolate\_}
${}$
\begin{lstlisting}
 interpolate with Krieging method

 this function may interpolate several quantities per coordinate,
 using the same variogram, if the semivariance of the quantities differs,
 the user may prefer to estimate the semivariance and interpolate each quantity
 individually

 Xs  : source point coordinates
 Vs  : value at source points
 Xt  : targe point coordinates
 Vt  : value at target points
 E2t : squared interpolation error at target points

\end{lstlisting}
\section{lib/mathematics/numerical-methods/interpolation/@RegularizedInterpolator1}
\subsection{RegularizedInterpolator1}
${}$
\begin{lstlisting}
 class for regularized interpolation (Thikonov) on a 1D mesh

\end{lstlisting}
\subsection{init}
${}$
\begin{lstlisting}
 initialize the interpolator with a set of sampling points

\end{lstlisting}
\section{lib/mathematics/numerical-methods/interpolation/@RegularizedInterpolator2}
\subsection{RegularizedInterpolator2}
${}$
\begin{lstlisting}
 class for regularized interpolation on an unstructures mesh (interpolation)

\end{lstlisting}
\subsection{init}
${}$
\begin{lstlisting}
 initialize the interpolator with a set of point samples

\end{lstlisting}
\section{lib/mathematics/numerical-methods/interpolation/@RegularizedInterpolator3}
\subsection{RegularizedInterpolator3}
${}$
\begin{lstlisting}
 class for regularized interpolation (Tikhonov) on a triangulation
 (unstructured mesh)

\end{lstlisting}
\subsection{init}
${}$
\begin{lstlisting}
 initialize the interpolator with a set of sampling points

\end{lstlisting}
\section{lib/mathematics/numerical-methods/interpolation}
\subsection{IDW}
${}$
\begin{lstlisting}
 spatial averaging by inverse distance weighting

\end{lstlisting}
\subsection{IPoly}
${}$
\begin{lstlisting}
 polynomial interpolation class

\end{lstlisting}
\subsection{IRBM}
${}$
\begin{lstlisting}
 interpolate by the radial basis function method
			fprintf(1,'Progress IRBM: %d%%\n',round(100*idx/size(Xi,1)));

\end{lstlisting}
\subsection{ISparse}
${}$
\begin{lstlisting}
 sparse interpolation class

\end{lstlisting}
\subsection{Inn}
${}$
\begin{lstlisting}
 nearest neighbour interpolation

\end{lstlisting}
\subsection{Interpolator}
${}$
\begin{lstlisting}
 interpolator super-class
				fprintf(1,'Progress: %f%% %fs\n',100*idx/size(Xt,1),t);

\end{lstlisting}
\subsection{fixnan}
${}$
\begin{lstlisting}
 fill nan-values in vector with gaps

\end{lstlisting}
\subsection{idw1}
${}$
\begin{lstlisting}
 spatial average ny inverse distance weighting

\end{lstlisting}
\subsection{idw2}
${}$
\begin{lstlisting}
 spatial average by inverse distance weighting

\end{lstlisting}
\subsection{inner2outer}
${}$
\begin{lstlisting}
 linear interpolation of segment mit point to grid points at segment ends
 assumes equal grid spacing

\end{lstlisting}
\subsection{inner2outer2}
${}$
\begin{lstlisting}
 interpolate from element (segment) centres to edge points

\end{lstlisting}
\subsection{interp1\_limited}
${}$
\begin{lstlisting}
 interpolate values, but not beyond a certain distance
 this function is idempotent, i.e. it will not extrapolate over into gaps
 exceedint the limit and thus not spuriously extend the series when called a second time on the same data

\end{lstlisting}
\subsection{interp1\_man}
${}$
\begin{lstlisting}
 interpolate

\end{lstlisting}
\subsection{interp1\_save}
${}$
\begin{lstlisting}
 make interpolation save to round off errors
 the matlab internal interpolation suffers from rounding errors, which
 are unacceptable when values of X and Y are large (for example UTm coordinates)
 this normalization prevents this

\end{lstlisting}
\subsection{interp1\_slope}
${}$
\begin{lstlisting}
 quadratic interpolation returning value and derivative(s)

\end{lstlisting}
\subsection{interp1\_smooth}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{interp1\_unique}
${}$
\begin{lstlisting}
 matlab fails to interpolate, when x values are not unique
 this function makes the values unique before use

\end{lstlisting}
\subsection{interp2\_man}
${}$
\begin{lstlisting}
 nearest neighbour interpolation in two dimensions

\end{lstlisting}
\subsection{interp\_angle}
${}$
\begin{lstlisting}
 interpolate an angle

\end{lstlisting}
\subsection{interp\_fourier}
${}$
\begin{lstlisting}
 interpolation by the fourier method

\end{lstlisting}
\subsection{interp\_fourier\_batch}
${}$
\begin{lstlisting}
 batch interpolation by the fourier interpolation

\end{lstlisting}
\subsection{interp\_sn}
${}$
\begin{lstlisting}
 interpolate along streamwise coordinates
 This gives similar result to setting aspect ratio for sN to infinity,
 but not quite,as the input point set is not dense (scale for sN to infinity does not work)
		sdx  = sdx(sdx_); 

\end{lstlisting}
\subsection{interp\_sn2}
${}$
\begin{lstlisting}
 interpolation in streamwise coordinates

\end{lstlisting}
\subsection{interp\_sn3}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{interp\_sn\_}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{limit\_by\_distance\_1d}
${}$
\begin{lstlisting}
 smooth subsequent values along a curve such that
	v(x0+dx) < v(x0) + (ratio-1)*dx
 if v is the edge length in a resampled polygon, then v_i/v_(i+1) < ratio
 	ratio^1 = exp(a*1)

\end{lstlisting}
\subsection{resample1}
${}$
\begin{lstlisting}
 interpolation along a parametric curve with variable step width

\end{lstlisting}
\subsection{resample\_d\_min}
${}$
\begin{lstlisting}
 resample a function

\end{lstlisting}
\subsection{resample\_vector}
${}$
\begin{lstlisting}
 resample a track so that velocity vectors do not run into each other

\end{lstlisting}
\subsection{test\_interp1\_limited}
${}$
\begin{lstlisting}

\end{lstlisting}
\section{lib/mathematics/numerical-methods}
\subsection{inverse\_complex}
${}$
\begin{lstlisting}

\end{lstlisting}
\section{lib/mathematics/numerical-methods/ode}
\subsection{bvp2\_check\_arguments}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{bvp2c}
${}$
\begin{lstlisting}
 solve system of non-linear second order odes (in more than one variable)
 as boundary value problems

 odefun provides ode coefficients c:
 c(x,1) y''(x) + c(x,2) y'(x) + c(x,3) y = c(x,4)
    c_1 y"     + c_2 y'       + c_3 y + c_4 = c_4

 subject to the boundary conditions
 bcfun provides v and p and optionally q, so that:

 b_1 y + b_2 y' = f
    q(x,1)*( p(x,1) y_l(x) + p(x,2)  y_l'(x)
  + q(x,2)*( p(x,1) y_r(x) + p(x,2) y_r'(x)    = v(x)
 where q weighs the waves travelling from left to right and right to left (default [1 1])

\end{lstlisting}
\subsection{bvp2c2}
${}$
\begin{lstlisting}
 solve second order boundary value problem via roots of the characteristic
 polynomial

 input:

 x   : [nx1] discretized domain
       n : number of vertices
      nxc = n-1 : number of segments

 bc  : struct : boundary condition
       bc.p(1)*y(0) + bc.pd(2)*y'(0) = bc.val(1)
       bc.p(2)*y(L) + bc.pd(2)*y'(L) = bc.val(2)

 output:

 A   : [2*nxc x 2*ns] disrcretisation matrix
 rhs : [2*nxc x 1] right hand size

 y = A^-1 rhs


\end{lstlisting}
\subsection{bvp2fdm}
${}$
\begin{lstlisting}
 solve system of non-linear second order odes (in more than one variable)
 as boundary value problems by the finite difference method

 odefun provides ode coefficients c:
 c(x,1) y''(x) + c(x,2) y'(x) + c(x,3) y = c(x,4)
  c_1 y" + c_2 y' + c_3 y + c_4 = 0

 subject to the boundary conditions
 bcfun provides v and p and optionally q, so that:

 b_1 y + b_2 y' = f
    q(x,1)*( p(x,1) y_l(x) + p(x,2)  y_l'(x)
  + q(x,2)*( p(x,1) y_r(x) + p(x,2) y_r'(x)    = v(x)
 where q weighs the waves travelling from left to right and right to left (default [1 1])

\end{lstlisting}
\subsection{bvp2wavetrain}
${}$
\begin{lstlisting}
 solve second order boundary value problem by repeated integration

\end{lstlisting}
\subsection{bvp2wavetwopass}
${}$
\begin{lstlisting}
 two pass solution for the linearised wave equation
 solve first for the wave number k, and then for y

\end{lstlisting}
\subsection{ivp\_euler\_forward}
${}$
\begin{lstlisting}
 solve intial value problem by the euler forward method

\end{lstlisting}
\subsection{ivprk2}
${}$
\begin{lstlisting}
 solve initial value problem by the two step runge kutta method

\end{lstlisting}
\subsection{ode2\_matrix}
${}$
\begin{lstlisting}
 transformation matrix of second order ode
 to left and right going wave

 c = odefun(x)
 c1 y'' + c2' y + c3 y == 0
 y = y_p + y_m, left and right going wave
 d/dx [y_p, y_m] = A*[y_m, y_p]

\end{lstlisting}
\subsection{ode2characteristic}
${}$
\begin{lstlisting}
 second order odes 
 transmittded and reflected wave

\end{lstlisting}
\subsection{step\_trapezoidal}
${}$
\begin{lstlisting}
 single trapezoidal step

\end{lstlisting}
\subsection{test\_bvp2}
${}$
\begin{lstlisting}

\end{lstlisting}
\section{lib/mathematics/numerical-methods/optimisation}
\subsection{armijo\_stopping\_criterion}
${}$
\begin{lstlisting}
 armijo stopping criterion for optimizations

\end{lstlisting}
\subsection{astar}
${}$
\begin{lstlisting}
 astar path finding alforithm

\end{lstlisting}
\subsection{binsearch}
${}$
\begin{lstlisting}
 binary search on a line

\end{lstlisting}
\subsection{bisection}
${}$
\begin{lstlisting}
 bisection

\end{lstlisting}
\subsection{box1}
${}$
\begin{lstlisting}
 test objective function for optimisation routines 

\end{lstlisting}
\subsection{box2}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{cauchy}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{cauchy2}
${}$
\begin{lstlisting}
 solve non-linear system by cuachy's method
 slower than quadratic optimisation, but does not require a hessian
 fun : objective function, returns
	f  : scalar, objective function value 
	g  : nx1, gradient
 x   : nx1, initial position
 opt : options

\end{lstlisting}
\subsection{directional\_derivative}
${}$
\begin{lstlisting}
 directional (projected) derivative
 d : derivative, highest first
 p : series expansion around x0

\end{lstlisting}
\subsection{dud}
${}$
\begin{lstlisting}
 optimization by the dud algorithm

\end{lstlisting}
\subsection{extreme3}
${}$
\begin{lstlisting}
 extract maxima by quadratic approximation from sampled function val(t)
 intended to be called after [mval, mid] = max(val) for refinement of
 locatian and maximum

 input
 t    : sampling time (uniformly spaced)
 v    : values at sampling times
 ouput:
 tdx  : index where extremum should be computed
 t0   : location of the extremum
 val0 : value of extremum

 v'(dt0) = 0 and v''(dt0) determines type of extremum

\end{lstlisting}
\subsection{extreme\_quadratic}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{ftest}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{fzero\_bisect}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{fzero\_newton}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{grad}
${}$
\begin{lstlisting}
 numerical gradient

\end{lstlisting}
\subsection{hessian}
${}$
\begin{lstlisting}
 numerical hessian

\end{lstlisting}
\subsection{hessian\_from\_gradient}
${}$
\begin{lstlisting}
 numerical hessian from gradient

\end{lstlisting}
\subsection{hessian\_projected}
${}$
\begin{lstlisting}
 numerical hessian projected to one dimenstion

\end{lstlisting}
\subsection{line\_search}
${}$
\begin{lstlisting}
 bisection routine

\end{lstlisting}
\subsection{line\_search2}
${}$
\begin{lstlisting}
 bisection method

 fun : objective funct
 x0  : start value
 f0  : objective function value at x0
 g   : gradient at x0
 p   : search direction from x0 (p = g for steepest descend)
 h   : initial step length (default 1)
 lb  : lower bound for x
 up  : upper bound for x

\end{lstlisting}
\subsection{line\_search\_polynomial}
${}$
\begin{lstlisting}
 polynomial line search
 fun : objective funct
 x0  : start value
 f0  : objective function value at x0
 g   : gradient at x0
 dir : search direction from x0 (p = g for steepest descend)
 h   : initial step length (default 1)
 lb  : lower bound for x
 up  : upper bound for x

\end{lstlisting}
\subsection{line\_search\_polynomial2}
${}$
\begin{lstlisting}
 cubic line search
 fun : objective funct
 x0  : start value
 f0  : objective function value at x0
 g   : gradient at x0
 dir : search direction from x0 (p = g for steepest descend)
 h   : initial step length (default 1)
 lb  : lower bound for x
 up  : upper bound for x

\end{lstlisting}
\subsection{line\_search\_quadratic}
${}$
\begin{lstlisting}
 quadratic line search
 fun : objective funct
 x0  : start value
 f0  : objective function value at x0
 g   : gradient at x0
 dir : search direction from x0 (p = g for steepest descend)
 h   : initial step length (default 1)
 lb  : lower bound for x
 up  : upper bound for x

\end{lstlisting}
\subsection{line\_search\_quadratic2}
${}$
\begin{lstlisting}
 quadratic line search

\end{lstlisting}
\subsection{line\_search\_wolfe}
${}$
\begin{lstlisting}
 line search by wolfe method
 c.f.: OPTIMIZATION THEORY AND METHODS - Nonlinear Programming, Sun, Yuan

\end{lstlisting}
\subsection{ls\_bgfs}
${}$
\begin{lstlisting}
 least squares by the bgfs method

\end{lstlisting}
\subsection{ls\_broyden}
${}$
\begin{lstlisting}
 least squares by the broyden method
 for rectangular / non symmetric systems
	Numerical  Optimization nocedal
	Practical  Methods  of  Optimization fletcher
 c.f. gerber 1981
 c.f. fletcher 1978 (more advanced, not used here)
 c.f. Kelley 1999 ch. 4

 BGFS:
 Broyden 1965
 Fletcher 1970
 Goldfarb 1970
 Shanno 1970

\end{lstlisting}
\subsection{ls\_generalized\_secant}
${}$
\begin{lstlisting}
 least squares by the secant method
 Barnes, 1965
 Wolfe, 1959
 Fletcher 1980, 6.3
 seber 2003
 gerber

\end{lstlisting}
\subsection{nlcg}
${}$
\begin{lstlisting}
 non-linear conjugate gradient
 input:
 x   : nx1 start vectort
 opt : struct options
 fdx : gradient constraint

\end{lstlisting}
\subsection{nlls}
${}$
\begin{lstlisting}
 non-linear least squares

\end{lstlisting}
\subsection{picard}
${}$
\begin{lstlisting}
 picard iteration

\end{lstlisting}
\subsection{poly\_extrema}
${}$
\begin{lstlisting}
 extrema of a polynomial

\end{lstlisting}
\subsection{quadratic\_function}
${}$
\begin{lstlisting}
 evaluate quadratic function in higher dimensions

\end{lstlisting}
\subsection{quadratic\_programming}
${}$
\begin{lstlisting}
 optimize by quadratic programming

\end{lstlisting}
\subsection{quadratic\_step}
${}$
\begin{lstlisting}
 single step of the quadratic programming

\end{lstlisting}
\subsection{rosenbrock}
${}$
\begin{lstlisting}
 rosenbrock test function

\end{lstlisting}
\subsection{sqrt\_heron}
${}$
\begin{lstlisting}
 Heron's method for the square root

\end{lstlisting}
\subsection{test\_directional\_derivative}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{test\_dud}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{test\_fzero\_newton}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{test\_line\_search\_quadratic2}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{test\_ls\_generalized\_secant}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{test\_nlcg\_6\_order}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{test\_nlls}
${}$
\begin{lstlisting}
	f = w'*(p*abs(x-1).^4) + w'*(1-p)*abs(x-1).^2;

\end{lstlisting}
\section{lib/mathematics/numerical-methods/pde}
\subsection{laplacian2d\_fundamental\_solution}
${}$
\begin{lstlisting}

\end{lstlisting}
\section{lib/mathematics/numerical-methods/piecewise-polynomials}
\subsection{Hermite1}
${}$
\begin{lstlisting}
 hermite polynomial interpolation in 1d

\end{lstlisting}
\subsection{hp2\_fit}
${}$
\begin{lstlisting}

 fit a hermite polynomial
 coefficients are derivative free
 x0  : left point of first segment
 x1  : right point of last segment
 n   : number of segments
 x   : sample x-value
 val : sample y-value
 c   : coefficients (values at points, no derivatives)

\end{lstlisting}
\subsection{hp2\_predict}
${}$
\begin{lstlisting}
 prediction with pw hermite polynomial
 c are values at support points

\end{lstlisting}
\subsection{hp\_predict}
${}$
\begin{lstlisting}
 predict with piecewise hermite polynomial

\end{lstlisting}
\subsection{hp\_regress}
${}$
\begin{lstlisting}
 fit piecewise hermite polynomial
 coefficients are values and derivatives

\end{lstlisting}
\subsection{lp\_count}
${}$
\begin{lstlisting}
 lagrangian basis for interpolation
 count number of valid samples

\end{lstlisting}
\subsection{lp\_predict}
${}$
\begin{lstlisting}
 lagrangian basis piecwie interpolation, predicor

\end{lstlisting}
\subsection{lp\_regress}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{lp\_regress\_}
${}$
\begin{lstlisting}

\end{lstlisting}
\section{lib/mathematics/regression/@PolyOLS}
\subsection{PolyOLS}
${}$
\begin{lstlisting}
 class for polynomial least squares

\end{lstlisting}
\subsection{coefftest}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{detrend}
${}$
\begin{lstlisting}
 detrending by polynomial regression

\end{lstlisting}
\subsection{fit}
${}$
\begin{lstlisting}
 fit a polynomial function
 like polyfit, but returns parameter error estimates
 TODO automatically activate scaleflag

\end{lstlisting}
\subsection{fit\_}
${}$
\begin{lstlisting}
 fit a polynomial function

\end{lstlisting}
\subsection{predict}
${}$
\begin{lstlisting}
 predict polynomial function values

\end{lstlisting}
\subsection{predict\_}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{slope}
${}$
\begin{lstlisting}
 slope by linear regression

\end{lstlisting}
\section{lib/mathematics/regression/@PowerLS}
\subsection{PowerLS}
${}$
\begin{lstlisting}
 class for power law regression

\end{lstlisting}
\subsection{fit}
${}$
\begin{lstlisting}
 fit a power law
 like polyfit, but returns parameter error estimates

\end{lstlisting}
\subsection{predict}
${}$
\begin{lstlisting}
 predict with power law
	S2 = diag((A*obj.C)*A');
	L  = Y - S;
	U  = Y + S;

\end{lstlisting}
\subsection{predict\_}
${}$
\begin{lstlisting}

\end{lstlisting}
\section{lib/mathematics/regression/@Theil}
\subsection{Theil}
${}$
\begin{lstlisting}
 Kendal-Theil-Sen robust regression

\end{lstlisting}
\subsection{detrend}
${}$
\begin{lstlisting}
 linear detrending of a set of samples by the Theil-Senn Slope

\end{lstlisting}
\subsection{fit}
${}$
\begin{lstlisting}
 fit slope and intercept to a set of sample with the Theil-Sen method
 
 c     : confidence interval c = 2*ns*normcdf(1) for ns-sigma intervals
 param : itercept and slope
 P : confidence interval

\end{lstlisting}
\subsection{predict}
${}$
\begin{lstlisting}
 predict values and confidence intervals with the Theil-Sen method

\end{lstlisting}
\subsection{slope}
${}$
\begin{lstlisting}
 fit the slope with the Theil-Sen method

\end{lstlisting}
\section{lib/mathematics/regression}
\begin{lstlisting}
linear and non-linear regression

\end{lstlisting}
\subsection{Theil\_Multivariate}
${}$
\begin{lstlisting}
 extension of the Theil-Senn regression to higher dimensions by
 means of the Gauss-Seidel iteration

\end{lstlisting}
\subsection{areg}
${}$
\begin{lstlisting}
 regression using the pth-fraction of samples with smallest residual

\end{lstlisting}
\subsection{ginireg}
${}$
\begin{lstlisting}
 gini regression

\end{lstlisting}
\subsection{hesssimplereg}
${}$
\begin{lstlisting}
 hessian, gradient and objective function value of the simple regression
 rhs = p(1) + p(2) x + eps

\end{lstlisting}
\subsection{l1lin}
${}$
\begin{lstlisting}
 solve ||Ax - b||_L1 by means of linear programming

\end{lstlisting}
\subsection{lsq\_sparam}
${}$
\begin{lstlisting}
 parameter covariance of the least squares regression

 fun : model function for predtiction
 b   : sample values
 f(p) = b
 p   : parameter at point of evaluation (preferably optimum)

\end{lstlisting}
\subsection{polyfitd}
${}$
\begin{lstlisting}
 fit a polynomial of order n to a set of sampled values and sampled values
 of the derivative

 x0 must contain at least for conditioning as otherwise the intercept
 cannot be determined

\end{lstlisting}
\subsection{regression\_method\_of\_moments}
${}$
\begin{lstlisting}
 fit linear function ||a b x = y||_L2 by the method of moments
 y+eps = alpha + beta*x

\end{lstlisting}
\subsection{robustlinreg}
${}$
\begin{lstlisting}
 fit a linear function by splitting the x-values at their median
 	(med(y_left) - med(y_right))/(med(x_left)-med(x_right)
 this approach performs poorly compared to the theil-senn operator

\end{lstlisting}
\subsection{theil2}
${}$
\begin{lstlisting}
 Theil senn-estimator for two dimensions (glm)

\end{lstlisting}
\subsection{theil\_generalised}
${}$
\begin{lstlisting}
 generalization of the Theil-Senn operator to higher dimensions,
 for arbitrary functions such as polynomials and multivariate regression
 either higher order polynomials or glm
 c.f. "On theil's fitting method", Pegoraro, 1991

\end{lstlisting}
\subsection{total\_least\_squares}
${}$
\begin{lstlisting}
 total least squares

\end{lstlisting}
\subsection{weighted\_median\_regression}
${}$
\begin{lstlisting}
 weighted median regression 
 c.f. Scholz, 1978

\end{lstlisting}
\section{lib/mathematics/set-theory}
\subsection{issubset}
${}$
\begin{lstlisting}
 test if set B is subset of A in O(n)-runtime

 A : first set
 B : second set
 P : set of primes (auxiliary)

\end{lstlisting}
\section{lib/mathematics/signal-processing}
\subsection{acf\_effective\_sample\_size}
${}$
\begin{lstlisting}
 effective sample size from acf

\end{lstlisting}
\subsection{acf\_genton}
${}$
\begin{lstlisting}
 autocorrelation function

\end{lstlisting}
\subsection{acfar1}
${}$
\begin{lstlisting}
 Autocorrelation function of the finite AR1 process

 a_k = 1/(n-k)sum x_ix_i+1 + (xi + xi+k)mu + mu^2
     = r^k + 1/n sum_ij + 1/n
	pause

\end{lstlisting}
\subsection{acfar1\_2}
${}$
\begin{lstlisting}
 autocorrelation of the ar1 process

\end{lstlisting}
\subsection{acfar2}
${}$
\begin{lstlisting}
 impulse response of the ar2 process

\end{lstlisting}
\subsection{acfar2\_2}
${}$
\begin{lstlisting}
 autocorrelation of the ar2 process
 X_i + a1 X_i-1 + a2 X_i-2 = 0

\end{lstlisting}
\subsection{ar1\_cutoff\_frequency}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{ar1\_effective\_sample\_size}
${}$
\begin{lstlisting}
 effective sample size correction for autocorrelated series

\end{lstlisting}
\subsection{ar1\_mse\_mu\_single\_sample}
${}$
\begin{lstlisting}
 standard error of a single sample of an ar1 correlated process

\end{lstlisting}
\subsection{ar1\_mse\_pop}
${}$
\begin{lstlisting}
 variance of the population mean of a single realisation around zero

 E[(mu_N-0)^2] = E[mu_N^]


\end{lstlisting}
\subsection{ar1\_mse\_range}
${}$
\begin{lstlisting}
 mean standard error of the mean of a range of values taken from an ar1 process

\end{lstlisting}
\subsection{ar1\_spectrum}
${}$
\begin{lstlisting}
 spectrum of the ar1 process

\end{lstlisting}
\subsection{ar1\_to\_tikhonov}
${}$
\begin{lstlisting}
 convert ar1 correlation to tikhonovs lambda

\end{lstlisting}
\subsection{ar1\_var\_factor}
${}$
\begin{lstlisting}
 variance correction factor for an autocorrelated finite process
 n   : [1 .. inf] population size
 m   : [1 .. n]   samples size
 rho : [ -1 < rho < 1 (for convergence) ] correlation of samples

\end{lstlisting}
\subsection{ar1\_var\_factor\_}
${}$
\begin{lstlisting}
 variance of an autocorrelated finite process

\end{lstlisting}
\subsection{ar1\_var\_range2}
${}$
\begin{lstlisting}
 variance of sub sample starting at the end of the series

 from the finite length first order autocorrelated process

 s2 = 1/m^2 sum_i^m sum_j^m rho^-|i-j|

\end{lstlisting}
\subsection{ar1delay}
${}$
\begin{lstlisting}
 approximate acf by the ar1 process
 acf: autocovariance or autocorrerlation function
 nf : skip first samples (for mixed geometric-arithmetic series (ARMA)

\end{lstlisting}
\subsection{ar1delay\_old}
${}$
\begin{lstlisting}
 autocorrelation of the residual

\end{lstlisting}
\subsection{ar2conv}
${}$
\begin{lstlisting}
 coefficients of the ar2 process determined from the two leading correlations
 of the acf [1,r1,r2,...]

\end{lstlisting}
\subsection{ar2dof}
${}$
\begin{lstlisting}
 effective samples size for the ar2 process

\end{lstlisting}
\subsection{ar2param}
${}$
\begin{lstlisting}
 ar2 parameter estimation from first two terms of acf

 acf = [1 a1 a2 ...]

\end{lstlisting}
\subsection{asymwin}
${}$
\begin{lstlisting}
 creates asymmetrical filter windows
 filter will always have negative weights

\end{lstlisting}
\subsection{autocorr\_fft}
${}$
\begin{lstlisting}
 autocorrelation function

\end{lstlisting}
\subsection{bandpass}
${}$
\begin{lstlisting}
 bandpass filter

\end{lstlisting}
\subsection{bandpass2}
${}$
\begin{lstlisting}
 bandpass filter

\end{lstlisting}
\subsection{bartlett}
${}$
\begin{lstlisting}
 Effective sample size factor for bartlett window
 c.f. thiebaux
 c.f spectral analysis-jenkins, eq. (6.3.27)
 c = acf
 note: results seams always to be 1 tac too low
 T : reduction factor for dof
 for ar1 with a = rho^k = exp(-k/L), T = 2L

\end{lstlisting}
\subsection{bartlett\_spectrogram}
${}$
\begin{lstlisting}
 bartlet spectrogramm
 TODO sliding window

\end{lstlisting}
\subsection{bin1d}
${}$
\begin{lstlisting}
 bin values of v sampled at x into bins bounded by "edges"
 apply function v to it

\end{lstlisting}
\subsection{bin2d}
${}$
\begin{lstlisting}
 bin values of V sampled at X and Y into the grid structured grid ex,ey
 apply function func to all walues in the bin
 func = mean : default
 func = sum : non-normalized frequency histogram in 2D

\end{lstlisting}
\subsection{binormrnd}
${}$
\begin{lstlisting}
 generate two correlated normally distributed vectors

\end{lstlisting}
\subsection{conv1\_man}
${}$
\begin{lstlisting}
 convolutions with padding

\end{lstlisting}
\subsection{conv2\_man}
${}$
\begin{lstlisting}
 convolution in 2d

\end{lstlisting}
\subsection{conv2z}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{conv30}
${}$
\begin{lstlisting}
 convolve with rectangular window of lenght n
 circular boundaries

\end{lstlisting}
\subsection{conv\_}
${}$
\begin{lstlisting}
 convolution of a with b

\end{lstlisting}
\subsection{conv\_centered}
${}$
\begin{lstlisting}
 convolve x with filter window f
 when length of f is even, this guarantees a symmetric result (no off by on
 displacement) by making the lenght of f odd at first

\end{lstlisting}
\subsection{convz}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{cosexpdelay}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{csmooth}
${}$
\begin{lstlisting}
 smooth recursively with [1,2,1]/4 kernel

\end{lstlisting}
\subsection{daniell\_window}
${}$
\begin{lstlisting}
 Daniell window for smoothing the power spectrum
 c.f. Daniell 1946
 Bloomfield 2000
 meko 2015

\end{lstlisting}
\subsection{danielle\_window}
${}$
\begin{lstlisting}
 danielle fourier window

\end{lstlisting}
\subsection{db2neper}
${}$
\begin{lstlisting}
 convert decibel to neper

\end{lstlisting}
\subsection{db2power}
${}$
\begin{lstlisting}
 power ratio from db

\end{lstlisting}
\subsection{derive\_danielle\_weight}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{derive\_limit\_0\_acfar}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{detect\_peak}
${}$
\begin{lstlisting}
 detect peaks in a vector
 requires function value to fall to p*max before new value is allowed

\end{lstlisting}
\subsection{digital\_low\_pass\_filter}
${}$
\begin{lstlisting}
 design coefficients of a low pass filter with specified cut of frequency
 and sampling period
 alalogue low pass with pole at s=-omega_c=1/tau=1/RC
 Ha = tau/(tau + s) = 1/(1 + omega_c*s)

\end{lstlisting}
\subsection{doublesum\_ij}
${}$
\begin{lstlisting}
 double sum of r^i

\end{lstlisting}
\subsection{effective\_sample\_size\_to\_ar1}
${}$
\begin{lstlisting}
 convert effective sample size to ar1 correlation

\end{lstlisting}
\subsection{filt\_hodges\_lehman}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{filter1}
${}$
\begin{lstlisting}
 filter along one dimension

\end{lstlisting}
\subsection{filter2}
${}$
\begin{lstlisting}
 filter columns of x (matlab does only support vector input)

\end{lstlisting}
\subsection{filter\_}
${}$
\begin{lstlisting}
 invalidate values that exceed n-times the robust standard deviation

\end{lstlisting}
\subsection{filteriir}
${}$
\begin{lstlisting}
 filter adcp t-n data over time

 v : nz,nt   : values to be filtered
 H : nt,1    : depth of ensemble
 last : nt,1 : last bin above bottom that can be sampled without side lobe interference
 nf : scalar : number of reweighted iterations

 when samples 
 - distance to bed is reference (advantageous for near-bed suspended transport)
 TODO for wash load: distance to surface is more relevant
 interpolate depending on z

 when depth changes, neighbouring indices do not correspond to same relative position in the water column
 relative poisition in the colum (s-coordinate) smoothes values
 near the bed: absolute distance to bed is chosen
 near surface: absolute distance to surface is chosen
 -> cubic transformation of index

 faster and avoid alising (smoothing along z)
	resample ensemble to same number of bins in S -> filter -> resample back
	use nonlinear transform z-s coordinates
 -> resampling has to be local (Hi -> H-filtered)

 filtered profile coordinates to sample coordinates
 	zf -> zi (special transform)
 corresponding indices and fractions
 filtration step (update of hf and vf)
 sample coordinates to updated profile coordinates
 (the inverse step is actually not necessary)
 write filtered value

\end{lstlisting}
\subsection{filterp}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{filterp1}
${}$
\begin{lstlisting}
 fir filter with some fancy extras

\end{lstlisting}
\subsection{filterstd}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{firls\_man}
${}$
\begin{lstlisting}
 design finite impulse response filter by the least squares method

\end{lstlisting}
\subsection{flattopwin}
${}$
\begin{lstlisting}
 the flat top window

\end{lstlisting}
\subsection{frequency\_response\_boxcar}
${}$
\begin{lstlisting}
 frquency response of a boxcar filter

\end{lstlisting}
\subsection{freqz\_boxcar}
${}$
\begin{lstlisting}
 frequncy response of a boxcar filter

\end{lstlisting}
\subsection{gaussfilt1}
${}$
\begin{lstlisting}
 filter data series with a gaussian window

\end{lstlisting}
\subsection{hanchangewin}
${}$
\begin{lstlisting}
 hanning window for change point detection

\end{lstlisting}
\subsection{hanchangewin2}
${}$
\begin{lstlisting}
 nanning window for chage point detection

\end{lstlisting}
\subsection{hanwin}
${}$
\begin{lstlisting}
 hanning filter window

\end{lstlisting}
\subsection{hanwin\_}
${}$
\begin{lstlisting}
 hanning filter window

\end{lstlisting}
\subsection{highpass}
${}$
\begin{lstlisting}
 high pass filter

\end{lstlisting}
\subsection{kaiserwin}
${}$
\begin{lstlisting}
 kaiser filter window

\end{lstlisting}
\subsection{kalman}
${}$
\begin{lstlisting}
 Kalman filter

\end{lstlisting}
\subsection{lanczoswin}
${}$
\begin{lstlisting}
 Lanczos window

\end{lstlisting}
\subsection{last}
${}$
\begin{lstlisting}
 lake tail, but for matrices

\end{lstlisting}
\subsection{lowpass}
${}$
\begin{lstlisting}
 low pass filter

\end{lstlisting}
\subsection{lowpass2}
${}$
\begin{lstlisting}
 design low pass filter with cutoff-frequency f1

\end{lstlisting}
\subsection{lowpass\_iir}
${}$
\begin{lstlisting}
 iir-low pass

\end{lstlisting}
\subsection{lowpass\_iir\_symmetric}
${}$
\begin{lstlisting}
 two-sided iir low pass filter (for symmetry)

\end{lstlisting}
\subsection{lowpassfilter2}
${}$
\begin{lstlisting}
 low-pass filter of data

\end{lstlisting}
\subsection{maxfilt1}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{meanfilt1}
${}$
\begin{lstlisting}
 moving average filter with special treatment of the boundaries

\end{lstlisting}
\subsection{medfilt1\_man}
${}$
\begin{lstlisting}
 moving median filter, supports columnwise operation

\end{lstlisting}
\subsection{medfilt1\_man2}
${}$
\begin{lstlisting}
 moving median filter with special treatment of boundaries

\end{lstlisting}
\subsection{medfilt1\_padded}
${}$
\begin{lstlisting}
 median filter with padding

\end{lstlisting}
\subsection{medfilt1\_reduced}
${}$
\begin{lstlisting}
 median filter with padding

\end{lstlisting}
\subsection{mid\_term\_single\_sample}
${}$
\begin{lstlisting}
 variance of single sample, mid term

\end{lstlisting}
\subsection{minfilt1}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{mu2ar1}
${}$
\begin{lstlisting}
 error variance of the mean of the finite length ar1 process


 (mu)^2 = (sum epsi)^2 = sum_i sum_j eps_i eps_j = sum_ii(rho,n)/n^2
 this has the limit s^2 for rho->1 

\end{lstlisting}
\subsection{mysmooth}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{nanautocorr}
${}$
\begin{lstlisting}
 autocorrelation with nan-values

\end{lstlisting}
\subsection{nanmedfilt1}
${}$
\begin{lstlisting}
 medfilt1, skipping nans

\end{lstlisting}
\subsection{neper2db}
${}$
\begin{lstlisting}
 convert neper to db

\end{lstlisting}
\subsection{peaks\_man}
${}$
\begin{lstlisting}
 peaks of a periodogram

\end{lstlisting}
\subsection{polyfilt1}
${}$
\begin{lstlisting}
 polynomial filter,
 can be achieved by iteratively processing the data with
 a mean (zero-order) filter

\end{lstlisting}
\subsection{qmedfilt1}
${}$
\begin{lstlisting}
 medfilt1, after fitting a quadratic polynomial

\end{lstlisting}
\subsection{randar1}
${}$
\begin{lstlisting}
 generate random ar1 process
 e1 = randar1(sigma,p,n,m)

\end{lstlisting}
\subsection{randar1\_dual}
${}$
\begin{lstlisting}
 draw random variables of two corrlated ar1 processes

\end{lstlisting}
\subsection{randar2}
${}$
\begin{lstlisting}
 generate ar2 process

\end{lstlisting}
\subsection{randarp}
${}$
\begin{lstlisting}
 randomly generate the instance of an ar-p process

\end{lstlisting}
\subsection{range\_window}
${}$
\begin{lstlisting}
 range of values within a certain range of indices (window)

\end{lstlisting}
\subsection{rectwin}
${}$
\begin{lstlisting}
 rectangular window

\end{lstlisting}
\subsection{recursive\_sum}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{select\_range}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{smooth1d\_parametric}
${}$
\begin{lstlisting}
 smooth position of p0=x0,y0 between p1=x1,y1 and p2=x2,y2,
 so that distance to p1 and p2 becomes equal
 and the chord length remains the same

\end{lstlisting}
\subsection{smooth2}
${}$
\begin{lstlisting}
 smooth vectos of X

\end{lstlisting}
\subsection{smooth\_man}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{smooth\_parametric}
${}$
\begin{lstlisting}
 smooth a parametric function given in x-y coordinates
	matvec2x2(R,[dxc;dyc])

\end{lstlisting}
\subsection{smooth\_parametric2}
${}$
\begin{lstlisting}
 parametrically smooth the curve

\end{lstlisting}
\subsection{smooth\_with\_splines}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{smoothfft}
${}$
\begin{lstlisting}
 filter with fast fourier transform

\end{lstlisting}
\subsection{spectrogram}
${}$
\begin{lstlisting}
 spectrogram

\end{lstlisting}
\subsection{std\_window}
${}$
\begin{lstlisting}
 moving block standard deviation

\end{lstlisting}
\subsection{sum\_i\_lag}
${}$
\begin{lstlisting}
 sum of ar1 matrix with lag
 sum_i=1^n rho^|i-k|

\end{lstlisting}
\subsection{sum\_ii}
${}$
\begin{lstlisting}
 sum of ar1 matrix
 sum_i=1^n sum_j=1^n rho^|i-j|
 this is for the variance, take square root for the standard deviation factor

\end{lstlisting}
\subsection{sum\_ii\_}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{sum\_ij}
${}$
\begin{lstlisting}
 sum of ar1 matrix
 sum_{i=1}^n sum_{j=1}^m r^|i-j|

\end{lstlisting}
\subsection{sum\_ij\_}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{sum\_ij\_partial\_}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{sum\_multivar}
${}$
\begin{lstlisting}
 sum of matrix entries of bivariate ar1 process

\end{lstlisting}
\subsection{test\_acfar1}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{test\_acfar1\_2}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{test\_acfar1\_3}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{test\_acfar1\_4}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{test\_acfar2}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{test\_ar1\_var\_factor}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{test\_ar1\_var\_factor\_2}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{test\_ar1\_var\_mu\_single\_sample}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{test\_ar1\_var\_pop}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{test\_ar1\_var\_pop\_1}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{test\_ar1delay}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{test\_bivariate\_covariance\_term}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{test\_convexity}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{test\_lanczoswin}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{test\_madcorr}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{test\_randar1}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{test\_randar1\_multivariate}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{test\_randar2}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{test\_sum\_ij}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{test\_sum\_multivar}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{test\_trifilt1}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{test\_wautocorr}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{test\_wavelet\_transform}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{test\_wordfilt}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{test\_xar1\_mid\_term}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{tikhonov\_to\_ar1}
${}$
\begin{lstlisting}
 convert coefficient of the tikhonov regularization to correlatioon of the ar1 process

\end{lstlisting}
\subsection{trapwin}
${}$
\begin{lstlisting}
 trapezoidal filter window

\end{lstlisting}
\subsection{trifilt1}
${}$
\begin{lstlisting}
 filter with triangular window

\end{lstlisting}
\subsection{triwin}
${}$
\begin{lstlisting}
 triangular filter window

\end{lstlisting}
\subsection{triwin2}
${}$
\begin{lstlisting}
 triangular filter window

\end{lstlisting}
\subsection{varar1}
${}$
\begin{lstlisting}
 error variance of a single sample of a finite length ar1 process
 with respect to the mean, averaged over the population

\end{lstlisting}
\subsection{welch\_spectrogram}
${}$
\begin{lstlisting}
 welch spectrogram

\end{lstlisting}
\subsection{wfilt}
${}$
\begin{lstlisting}
 filter with window

\end{lstlisting}
\subsection{winbandpass}
${}$
\begin{lstlisting}
 filter with bandpass

\end{lstlisting}
\subsection{window\_make\_odd}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{winfilt0}
${}$
\begin{lstlisting}
 filter with window

\end{lstlisting}
\subsection{winlength}
${}$
\begin{lstlisting}
 window length for desired cutoff frequency
 power at fc is halved
 H(wf) = 1/sqrt(2) H(f)
 if the filter window were used as a low pass filter
 note: the user should prefer a windowed ideal low pass filter
 TODO, relate this to DOF

\end{lstlisting}
\subsection{wmeanfilt}
${}$
\begin{lstlisting}
 mean filter with window

\end{lstlisting}
\subsection{wmedfilt}
${}$
\begin{lstlisting}
 median filter with window

\end{lstlisting}
\subsection{wordfilt}
${}$
\begin{lstlisting}
 weighted order filter

\end{lstlisting}
\subsection{wordfilt\_edgeworth}
${}$
\begin{lstlisting}
 weighed order filter

\end{lstlisting}
\subsection{xar1}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{xcorr\_man}
${}$
\begin{lstlisting}
 cross correlation of two sampled ar1 processes

\end{lstlisting}
\section{lib/mathematics/sorting}
\subsection{sort2}
${}$
\begin{lstlisting}
 sort two numbers

\end{lstlisting}
\subsection{sort2d}
${}$
\begin{lstlisting}
 sort elements of matrix in X
 returns row and column index of sorted values

\end{lstlisting}
\section{lib/mathematics/special-functions}
\subsection{bessel\_sphere}
${}$
\begin{lstlisting}
 spherical Bessel function of the first kind

\end{lstlisting}
\subsection{digamma\_man}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{hankel\_sphere}
${}$
\begin{lstlisting}
 spherical Hankel function for the far field (incident plane wave)
 first kind

\end{lstlisting}
\subsection{hermite}
${}$
\begin{lstlisting}
 probabilistic's hermite polynomial by recurrence relation

 input :
 n : order
 x : value

 output:
 f : H_n(x)
 df : d/dx H_n(x)


\end{lstlisting}
\subsection{legendre\_man}
${}$
\begin{lstlisting}
 legendre polynomials

\end{lstlisting}
\subsection{neumann\_sphere}
${}$
\begin{lstlisting}
 spherical Neumann function
 Bessel function of the second kind

\end{lstlisting}
\section{lib/mathematics/statistics}
\subsection{atan\_s2}
${}$
\begin{lstlisting}
 stadard deviation of the arcus tangens by means of taylor expansion

\end{lstlisting}
\subsection{beta\_mode\_to\_parameter}
${}$
\begin{lstlisting}
 transform modes (mean and sd) to paramets of the beta function

\end{lstlisting}
\subsection{coefficient\_of\_determination}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{conditional\_expectation\_normal}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{correlation\_confidence\_pearson}
${}$
\begin{lstlisting}
 confience intervals of the correlation coefficient
 c.f. Fischer 1921

\end{lstlisting}
\section{lib/mathematics/statistics/distributions}
\subsection{PDF}
${}$
\begin{lstlisting}
 class for quasi-distributions from a set of sampling points

\end{lstlisting}
\subsection{binorm\_separation\_coefficient}
${}$
\begin{lstlisting}
 separation coefficient of a bimodal normal distribution

\end{lstlisting}
\subsection{binormcdf}
${}$
\begin{lstlisting}
 bio-modal gaussian distribution

\end{lstlisting}
\subsection{binormfit}
${}$
\begin{lstlisting}
 fit sum of to normal distribution to a histogram

\end{lstlisting}
\subsection{binormpdf}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{edgeworth\_cdf}
${}$
\begin{lstlisting}
 edgeworth expansion of an unknown cumulative distribution
 with mean mu, standard deviation sigma, and third and fourth cumulants
 c.f. Rao 2010

\end{lstlisting}
\subsection{edgeworth\_pdf}
${}$
\begin{lstlisting}

 probability density of and unknown distribution
 with mean mu, standard deviation sigma, and third and fourth cumulants
 c.f. Rao 2010

\end{lstlisting}
\subsection{logn\_mode2param}
${}$
\begin{lstlisting}
 transform modes (mu,sd) to parameters of the log normal distribution

\end{lstlisting}
\subsection{logn\_param2mode}
${}$
\begin{lstlisting}
 transform parameters to mode (mu, sd) for the log normal distribution

\end{lstlisting}
\subsection{lognpdf\_}
${}$
\begin{lstlisting}
 log normal distribution called by modes rather than parameters

\end{lstlisting}
\subsection{pdfsample}
${}$
\begin{lstlisting}
 pdf from sample distribution
 Note: better use kernal density estimates

\end{lstlisting}
\subsection{t2cdf}
${}$
\begin{lstlisting}
 Hotelling's T-squared cumulative distribution

\end{lstlisting}
\subsection{t2inv}
${}$
\begin{lstlisting}
 inverse of Hotelling's T-squared cumulative distribution

\end{lstlisting}
\section{lib/mathematics/statistics}
\subsection{example\_standard\_error\_of\_sample\_quantiles}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{f\_var\_finite}
${}$
\begin{lstlisting}
 reduction of variance when sampling from a finite population
 without replacement

\end{lstlisting}
\subsection{gamma\_mode\_to\_parameter}
${}$
\begin{lstlisting}
 transform modes (mu,sd) to parameters of the gamma distribution

\end{lstlisting}
\subsection{gaussfit3}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{gaussfit\_quantile}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{hodges\_lehmann\_correlation}
${}$
\begin{lstlisting}
 hodges_lehmann correlatoon coefficient
 c.f. Shamos 1976
 c.f. Bickel and Lehmann 1976
 c.f. rousseeuw 1993
 c.f. Shevlyakov 2011

\end{lstlisting}
\subsection{hodges\_lehmann\_dispersion}
${}$
\begin{lstlisting}
 dispersion determined by the hodges lehman method
 asymptotic efficiency of dispersion estimates:
 standard deviation:      E(s - hat s)/s = 2/sqrt(2 n) ~ 0.707/sqrt(n)			(100%)
 hodges lehmann dispersion E(s-\hat s)/s = (pi/3)^2 /(sqrt(2 n)) ~ 0.775/sqrt(n)	(91%)
 mad                      E(s-\hat s)/s ~ 1.17 s/sqrt(n)				(60%) 					
 c.f. Shamos 1976
 c.f. Bickel and Lehmann 1976
 c.f. rousseeuw 1993
 nb: rousseeuw uses the 25th percentile, which is more efficient for small sample sizes

\end{lstlisting}
\section{lib/mathematics/statistics/information-theory}
\subsection{akaike\_information\_criterion}
${}$
\begin{lstlisting}
 akaike information criterion

 serr : rmse of model prediction
 n : effective sample size
 k : number of parameters

 c.f. akaike (1974)
 c.f. sugiura 1978

\end{lstlisting}
\subsection{bayesian\_information\_criterion}
${}$
\begin{lstlisting}
 bayesian information criterion

\end{lstlisting}
\section{lib/mathematics/statistics}
\subsection{kurtncdf}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{kurtnpdf}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{kurtosis\_bias\_corrected}
${}$
\begin{lstlisting}
 bias corrected kurtosis

\end{lstlisting}
\subsection{limit}
${}$
\begin{lstlisting}
 limit a by lower and upper bound

\end{lstlisting}
\subsection{logfactorial}
${}$
\begin{lstlisting}
 approximate log of the factorial

\end{lstlisting}
\subsection{loglogpdf}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{lognfit\_quantile}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{logskewcdf}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{logskewpdf}
${}$
\begin{lstlisting}

\end{lstlisting}
\section{lib/mathematics/statistics/logu}
\subsection{lambertw\_numeric}
${}$
\begin{lstlisting}
 lambert-w function

\end{lstlisting}
\subsection{logtrialtcdf}
${}$
\begin{lstlisting}
 pdf of a logarithmic triangular distribution

\end{lstlisting}
\subsection{logtrialtinv}
${}$
\begin{lstlisting}
 inverse of the logarithmic triangular distribution
 = (d F log(a) log(b) + a log(b) - b log(a) - d F log(a) log(c) - a log(c) + d F log(b) log(c) + b log(c) - d F log^2(b))/((log(a) - log(b)) W((a^(-1/(log(a) - log(b))) (b^(-log(c)/log(a) - 1/log(a)) c)^(-log(a)/(log(a) - log(b))) (-d F log^2(b) + a log(b) + d F log(a) log(b) + d F log(c) log(b) - b log(a) - a log(c) + b log(c) - d F log(a) log(c)))/(log(a) - log(b))))
x = (d F log(a) log(b) + a log(b) - b log(a) - d F log(a) log(c) - a log(c) + d F log(b) log(c) + b log(c) - d F log^2(b))/((log(a) - log(b)) W((a^(-1/(log(a) - log(b))) (b^(-log(c)/log(a) - 1/log(a)) c)^(-log(a)/(log(a) - log(b))) (-d F log^2(b) + a log(b) + d F log(a) log(b) + d F log(c) log(b) - b log(a) - a log(c) + b log(c) - d F log(a) log(c)))/(log(a) - log(b))))

\end{lstlisting}
\subsection{logtrialtmean}
${}$
\begin{lstlisting}
 mean of the logarithmic triangular distribution

\end{lstlisting}
\subsection{logtrialtpdf}
${}$
\begin{lstlisting}
 density of the logarithmic triangular distribution

\end{lstlisting}
\subsection{logtrialtrnd}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{logtricdf}
${}$
\begin{lstlisting}
 cumulative distribution of the logarithmic triangular distribution

\end{lstlisting}
\subsection{logtriinv}
${}$
\begin{lstlisting}
 invere of the logarithmic triangular distribution

\end{lstlisting}
\subsection{logtrimean}
${}$
\begin{lstlisting}
 mean of the logarithmic triangular distribution

\end{lstlisting}
\subsection{logtripdf}
${}$
\begin{lstlisting}
 probability density of the logarithmic triangular distribution

\end{lstlisting}
\subsection{logtrirnd}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{logucdf}
${}$
\begin{lstlisting}
 probability density of the logarithmic uniform distribution

\end{lstlisting}
\subsection{logucm}
${}$
\begin{lstlisting}
 central moments of the log-uniform distribution

\end{lstlisting}
\subsection{loguinv}
${}$
\begin{lstlisting}
 inverse of the log-uniform distribution  

\end{lstlisting}
\subsection{logumean}
${}$
\begin{lstlisting}
 mean of the log-uniform distribution

\end{lstlisting}
\subsection{logupdf}
${}$
\begin{lstlisting}
 pdf of the log uniform distribution

\end{lstlisting}
\subsection{logurnd}
${}$
\begin{lstlisting}
 random numbers following a log-uniform distribution

\end{lstlisting}
\subsection{loguvar}
${}$
\begin{lstlisting}
 variance of the log-uniform distribution

\end{lstlisting}
\subsection{medlogu}
${}$
\begin{lstlisting}
 median of the log-uniform distribution

\end{lstlisting}
\subsection{test\_logurnd}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{tricdf}
${}$
\begin{lstlisting}
 cumulative distribution of the log-triangular distribution

\end{lstlisting}
\subsection{triinv}
${}$
\begin{lstlisting}
 inverse of the triangular distribution

\end{lstlisting}
\subsection{trimedian}
${}$
\begin{lstlisting}
 median of the triangular distribution

\end{lstlisting}
\subsection{tripdf}
${}$
\begin{lstlisting}
 probability density of the triangular distribution

\end{lstlisting}
\subsection{trirnd}
${}$
\begin{lstlisting}
 random numbers of the triangular distribution

\end{lstlisting}
\section{lib/mathematics/statistics}
\subsection{maxnnormals}
${}$
\begin{lstlisting}
 expected maximum of n normal variables
 c.f. Wolperts
 this is the median, not the mean of the maximum!
 see median of gumbel

\end{lstlisting}
\subsection{midrange}
${}$
\begin{lstlisting}
 mid range of columns of X

\end{lstlisting}
\subsection{minavg}
${}$
\begin{lstlisting}
 solution of the minimum variance problem
 minimise the variance of the weighted sum of n-independent
 random variables with equal mean and individual variance

\end{lstlisting}
\subsection{mode\_man}
${}$
\begin{lstlisting}

\end{lstlisting}
\section{lib/mathematics/statistics/moment-statistics}
\subsection{autocorr\_man3}
${}$
\begin{lstlisting}
 autoccorrelation of the columns of X 

\end{lstlisting}
\subsection{autocorr\_man4}
${}$
\begin{lstlisting}
 autocorrelation for x if x is a vector, or indivvidually for the 
 columns of x if x is a matrix

 c.f. box jenkins 2008 eq. 2.1.12

 Note that it is faster to compute the acf in frequency space
 as done in the matlab internal function

\end{lstlisting}
\subsection{autocorr\_man5}
${}$
\begin{lstlisting}
 autocorrellation of the columns of X

\end{lstlisting}
\subsection{blockserr}
${}$
\begin{lstlisting}
 estimate the standard error of potetially sequentilly correlated data
 by blocking
 block length should be sufficiently larger than correlation length
 and sufficiently smaller than data length
 this uses a sliding block approach, which reduces the variation of the error estimate

\end{lstlisting}
\subsection{comoment}
${}$
\begin{lstlisting}
 non-central higher order moments of the multivariate normal distribution

 c.f. Moments and cumulants of the multivariate real and complex Gaussian distributions
 
 note : there seem to be some typos in the original paper, 
	for x^4 cii^2, the square seems to be missing
 mu : nx1 mean vector
 C  : nxn covariance matrix
 k  : nx1 powers of variables in moments

\end{lstlisting}
\subsection{corr\_man}
${}$
\begin{lstlisting}
 correlation of two vectors

\end{lstlisting}
\subsection{cov\_man}
${}$
\begin{lstlisting}
 covariance matrix of two vectors

\end{lstlisting}
\subsection{dof}
${}$
\begin{lstlisting}
 mininum number of support points
 for a polynomial of degree order in dim dimensions

\end{lstlisting}
\subsection{edgeworth\_quantile}
${}$
\begin{lstlisting}
 inverse edgeworth expansion
 c.f. cornis fisher 1937
 c.f. Rao 2010
 c.f. 2.50 in hall
 CHERNOZHUKOV 3.3

\end{lstlisting}
\subsection{effective\_sample\_size}
${}$
\begin{lstlisting}
 effective sample size of the weighted mean of uncorrelated data
 c.f. Kish

\end{lstlisting}
\subsection{f\_correlation}
${}$
\begin{lstlisting}
 correction factor for standard error of the mean of n ar1-correlated iid samples

\end{lstlisting}
\subsection{f\_finite}
${}$
\begin{lstlisting}
 reduction factor of standard error for sampling from a finite distribution
 without replacement

\end{lstlisting}
\subsection{lmean}
${}$
\begin{lstlisting}
 mean of x.^l, not of abs

\end{lstlisting}
\subsection{lmoment}
${}$
\begin{lstlisting}
 l-moment of vector x

\end{lstlisting}
\subsection{maskmean}
${}$
\begin{lstlisting}
 mean of the masked values of X

\end{lstlisting}
\subsection{masknanmean}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{mean1}
${}$
\begin{lstlisting}
 mean of x

\end{lstlisting}
\subsection{mean\_man}
${}$
\begin{lstlisting}
 mean and standard error of X

\end{lstlisting}
\subsection{mse}
${}$
\begin{lstlisting}
 mean squared error of residual vector res
 this is de-facto the std for an unbiased residual

\end{lstlisting}
\subsection{nanautocorr\_man1}
${}$
\begin{lstlisting}
 autocorrelation of a vector with nan-values

\end{lstlisting}
\subsection{nanautocorr\_man2}
${}$
\begin{lstlisting}
 autocorrelation of a vector with nan-values

\end{lstlisting}
\subsection{nanautocorr\_man4}
${}$
\begin{lstlisting}
 compute autocorrelation for x if x is a vector, or indivvidually for the 
 columns of x if x is a matrix
 box jenkins 2008 eq. 2.1.12
 TODO nan is problematic!
 Note that it is faster to compute the acf in frequency space
 as done in the matlab internal function

\end{lstlisting}
\subsection{nancorr}
${}$
\begin{lstlisting}
 (co)-correlation matrix when samples a NaN

\end{lstlisting}
\subsection{nancumsum}
${}$
\begin{lstlisting}
 cumulative sum, setting nan values to zero

\end{lstlisting}
\subsection{nanlmean}
${}$
\begin{lstlisting}
 mean of the l-th power of the absolute value of x

\end{lstlisting}
\subsection{nanr2}
${}$
\begin{lstlisting}
 coefficient of determination when samples are invalid

\end{lstlisting}
\subsection{nanrms}
${}$
\begin{lstlisting}
 root mean square value when sample contains nan-values

\end{lstlisting}
\subsection{nanrmse}
${}$
\begin{lstlisting}
 root mean square error from vector of residuals
 this is de-facto the std for an unbiased residual

\end{lstlisting}
\subsection{nanserr}
${}$
\begin{lstlisting}
 standard error of x with respect to mean when x contains nan values

\end{lstlisting}
\subsection{nanwmean}
${}$
\begin{lstlisting}
 weighted mean
 min_x sum w (x-mu)^2 => mu = sum(wx)/sum(w)
 varargin can be dim
 function [mu serr] = nanwmean(w,x)

\end{lstlisting}
\subsection{nanwstd}
${}$
\begin{lstlisting}
 weighed standard deviation

\end{lstlisting}
\subsection{nanwvar}
${}$
\begin{lstlisting}
 weighted variance of columns, corrected for degrees of freedom (bessel)

 s^2 = sum(w*(x-sum(wx)/sum(w))^2)/sum(w)

\end{lstlisting}
\subsection{nanxcorr}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{pearson}
${}$
\begin{lstlisting}
 pearson correlation coefficient

\end{lstlisting}
\subsection{pearson\_to\_kendall}
${}$
\begin{lstlisting}
 conversion of pearson to kendall correlation coefficient
 c.f. Kruskal 1958

\end{lstlisting}
\subsection{pool\_samples}
${}$
\begin{lstlisting}
 pooled mean and standard deviation of several groups of different size, mean and standard deviation

\end{lstlisting}
\subsection{qmean}
${}$
\begin{lstlisting}
 trimmed mean

\end{lstlisting}
\subsection{range\_mean}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{rmse\_}
${}$
\begin{lstlisting}
 root mean square error computed from a residual vector
 this is de-facto the std for an unbiased residual

\end{lstlisting}
\subsection{serr}
${}$
\begin{lstlisting}
 standard error of the mean of a set of uncorrelated samples

\end{lstlisting}
\subsection{serr1}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{test\_qskew}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{test\_qstd\_qskew\_optimal\_p}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{wautocorr}
${}$
\begin{lstlisting}
 autocorrelation for x if x is a vector, or indivvidually for the 
 columns of x if x is a matrix
 samples can be weighted

 c.f. box jenkins 2008 eq. 2.1.12

 c.f. autocorr_man4

 Note that it is faster to compute the acf in frequency space
 as done in the matlab internal function

\end{lstlisting}
\subsection{wcorr}
${}$
\begin{lstlisting}
 correlation of two vectors when samples are weighted

\end{lstlisting}
\subsection{wcov}
${}$
\begin{lstlisting}
 covariance of two vectors when samples are weighted

\end{lstlisting}
\subsection{wdof}
${}$
\begin{lstlisting}
 effective degrees of freedom for weighted samples

\end{lstlisting}
\subsection{wkurt}
${}$
\begin{lstlisting}
 kurtosis with weighted samples

\end{lstlisting}
\subsection{wmean}
${}$
\begin{lstlisting}
 weighted mean

 min_x sum w (x-mu)^2 => mu = sum(wx)/sum(w)

 varargin can be dim
 function [mu serr] = wmean(w,x)

\end{lstlisting}
\subsection{wrms}
${}$
\begin{lstlisting}
 weighted root mean square error

\end{lstlisting}
\subsection{wserr}
${}$
\begin{lstlisting}
 weighted root mean square error

\end{lstlisting}
\subsection{wskew}
${}$
\begin{lstlisting}
 skewness of a weighted set of samples

\end{lstlisting}
\subsection{wstd}
${}$
\begin{lstlisting}
 weighed standard deviation

\end{lstlisting}
\subsection{wvar}
${}$
\begin{lstlisting}
 weighted variance of columns, corrected for degrees of freedom (bessel)
 variance of the weighted sample mean of samples with same mean (but not necessarily same variance)
 s^2 = sum (w^2(x-sum(wx)^2))

 s2_mu : error of mean, s2_mu : sd of prediction

\end{lstlisting}
\section{lib/mathematics/statistics}
\subsection{nangeomean}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{nangeostd}
${}$
\begin{lstlisting}
 geometric standard deviation ignoring nan-values

\end{lstlisting}
\section{lib/mathematics/statistics/nonparametric-statistics}
\subsection{kernel1d}
${}$
\begin{lstlisting}
 X   : ouput x axis bins
 xi  : samples along x
 m   : number of bins in X
 fun : kernel function
 pdf : propability density of xi

\end{lstlisting}
\subsection{kernel2d}
${}$
\begin{lstlisting}
 kernel density estimate in two dimensions

\end{lstlisting}
\section{lib/mathematics/statistics}
\subsection{normmoment}
${}$
\begin{lstlisting}
 expected norm of x.^n, when values x in x are iid normal with mu and sigma

\end{lstlisting}
\subsection{normpdf2}
${}$
\begin{lstlisting}
 pdf of the bivariate normal distribution

\end{lstlisting}
\section{lib/mathematics/statistics/order-statistics}
\subsection{hodges\_lehmann\_location}
${}$
\begin{lstlisting}
 hodges lehman location estimator

 Asymptotic rms efficency of location estimte:
      mean:          1 s/sqrt(n)
      hodges lehman: sqrt(pi/3)*s ~ 1.0233 s/sqrt(n)
      median:        pi/2 s/sqrt(n) ~ 1.25 s / sqrt(n)

\end{lstlisting}
\subsection{kendall}
${}$
\begin{lstlisting}
 kendall correlation coefficient

\end{lstlisting}
\subsection{kendall\_to\_pearson}
${}$
\begin{lstlisting}
 convert kendall rank correlation coefficient to the person product moment
 correlation coefficient

 c.f. Kruska, 1985

\end{lstlisting}
\subsection{mad2sd}
${}$
\begin{lstlisting}
 transform median absolute deviation to standard deviation
 for normal distributed values

\end{lstlisting}
\subsection{madcorr}
${}$
\begin{lstlisting}
 proxy correlation by median absolute deviation

\end{lstlisting}
\subsection{median2\_holder}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{median\_ci}
${}$
\begin{lstlisting}
 median and its confidence intervals under assumption of normality
 se_me = sqrt(1/2 pi) 1.25331 * sd/sqrt(n)

\end{lstlisting}
\subsection{median\_man}
${}$
\begin{lstlisting}
 median and confidence intervals
 c is a P value for the confidence interval,
 default is 0.95 (2-sigma)
 median of the colums of X

\end{lstlisting}
\subsection{mediani}
${}$
\begin{lstlisting}
 index of median, if median is not unique, any of the values is chosen

\end{lstlisting}
\subsection{nanmadcorr}
${}$
\begin{lstlisting}
 proxy correlation by median absolute deviation

\end{lstlisting}
\subsection{nanwmedian}
${}$
\begin{lstlisting}
 weighted median, skips nan-values

\end{lstlisting}
\subsection{nanwquantile}
${}$
\begin{lstlisting}
 weighted quantile, skips nan values 

\end{lstlisting}
\subsection{oja\_median}
${}$
\begin{lstlisting}
 two dimensional oja median
 note: the multivariate median is not unique

 oja 1983, for extension to multivariate function, see chaudhri

\end{lstlisting}
\subsection{qkurtosis}
${}$
\begin{lstlisting}
 kurosis computed for quantiles

 Note : this is a measurement of shape-tailedness and yields the same value for the
        normal distribution as "kurtosis"
        However, this is a separate statistic and hence requires different
        methods for calculating P-values and hypothesis testing

\end{lstlisting}
\subsection{qmoments}
${}$
\begin{lstlisting}
 moments estimated from quantiles

\end{lstlisting}
\subsection{qskew}
${}$
\begin{lstlisting}
 skewness estimated from quantiles

 Note : this is a measurement of shape-symmetry and yields the same value for the
        skew-normal distribution as "skewness"
        However, this is an own statistic and hence requires different
        methods for calculating P-values and hypothesis testing

\end{lstlisting}
\subsection{qskewq}
${}$
\begin{lstlisting}
 skewness estimated by quantiles

\end{lstlisting}
\subsection{qstdq}
${}$
\begin{lstlisting}
 proxy standard deviation determined by quantiles

\end{lstlisting}
\subsection{quantile1\_optimisation}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{quantile2\_breckling}
${}$
\begin{lstlisting}
 qunatile regression

\end{lstlisting}
\subsection{quantile2\_chaudhuri}
${}$
\begin{lstlisting}
 quantile regression

\end{lstlisting}
\subsection{quantile2\_projected}
${}$
\begin{lstlisting}
 quantile in two dimensions

\end{lstlisting}
\subsection{quantile2\_projected2}
${}$
\begin{lstlisting}
 spatial qunatile for chosen direction

\end{lstlisting}
\subsection{quantile\_envelope}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{quantile\_regression\_simple}
${}$
\begin{lstlisting}
 simple quantile regression

\end{lstlisting}
\subsection{ranking}
${}$
\begin{lstlisting}
 ranking for spearman statistics

\end{lstlisting}
\subsection{spatial\_median}
${}$
\begin{lstlisting}
 c.f. Oja 2008
 is this the same as the oja simplex median (c.f. small 1990)?

\end{lstlisting}
\subsection{spatial\_quantile}
${}$
\begin{lstlisting}
 spatial quantile

\end{lstlisting}
\subsection{spatial\_quantile2}
${}$
\begin{lstlisting}
 spatial quantile

\end{lstlisting}
\subsection{spatial\_quantile3}
${}$
\begin{lstlisting}
 spatial quantile

\end{lstlisting}
\subsection{spatial\_rank}
${}$
\begin{lstlisting}
 unsigned rank

\end{lstlisting}
\subsection{spatial\_sign}
${}$
\begin{lstlisting}
 spatial sign

\end{lstlisting}
\subsection{spatial\_signed\_rank}
${}$
\begin{lstlisting}
 signed rank
 Note: this is only a true rank if X is normal with zero mean, abitrary variance

\end{lstlisting}
\subsection{spearman}
${}$
\begin{lstlisting}
 spearman's product moment coefficient

\end{lstlisting}
\subsection{spearman\_rank}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{spearman\_to\_pearson}
${}$
\begin{lstlisting}
 conversion of spearman rank to person product moment correlation coefficient

\end{lstlisting}
\subsection{wmedian}
${}$
\begin{lstlisting}
 weighted median

\end{lstlisting}
\subsection{wquantile}
${}$
\begin{lstlisting}
 weighted quantile

\end{lstlisting}
\section{lib/mathematics/statistics}
\subsection{qstd}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{quantile\_extrap}
${}$
\begin{lstlisting}

\end{lstlisting}
\section{lib/mathematics/statistics/random-number-generation}
\subsection{laplacernd}
${}$
\begin{lstlisting}
 random number of laplace distribution

\end{lstlisting}
\subsection{randc}
${}$
\begin{lstlisting}
 correlate to correlated standard normally distributed vectors

\end{lstlisting}
\subsection{skewness2param}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{skewpdf\_central\_moments}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{skewrnd}
${}$
\begin{lstlisting}
 random numbers of the skew normal distribution

\end{lstlisting}
\subsection{skewrnd2}
${}$
\begin{lstlisting}
 random numbers of the skew normal distribution

\end{lstlisting}
\section{lib/mathematics/statistics}
\subsection{range}
${}$
\begin{lstlisting}
 mid range

\end{lstlisting}
\subsection{resample\_with\_replacement}
${}$
\begin{lstlisting}

\end{lstlisting}
\section{lib/mathematics/statistics/resampling-statistics/@Jackknife}
\subsection{Jackknife}
${}$
\begin{lstlisting}
 class for leave out 1 (delete 1) Jackknife estimates

 note 1 : the 1-delete jackknife does not yield consistend estimates for all functions,
        in particular it will perform poorly on robust estimation functions
        this is overcome by the d-delete jacknife, where d has to exceed the breakdown point
        of the estimating function, for example sqrt(n) for the median
        as this leads to unreasonably large number of repetitions, bootstrap
        is recommended for large sample cases (or blocking for sequential data)
 note 2 : as a linearisation, jackknife underestimates the error variance in case of 
          dependence in the data
 note 3 : studentisation and the leave out 1 jackknife are related
 note 4 : the double 1 sample jacknife performs iferior to the d1 jacknife

\end{lstlisting}
\subsection{estimated\_STATIC}
${}$
\begin{lstlisting}
 jacknife estimate of mean, bias and standard error
 theta0 : estimate from all samples
 thetad : set of estimates obtained by leaving out one data point each
          last dimension of theta is assumed to be the jackknife dimension

\end{lstlisting}
\subsection{matrix1\_STATIC}
${}$
\begin{lstlisting}
 matrix of estimation for leaving out two samples at a time

\end{lstlisting}
\subsection{matrix2}
${}$
\begin{lstlisting}
 matrix of estimations for jacknive with two samples left out

\end{lstlisting}
\section{lib/mathematics/statistics/resampling-statistics}
\subsection{block\_jackknife}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{jackknife\_moments}
${}$
\begin{lstlisting}
 moments determined by the jacknife

 func : function of interest on the samples (e.g. mean)
 A    : parameter matrix
        columns : parameters
        rows    : samples of the parameter sets
 d   : number of samples left out

\end{lstlisting}
\subsection{moving\_block\_jackknife}
${}$
\begin{lstlisting}

 blocked Jacknfife for autocorrelated data
 sliding block, statistically more efficient but computationally expensive
 note, number of blocks must be sufficiently large h ~ sqrt(n)? << n

\end{lstlisting}
\subsection{randblockserr}
${}$
\begin{lstlisting}
 standard error of sequentilly correlated data by blocking
 block length should be sufficiently larger than correlation length
 and sufficiently smaller than data length
 this uses a sliding block approach, which reduces the variation of the error estimate
 TODO this does not work, randomly picking samples does not reveal the correlation

\end{lstlisting}
\subsection{resample}
${}$
\begin{lstlisting}
 resample a vector and apply function to it

 TODO, should be with replacement

 n  : number of samples
 m  : number of subsamples
 cx : maximum number of combinations

\end{lstlisting}
\section{lib/mathematics/statistics}
\subsection{scale\_quantile\_sd}
${}$
\begin{lstlisting}
 scale factor for the standard deviation
 of the asymtpotic distibution of sample quantiles
 (for normal distribution)
 see cadwell, 1952

\end{lstlisting}
\subsection{sd\_sample\_quantiles}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{skewpdf}
${}$
\begin{lstlisting}
 skew-normal distribution
 c.f. Azzalini 1985

\end{lstlisting}
\subsection{trimmed\_mean}
${}$
\begin{lstlisting}
 trimmed mean

\end{lstlisting}
\subsection{ttest2\_man}
${}$
\begin{lstlisting}
 two-sample t-test
 here posix return value standard: h = 0 accepted, h = 1 failed
 note: the matlab logic is inverse : h = 1 accepted, h = 0 failed
 two sided univariate t-test

\end{lstlisting}
\subsection{ttest\_man}
${}$
\begin{lstlisting}
 two-sample t-test
 unequal sample size
 equal variance

\end{lstlisting}
\subsection{ttest\_paired}
${}$
\begin{lstlisting}
 paired t-test
 unequal sample size
 equal variance
 more powerfull than unpaired test, as long as correlation between x1 and x2 > 0

\end{lstlisting}
\subsection{wgeomean}
${}$
\begin{lstlisting}
 weighted geometric mean
 function mu = wgeomean(w,x)

\end{lstlisting}
\subsection{wgeovar}
${}$
\begin{lstlisting}
 variance of the weighted geometric mean

\end{lstlisting}
\subsection{wharmean}
${}$
\begin{lstlisting}
 weighted harmonic mean

\end{lstlisting}
\subsection{wharstd}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{wharvar}
${}$
\begin{lstlisting}

\end{lstlisting}
\section{lib/mathematics}
\begin{lstlisting}
mathematical functions of various kind

\end{lstlisting}
\subsection{ternary\_diagram}
${}$
\begin{lstlisting}

\end{lstlisting}
\section{lib/mathematics/test/master}
\subsection{dat\_test\_lanczos\_3d\_k\_20\_n\_40}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{poisson2d\_blk}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{qr\_implicit\_givens\_2}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{spectral\_derivative\_2d}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{test\_2d\_eigensolver\_hydrogen}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{test\_2d\_refine}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{test\_3d\_eigensolver\_hydrogen}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{test\_FEM}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{test\_Mesh\_3d}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{test\_arnoldi}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{test\_arpackc}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{test\_assemble}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{test\_assembly\_performance}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{test\_bc\_one\_sided}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{test\_compare\_solvers}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{test\_complete}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{test\_convergence}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{test\_convergence\_b}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{test\_df\_2d}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{test\_eig\_algs}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{test\_eig\_inverse}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{test\_eigs\_lanczos}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{test\_eigs\_lanczos\_1}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{test\_eigs\_lanczos\_2}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{test\_eigs\_lanczos\_performance}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{test\_fdm}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{test\_fdm\_d\_vargrid}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{test\_fdm\_spectral}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{test\_fem}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{test\_fem\_1d}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{test\_fem\_1d\_higher\_order}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{test\_fem\_2d\_adaptive}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{test\_fem\_2d\_higher\_order}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{test\_fem\_3d\_higher\_order}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{test\_fem\_3d\_refine}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{test\_fem\_b}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{test\_fem\_derivative}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{test\_fem\_quadrature}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{test\_final}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{test\_fix\_substitution}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{test\_forward}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{test\_get\_sparse\_arrays}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{test\_harmonic\_oscillator}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{test\_high\_order\_fdm\_periodic\_bc}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{test\_hydrogen\_wf}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{test\_ichol}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{test\_interpolation}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{test\_inverse\_problem}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{test\_it\_vs\_exact}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{test\_jama}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{test\_jd}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{test\_jdqz}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{test\_lanczos\_2}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{test\_lanczos\_biorthogonal}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{test\_laplacian}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{test\_laplacian\_non\_uniform}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{test\_laplacian\_simple}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{test\_mesh\_2d\_uniform}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{test\_mesh\_2d\_uniform\_2}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{test\_mesh\_circle}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{test\_mesh\_generation}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{test\_mesh\_interpolate}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{test\_mg}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{test\_minres\_recycle}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{test\_multigrid}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{test\_nc}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{test\_nonuniform\_symmetric}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{test\_pde}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{test\_permutation}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{test\_poison\_fem}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{test\_polar}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{test\_potential}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{test\_powers}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{test\_precondition}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{test\_project\_rectangle}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{test\_qr}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{test\_quantum\_well}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{test\_radial\_adaptive}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{test\_radial\_confinement}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{test\_radial\_fixes}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{test\_refine\_2d}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{test\_refine\_2d\_b}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{test\_refine\_3d}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{test\_refine\_structural}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{test\_regularisation}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{test\_round\_off}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{test\_schrödinger\_potentials}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{test\_uniform\_mesh}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{test\_vargrid}
${}$
\begin{lstlisting}

\end{lstlisting}
\section{lib/mathematics/test}
\subsection{test\_gaussfit3}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{test\_mtimes3x3}
${}$
\begin{lstlisting}

\end{lstlisting}
\section{lib/mathematics/wavelet}
\subsection{contiuous\_wavelet\_transform}
${}$
\begin{lstlisting}
 continuous wavelet transform 
 follows "The Illustrated Wavelet Transform Handbook: Introductory Theory and ..."

\end{lstlisting}
\subsection{cwt\_man}
${}$
\begin{lstlisting}
 continuous fourier transform
 as of time of implmentation, the matlab interal cwt is affected by
 serious round-off errors and has issues with the scaling,
 which is not the case here

\end{lstlisting}
\subsection{example\_wavelets}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{phasewrap}
${}$
\begin{lstlisting}
 wrap the phase to +/- pi

\end{lstlisting}
\subsection{test\_cwt\_man}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{test\_phasewrap}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{test\_wavelet}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{test\_wavelet2}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{test\_wavelet\_analysis}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{test\_wavelet\_reconstruct}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{test\_wtc}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{wavelet}
${}$
\begin{lstlisting}
 wavelet windows

\end{lstlisting}
\subsection{wavelet\_reconstruct}
${}$
\begin{lstlisting}
 iverses wavelet transform for single frequency
 (reconstruction of time series)
 n : window lengths in multiples of filter period 1/f0

\end{lstlisting}
\subsection{wavelet\_transform}
${}$
\begin{lstlisting}
 wavelet transform for single frequency
 n : window lengths in multiples of filter period 1/f0

\end{lstlisting}
\section{lib/mathematics}
\begin{lstlisting}
mathematical functions of various kind

\end{lstlisting}
\subsection{wrapphase}
${}$
\begin{lstlisting}

\end{lstlisting}
\section{lib/mesh/@StructuredMesh}
\subsection{StructuredMesh}
${}$
\begin{lstlisting}
 structured mesh processing
 compatible with Delft3D
 also provides set-up of discretisation matrices

\end{lstlisting}
\subsection{apply\_boundary\_condition}
${}$
\begin{lstlisting}
 apply boundary condition and the four sides of the domain
 TODO: allow for interior boudaries

\end{lstlisting}
\subsection{bc\_from\_shp}
${}$
\begin{lstlisting}
 read boundary condition from shape file

\end{lstlisting}
\subsection{bc\_index}
${}$
\begin{lstlisting}
 TODO this is deprecated
 generate indices for boundary edges

\end{lstlisting}
\subsection{bc\_isinvalid}
${}$
\begin{lstlisting}
 check boundary conditions for stacked domains

\end{lstlisting}
\subsection{block}
${}$
\begin{lstlisting}
 stack multiple meshes to complex domain

\end{lstlisting}
\subsection{boundary\_chain}
${}$
\begin{lstlisting}
 return chain of boundary points

\end{lstlisting}
\subsection{boundary\_direction}
${}$
\begin{lstlisting}
 return direction of boundary segment

\end{lstlisting}
\subsection{boundary\_indices}
${}$
\begin{lstlisting}
 indices of boundary segments
 id : index of boundary point
 jd : index of 

\end{lstlisting}
\subsection{cat}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{centreline}
${}$
\begin{lstlisting}
 domain (channel) centreline along chosen dimension

\end{lstlisting}
\subsection{child}
${}$
\begin{lstlisting}
 hierarchical mesh generation (for bifurcations)

\end{lstlisting}
\subsection{copy}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{corner\_indices}
${}$
\begin{lstlisting}
 indices of domain corners

\end{lstlisting}
\subsection{cut\_from\_domain}
${}$
\begin{lstlisting}
 cut subdomain

\end{lstlisting}
\subsection{export\_delft3d\_bnd}
${}$
\begin{lstlisting}
 export the boundary in delft3d compatible format 

\end{lstlisting}
\subsection{export\_delft3d\_dep}
${}$
\begin{lstlisting}
 export bathymetry data in Delft3D dep-format

\end{lstlisting}
\subsection{export\_delft3d\_grd}
${}$
\begin{lstlisting}
 export mesh in deltares delft3D grd file format

\end{lstlisting}
\subsection{export\_delft3d\_ini}
${}$
\begin{lstlisting}
 export delft3D compatible initial condition file

\end{lstlisting}
\subsection{export\_shp}
${}$
\begin{lstlisting}
 export mesh elements as shape file

\end{lstlisting}
\subsection{extend\_straight\_reach}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{extract\_elements}
${}$
\begin{lstlisting}
 element indices from grid

\end{lstlisting}
\subsection{flip\_dimension}
${}$
\begin{lstlisting}
 flip left and right or top and down

\end{lstlisting}
\subsection{from\_1d\_mesh}
${}$
\begin{lstlisting}
 convert a 1D mesh to 2D mesh consisting of quadrilaterals

\end{lstlisting}
\subsection{generate\_bifurcation}
${}$
\begin{lstlisting}
 creates a mesh for bifurcation with bluff, which is required for delft3d grids
 TODO do not fix indices
 TODO determine p individually
 bank : bankline shapefile
 nn : number of points across branches
 ds: spacing along s
 p : fraction of right side branch
 level : generate hierarchical mesh,
	  grid points in each branch will be 2^n+1,
	  and sub meshes until level 1 will be generated

 for lower levels the connecting volumes remain narrow,
 as the two volumes left and right of the division line are not scaled
 -> post smoothing required

 nn: n=6; for idx=1:5; n(end+1)  = 2*(n(end)-3)+3, end
 ns: n=18; for idx=1:5; n(end+1) = 2*(n(end)-2)+2, end (should be improved to 2*(n-1)+1

\end{lstlisting}
\subsection{generate\_disk}
${}$
\begin{lstlisting}
 generate semicircular domain

\end{lstlisting}
\subsection{generate\_from\_centreline}
${}$
\begin{lstlisting}
 generate a mesh from a given centreline
 TODO : avoid crossing of inner bed points in sharp bends

\end{lstlisting}
\subsection{generate\_rectangle}
${}$
\begin{lstlisting}
 discretize a rectangular domain

\end{lstlisting}
\subsection{generate\_structured\_grid}
${}$
\begin{lstlisting}
 generate a structured mesh consisting of several sub-meshes

\end{lstlisting}
\subsection{grid\_block}
${}$
\begin{lstlisting}
 mesh a subdomain

\end{lstlisting}
\subsection{improve}
${}$
\begin{lstlisting}
 improve (smooth) the mesh

\end{lstlisting}
\subsection{interp\_elem2point}
${}$
\begin{lstlisting}
 interpolate values sampled at element centres to element corners
 TODO allow also interpolation to u and v points

\end{lstlisting}
\subsection{mesh\_polygon}
${}$
\begin{lstlisting}
 mesh a 1D channel, where boundaries are given as polygon
 TODO, this should better use voronoi-tesselation (see centreline class)

\end{lstlisting}
\subsection{orthogonality}
${}$
\begin{lstlisting}
 orthogonality of elements

\end{lstlisting}
\subsection{orthogonalize}
${}$
\begin{lstlisting}
 orthogonalize mesh
 set x of point coordinates to 1/2

\end{lstlisting}
\subsection{plot}
${}$
\begin{lstlisting}
 plot the mesh

\end{lstlisting}
\subsection{plot\_boundary}
${}$
\begin{lstlisting}
 plot the mesh boundary

\end{lstlisting}
\subsection{plot\_coupling}
${}$
\begin{lstlisting}
 plot connected vertices, see vertex_connection_matrix.m

\end{lstlisting}
\subsection{plot\_orthogonality}
${}$
\begin{lstlisting}
 plot mesh with edges colored by orthogonality condition

\end{lstlisting}
\subsection{quiver}
${}$
\begin{lstlisting}
 quiver plot of velocity

\end{lstlisting}
\subsection{read\_delft3d\_dep}
${}$
\begin{lstlisting}
 depth in dat file is defined at volume centres (water leve point)
 first row, first column and last column are buffer
 but nast colum is not (only when outflow?)

\end{lstlisting}
\subsection{read\_delft3d\_grd}
${}$
\begin{lstlisting}
 read mesh in delft3D grd format

\end{lstlisting}
\subsection{smooth\_cubic}
${}$
\begin{lstlisting}
 cubically smooth the mesh coordinates

\end{lstlisting}
\subsection{smooth\_curvilinear}
${}$
\begin{lstlisting}
 smooth the mesh
relax = (10+relax)/11;
relax = min(0.5,relax);

\end{lstlisting}
\subsection{smooth\_laplacian}
${}$
\begin{lstlisting}
 smooth the mesh coordinates

 better than before, but causes dn in inner bends to be narrower than in outer bends
 (straightens the lines)
 better smooth p: i.e. fractional distance from left to right,
 this is complicated at the bif
 better: two neighbour smooth: smooth dn and ds with left/right, top bottom only 

\end{lstlisting}
\subsection{smooth\_simple}
${}$
\begin{lstlisting}

 smooth the mesh coordinates

\end{lstlisting}
\subsection{smooth\_sn}
${}$
\begin{lstlisting}

 smooth the mesh coordinates


\end{lstlisting}
\subsection{snap}
${}$
\begin{lstlisting}
 snap two meshes that connect at their domain boundaries

\end{lstlisting}
\subsection{statistic}
${}$
\begin{lstlisting}
 compute mesh statistics

\end{lstlisting}
\subsection{to\_unstructured\_mesh}
${}$
\begin{lstlisting}
 convert to unstructured mesh

\end{lstlisting}
\subsection{transpose\_dimension}
${}$
\begin{lstlisting}
 transpose dimensions

\end{lstlisting}
\subsection{vertex\_connection\_matrix}
${}$
\begin{lstlisting}
 connectivity of neighbouring vertices
 TODO same for elements

\end{lstlisting}
\section{lib/mesh/@UnstructuredMesh}
\subsection{UnstructuredMesh}
${}$
\begin{lstlisting}
 class containing some meshing functionality
 complementary to Mesh_2d, Mesh_3d, Tree_2d and Tree_3d

\end{lstlisting}
\subsection{add\_element}
${}$
\begin{lstlisting}
 add an element with vertex indices, vertices already exist

\end{lstlisting}
\subsection{add\_vertex}
${}$
\begin{lstlisting}
 add a vertex

\end{lstlisting}
\subsection{angle}
${}$
\begin{lstlisting}
 interior angles of each element

\end{lstlisting}
\subsection{assign\_1d}
${}$
\begin{lstlisting}
 assign coordinatex (x0,y0) to containing element
 TODO this can fail, if triangulation is not delaunay

\end{lstlisting}
\subsection{assign\_2d}
${}$
\begin{lstlisting}
 assign coordinatex (x0,y0) to containing element

\end{lstlisting}
\subsection{assign\_3d}
${}$
\begin{lstlisting}
 assign coordinatex (P0,y0) to containing element

\end{lstlisting}
\subsection{bnd\_1d}
${}$
\begin{lstlisting}
 left and right end points for 1D meshes

\end{lstlisting}
\subsection{boundary\_1d}
${}$
\begin{lstlisting}
 convert 1D mesh to 2D mesh

\end{lstlisting}
\subsection{boundary\_chain2}
${}$
\begin{lstlisting}
 get chained indices of boundary segments,
 used for setting up higher order polynomials along the boundary

\end{lstlisting}
\subsection{boundary\_length\_and\_direction}
${}$
\begin{lstlisting}
 edge length and direction of boundary segments
 TODO, this should be just edge length and direction

\end{lstlisting}
\subsection{cat}
${}$
\begin{lstlisting}
 concatenate two meshes

\end{lstlisting}
\subsection{chain\_1d}
${}$
\begin{lstlisting}
 chain 1D elements (segments)

\end{lstlisting}
\subsection{check\_dublicate\_elements}
${}$
\begin{lstlisting}
 check if elements are duplicate elements
 TODO, this does not check if elements cover each other, for example
 hierarchical meshes or ABC+BCD and ABD+ACD
 TODO check overlap by computation of area

\end{lstlisting}
\subsection{check\_edge\_intersection}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{clip}
${}$
\begin{lstlisting}
 clip mesh to polygonal domain 
 TODO only works for triangles

\end{lstlisting}
\subsection{compute\_elem2elem}
${}$
\begin{lstlisting}
 set up element2element neighbourhood relation

\end{lstlisting}
\subsection{connect\_1d\_2d}
${}$
\begin{lstlisting}
 auto merge 1d and 2d mesh
 this silently requires that 1d segments consist at least of 3 elements
 TODO only implemented for triangles

\end{lstlisting}
\subsection{convert\_2d\_to\_1d}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{copy}
${}$
\begin{lstlisting}
 copy constructor

\end{lstlisting}
\subsection{cross\_section}
${}$
\begin{lstlisting}
 get cross-sections for 1D elements

\end{lstlisting}
\subsection{delete\_element}
${}$
\begin{lstlisting}
 delete an element

\end{lstlisting}
\subsection{derivative\_matrix\_1d}
${}$
\begin{lstlisting}
 first order first derivative discretisation matrix on the 1d mesh

\end{lstlisting}
\subsection{derivative\_matrix\_2d}
${}$
\begin{lstlisting}
 first order first derivative discretisation matrix on the mesh

\end{lstlisting}
\subsection{derivative\_matrix\_2d\_2}
${}$
\begin{lstlisting}
 second order derivative matrix on a triangulation

\end{lstlisting}
\subsection{derivative\_matrix\_3d}
${}$
\begin{lstlisting}
 first order first derivative discretisation matrix on the mesh

\end{lstlisting}
\subsection{distance}
${}$
\begin{lstlisting}
 distance along edges from a point set to all other points

 open      : id of start point(s)
 countflag : if set use number of hops as distance not the euclidean distance

\end{lstlisting}
\subsection{dual\_mesh}
${}$
\begin{lstlisting}
 dual mesh formed by the centre of cicumference
 the dual mesh consists not only of triangles
 TODO rename in generate dual mesh

\end{lstlisting}
\subsection{edge\_length}
${}$
\begin{lstlisting}
 euclidean edge length

\end{lstlisting}
\subsection{edge\_midpoint}
${}$
\begin{lstlisting}
 edge mid-points

\end{lstlisting}
\subsection{edges\_from\_elements}
${}$
\begin{lstlisting}
 edges and boundaries from elements

\end{lstlisting}
\subsection{eigs}
${}$
\begin{lstlisting}
 eigenvalues of the lapalcian on the mesh

\end{lstlisting}
\subsection{elem2edge\_}
${}$
\begin{lstlisting}
 pointer of element to edge

\end{lstlisting}
\subsection{elem2elem\_matrix}
${}$
\begin{lstlisting}
 matrix with neighbourhood relations for each element

\end{lstlisting}
\subsection{element\_area}
${}$
\begin{lstlisting}
 area of elements
 1d elements have zero area and are not processed

\end{lstlisting}
\subsection{element\_centroid}
${}$
\begin{lstlisting}
 centroids of lements

\end{lstlisting}
\subsection{element\_midpoint}
${}$
\begin{lstlisting}
 barymetric centre of elements

\end{lstlisting}
\subsection{elements\_from\_edges}
${}$
\begin{lstlisting}
 2D elements from edges

\end{lstlisting}
\subsection{eval2pval}
${}$
\begin{lstlisting}
 element (centroid) value to vertex value
 TODO, use dual mesh or triangulation

\end{lstlisting}
\subsection{export\_delft3d\_net}
${}$
\begin{lstlisting}
 export into DFLOWFM delft3d net.nc file

\end{lstlisting}
\subsection{export\_msh}
${}$
\begin{lstlisting}
 export mesh in GMSH msh format

\end{lstlisting}
\subsection{export\_pos}
${}$
\begin{lstlisting}
 export triangles and vertex values to gmsh pos-file format (x,y,z,val)
 intended for re-meshing with values representing local mesh size

\end{lstlisting}
\subsection{export\_shp}
${}$
\begin{lstlisting}
 export edges to GIS shapefile
 each element as separate polygon with one z-value

\end{lstlisting}
\subsection{facing\_element}
${}$
\begin{lstlisting}
 get triangle ndx that is opposit, e.g. "facing" the vertex vdx of triangle tdx

\end{lstlisting}
\subsection{filter\_neighbour}
${}$
\begin{lstlisting}
 apply a function on the values on connected vertices

\end{lstlisting}
\subsection{find\_encroached\_edges}
${}$
\begin{lstlisting}
 find encroached edges in a triangulation,
 i.e. edges for which on of the two facing point false into their enclosing
 circle

\end{lstlisting}
\subsection{flip}
${}$
\begin{lstlisting}
 flip edges between two triangles
	flip
	for each side
		if (connection between opposit points shorter than between edges, swap edge)
		this-> flip
		that-> flip
	end

\end{lstlisting}
\subsection{flip\_global}
${}$
\begin{lstlisting}
 recursively flip edges, i.e ABC+BCD -> ABD+ADC,
 when new edge (diagonal) is shorter
 TODO this is buggy, it cannot be always swapped, only if abcd is convex!

\end{lstlisting}
\subsection{flip\_quality}
${}$
\begin{lstlisting}
 flip edges, when mesh quality constraint improves

\end{lstlisting}
\subsection{gaussmat\_2d}
${}$
\begin{lstlisting}
 matrix for gauss integration on a triangulation

\end{lstlisting}
\subsection{generate\_chews\_first}
${}$
\begin{lstlisting}
 triangulate domain with chew's first algorithm

\end{lstlisting}
\subsection{generate\_from\_centreline\_1d}
${}$
\begin{lstlisting}
 generate a mesh from centreline

\end{lstlisting}
\subsection{generate\_from\_centreline\_2d}
${}$
\begin{lstlisting}
 generate mesh from centreline
 TODO allow number of segments to change

 sets up a simple quadrilateral mesh in S-N coordinates
 centreline (must be sorted in streamwise direction)
 input variables:
 cS : S (streamwise) coordinates of centreline
 cL : N (spanwise) coordinate of left bank
 cR : N (spanwise) coordinate of right bank
 input variables controlling ouptut resolution:
 S  : S coordinate of slices in S-direction (diff(S) is element width)
        must be sorted in s-direction
 n  : n number of points per cross section
        (n-1) is number of elements per cross section
 output variables:
 mesh.{X,Y,S,N} : point coordinates
 mesh.T         : point indices of elements (corners of the quadrilaterals)
 -> make it orthogonal to banks by using a spline along n

\end{lstlisting}
\subsection{generate\_frontal}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{generate\_ghost\_elements}
${}$
\begin{lstlisting}
 generate ghost elements, i.e. elements at the domain boundary, these 
 elements can overlap

 when the project flag set, ghost points are porjected to the boundary,
 the project flag is set for dual mesh generation
 the project flag is unset for application of the boundary condition

\end{lstlisting}
\subsection{generate\_gmsh}
${}$
\begin{lstlisting}
 generate a mesh from a polygon using gmsh

 inshp      : file name of shape file of preloaded shape file containing a polygon
 obase      : base of output file name
 resolution : struct containing default mesh resolution settings
 resfile_C  : file names of shape files, defining local resolution in polygonal regions
 opt        : options, see below

 this is a Static function

\end{lstlisting}
\subsection{generate\_hierarchical}
${}$
\begin{lstlisting}
 generate a hierachical mesh by recursively splitting elements
 containing boundary points

\end{lstlisting}
\subsection{generate\_triangle}
${}$
\begin{lstlisting}
 generate a mesh from a polygon using the programme "Triangle"

\end{lstlisting}
\subsection{generate\_uniform\_1d}
${}$
\begin{lstlisting}
 generate a uniformly spaced 1D mesh

\end{lstlisting}
\subsection{generate\_uniform\_quadrilateral}
${}$
\begin{lstlisting}
 generate a uniform 2D mesh

\end{lstlisting}
\subsection{generate\_uniform\_tetra}
${}$
\begin{lstlisting}
 uniformly tesselate a rhombic domain in 3D into tetrahedra

\end{lstlisting}
\subsection{generate\_uniform\_triangulation}
${}$
\begin{lstlisting}
 uniformly tesselate a rectangular (2d) domain into triangles

\end{lstlisting}
\subsection{get\_facing\_and\_shared\_vertices}
${}$
\begin{lstlisting}
 for a pairwise list (array) of triangles, determine there common and facing edges

\end{lstlisting}
\subsection{grid2tri}
${}$
\begin{lstlisting}
 topologically split a uniform mesh on a rectangular domain into triangles

\end{lstlisting}
\subsection{import\_delft3d\_net}
${}$
\begin{lstlisting}
 import mesh from Delft3d file ( {filanme}_net.nc )

\end{lstlisting}
\subsection{import\_msh}
${}$
\begin{lstlisting}
 import mesh from {filename}.msh files as generated by GSMH

\end{lstlisting}
\subsection{import\_triangle}
${}$
\begin{lstlisting}
 import a mesh generated with triangle (ele and node)

\end{lstlisting}
\subsection{improve\_iterative\_relocate\_insert}
${}$
\begin{lstlisting}
 iteratively improve the mesh by inserting vertices and smoothing
		fprintf('Iteration %d, %d elements, %d vertices, %d obtuse elements (%g%%)\n', iter, obj.nelem, obj.np, nobtuse, nobtuse./obj.nelem);

\end{lstlisting}
\subsection{improve\_iterative\_relocate\_uniform}
${}$
\begin{lstlisting}
 improve mesh by smoothing following by uniform refinement
		fprintf('Iteration %d, %d elements, %d vertices, %d obtuse elements (%g%%)\n', iter, obj.nelem, obj.np, nobtuse, nobtuse./obj.nelem);

\end{lstlisting}
\subsection{improve\_relocate\_global1}
${}$
\begin{lstlisting}
 iteratively improve angles to remove obtuse triangles

\end{lstlisting}
\subsection{improve\_relocate\_global2}
${}$
\begin{lstlisting}
 improve mesh globally

\end{lstlisting}
\subsection{improve\_relocate\_global\_3}
${}$
\begin{lstlisting}
 improve mesh quality globally

\end{lstlisting}
\subsection{improve\_relocate\_local}
${}$
\begin{lstlisting}
 iteratively improve angles to remove obtuse triangles

\end{lstlisting}
\subsection{improve\_relocate\_local\_old}
${}$
\begin{lstlisting}
 iteratively improve angles to remove obtuse triangles

\end{lstlisting}
\subsection{improve\_topology}
${}$
\begin{lstlisting}
 improve mesh topology

\end{lstlisting}
\subsection{insert\_mid\_points}
${}$
\begin{lstlisting}
 insert mid points into the mesh
 the new mesh is of much lower quality, but if all edges are flipped,
 this leads to the sqrt(2) refinement

\end{lstlisting}
\subsection{insert\_steiner\_points}
${}$
\begin{lstlisting}
 refine mesh by inserting steiner points (centre of circumference)
 for elements specified by tdx

\end{lstlisting}
\subsection{integrate\_1d}
${}$
\begin{lstlisting}
 integrate a quantity val across the mesh

\end{lstlisting}
\subsection{integrate\_discharge}
${}$
\begin{lstlisting}
 integrate discharge

\end{lstlisting}
\subsection{interp\_1d}
${}$
\begin{lstlisting}
 interpolate on a 1D mesh

\end{lstlisting}
\subsection{interp\_2d}
${}$
\begin{lstlisting}
 interpolate on a 2D mesh

\end{lstlisting}
\subsection{interp\_fourier}
${}$
\begin{lstlisting}
 interpolate values on the mesh using fourier methods

\end{lstlisting}
\subsection{interp\_tikhonov\_1d}
${}$
\begin{lstlisting}
 interpolation with Tikhonov regularisation

\end{lstlisting}
\subsection{interp\_tikhonov\_2d}
${}$
\begin{lstlisting}
 interpolation wiht Tikhonov regularisation in 2D

\end{lstlisting}
\subsection{interp\_tikhonov\_3d}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{interpolate\_from\_boundary}
${}$
\begin{lstlisting}
 interpolate interior values from the boundary

\end{lstlisting}
\subsection{interpolate\_point}
${}$
\begin{lstlisting}
 interpolate from samples to mesh points by IDW method

\end{lstlisting}
\subsection{interpolation\_error\_1d}
${}$
\begin{lstlisting}
 estimate interpolation error in 1D

\end{lstlisting}
\subsection{interpolation\_error\_2d}
${}$
\begin{lstlisting}
 interpolate error in 2D

\end{lstlisting}
\subsection{interpolation\_error\_3d}
${}$
\begin{lstlisting}
 estimate interpolation error in 3D

\end{lstlisting}
\subsection{interpolation\_matrix\_1d}
${}$
\begin{lstlisting}
 linear interpolation matrix from mesh points to arbitrary coordinates P0

\end{lstlisting}
\subsection{interpolation\_matrix\_2d}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{interpolation\_matrix\_3d}
${}$
\begin{lstlisting}
 interpolation matrix for interpolation in 3D

\end{lstlisting}
\subsection{isacute}
${}$
\begin{lstlisting}
 determine acute triangles

\end{lstlisting}
\subsection{isobtuse}
${}$
\begin{lstlisting}
 determine obtuse triangles

\end{lstlisting}
\subsection{iterate\_smooth2}
${}$
\begin{lstlisting}
 iteratively improve the mesh by smoothing

\end{lstlisting}
\subsection{limit\_by\_distance}
${}$
\begin{lstlisting}
 max edge length
 minimum distance
 TODO, this will always be zero

\end{lstlisting}
\subsection{make\_elements\_ccw}
${}$
\begin{lstlisting}
 make all 2D elements clock wise (such that their area is positive)

\end{lstlisting}
\subsection{merge\_duplicate\_points}
${}$
\begin{lstlisting}
 merge duplicate points

\end{lstlisting}
\subsection{merge\_facing\_blunt\_triangles}
${}$
\begin{lstlisting}
 merge blunt triangles that face each other

\end{lstlisting}
\subsection{mesh1}
${}$
\begin{lstlisting}
 mesh in 1D

\end{lstlisting}
\subsection{mesh\_1d}
${}$
\begin{lstlisting}
 extract the 1d mesh

\end{lstlisting}
\subsection{mesh\_2d}
${}$
\begin{lstlisting}
 extract the 1d mesh

\end{lstlisting}
\subsection{mesh\_junctions}
${}$
\begin{lstlisting}
 mesh junctions of a channel network
		hold on

\end{lstlisting}
\subsection{nearest\_boundary}
${}$
\begin{lstlisting}
 determine nearest boundary segment for each input coordindate

\end{lstlisting}
\subsection{nedge\_}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{nonobtuse\_refinement}
${}$
\begin{lstlisting}
 nonobtuse refinement according to Korotov
 not feasible for most obtuse triangles

\end{lstlisting}
\subsection{objective\_A}
${}$
\begin{lstlisting}
 one objective function value per angle

\end{lstlisting}
\subsection{objective\_T}
${}$
\begin{lstlisting}
 wrapper for mesh optimisation objective functions univariate in triangles

\end{lstlisting}
\subsection{objective\_angle}
${}$
\begin{lstlisting}
 objective function for iterative angle improvement

\end{lstlisting}
\subsection{optimum\_angle}
${}$
\begin{lstlisting}
 optimum angle for each vertex = 360^\deg / number of connected edges

\end{lstlisting}
\subsection{orthogonality\_quadrilaterals}
${}$
\begin{lstlisting}
 orthogonality condition for quadrilaterals

\end{lstlisting}
\subsection{path}
${}$
\begin{lstlisting}
 path along edges

\end{lstlisting}
\subsection{plot}
${}$
\begin{lstlisting}
 plot the mesh (and a discretised function) as a surface and net

\end{lstlisting}
\subsection{plot1d}
${}$
\begin{lstlisting}
 plot 1D mesh

\end{lstlisting}
\subsection{plot3}
${}$
\begin{lstlisting}
 plot mesh and values

\end{lstlisting}
\subsection{plotcs}
${}$
\begin{lstlisting}
 plot cross section

\end{lstlisting}
\subsection{project\_to\_boundary}
${}$
\begin{lstlisting}
 project a point to the boundary

\end{lstlisting}
\subsection{pval2eval}
${}$
\begin{lstlisting}
 vertex to element value

\end{lstlisting}
\subsection{quad2tri}
${}$
\begin{lstlisting}
 quadrilaterals to triangles

\end{lstlisting}
\subsection{raster\_boundary}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{recover\_edges}
${}$
\begin{lstlisting}
 recover (boundary) edges

\end{lstlisting}
\subsection{refine}
${}$
\begin{lstlisting}
 refine by splitting marked triangles

\end{lstlisting}
\subsection{refine\_edge\_halving}
${}$
\begin{lstlisting}
 mesh refinement by longest edge bisection

\end{lstlisting}
\subsection{remove\_empty\_triangles}
${}$
\begin{lstlisting}
 remove degenerated triangles with zero area

\end{lstlisting}
\subsection{remove\_isolated\_vertices}
${}$
\begin{lstlisting}
 remove points that are not part of the mesh
 (gmsh leaves sometimes spurious points in the msh file)

\end{lstlisting}
\subsection{remove\_points}
${}$
\begin{lstlisting}
 remove points and associated elements

\end{lstlisting}
\subsection{remove\_quartered\_triangles}
${}$
\begin{lstlisting}
 point has connectivity 4 and is not on the boundary

\end{lstlisting}
\subsection{remove\_small\_islands}
${}$
\begin{lstlisting}
 delft3D requires islands to have at least 7 edges
 this functions splits edges surrounding small islands

\end{lstlisting}
\subsection{remove\_triply\_connected\_boundary\_vertices}
${}$
\begin{lstlisting}
 remove boundary vertices that are connected only to three vertices

\end{lstlisting}
\subsection{remove\_trisected\_triangles}
${}$
\begin{lstlisting}
 remove trisected trianges
 point has connectivity 3 and is not on the boundary

\end{lstlisting}
\subsection{renumber\_point\_indices}
${}$
\begin{lstlisting}
 renumber vertex indices

\end{lstlisting}
\subsection{resolve\_8\_vertices}
${}$
\begin{lstlisting}
 improve mesh by removing one edge from vertices with 8-edges
 (an interior vertex in a regular triangulation has 6 neighbours,
  and unstructured meshes with local refinement are possible with
  5 and 7 neighbours, 4,3, or 8 and more connected vertices are not necessary

\end{lstlisting}
\subsection{restore\_acuteness}
${}$
\begin{lstlisting}
 restore acuteness
 Laplacian smoothing may at some places decrease the mesh quality,
 this locally restores acute elements

\end{lstlisting}
\subsection{retriangulate}
${}$
\begin{lstlisting}
 retriangulate the mesh

\end{lstlisting}
\subsection{ruppert}
${}$
\begin{lstlisting}
 refine the mesh using ruppert's algorithm

\end{lstlisting}
\subsection{scale\_to\_boundary}
${}$
\begin{lstlisting}
 scale hierarchical mesh to match boundary coordinates
 experimental

\end{lstlisting}
\subsection{scatterplot}
${}$
\begin{lstlisting}
 scatterplot of data on mesh

\end{lstlisting}
\subsection{section}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{segment}
${}$
\begin{lstlisting}
 segment the mesh into parts according to laplacian eigenvalues

\end{lstlisting}
\subsection{smooth2}
${}$
\begin{lstlisting}
 Laplacian smoothing of vertex coordinates,
 replace every point by the average coordinate of its neibghbours

\end{lstlisting}
\subsection{smooth\_1d}
${}$
\begin{lstlisting}
 smoothes values in each reach
 does not smooth the values at the connection points

\end{lstlisting}
\subsection{smooth\_val}
${}$
\begin{lstlisting}
 smooth values on the mesh
 TODO allow for smooting boundary only along boundary

\end{lstlisting}
\subsection{smoothness}
${}$
\begin{lstlisting}
 mesh smoothness as ratio of maximum edge length and minimum edge length

\end{lstlisting}
\subsection{split3}
${}$
\begin{lstlisting}
 split those triangles that contain a boundary point in three pieces,
 for hierrachical mesh generation

\end{lstlisting}
\subsection{split\_edge}
${}$
\begin{lstlisting}
 split an edge

\end{lstlisting}
\subsection{split\_edge\_perpendicular}
${}$
\begin{lstlisting}
 split edge perpendicularly

\end{lstlisting}
\subsection{split\_elem\_1d}
${}$
\begin{lstlisting}
 split a 1d element

\end{lstlisting}
\subsection{split\_encroached\_edges}
${}$
\begin{lstlisting}
 recursively split encroached edges

\end{lstlisting}
\subsection{split\_obtuse}
${}$
\begin{lstlisting}
 split obtuse elements

\end{lstlisting}
\subsection{split\_unsmooth\_edges}
${}$
\begin{lstlisting}
 split unsmooth edges

\end{lstlisting}
\subsection{statistics}
${}$
\begin{lstlisting}
 compute mesh statistics

\end{lstlisting}
\subsection{streamwise\_derivative\_matrix}
${}$
\begin{lstlisting}
 streamwise derivative matrix

\end{lstlisting}
\subsection{thalweg}
${}$
\begin{lstlisting}
 thalweg (deepest point along channel)

\end{lstlisting}
\subsection{to\_single}
${}$
\begin{lstlisting}
 TODO, also with indices

\end{lstlisting}
\subsection{uncross\_elements}
${}$
\begin{lstlisting}
 make sure, that 4 point elements span an area, and do not form a cross
 a call to this function should be succeeded by make_ccw
 this operator is idempotent

\end{lstlisting}
\subsection{uncross\_quadrilaterals}
${}$
\begin{lstlisting}
 make sure, that 4 point elements span an area, and do not form a cross
 a call to this function should be succeeded by make_ccw
 this operator is idempotent

\end{lstlisting}
\subsection{vertex\_distance}
${}$
\begin{lstlisting}
 connectivity of directly connected vertices

\end{lstlisting}
\subsection{vertex\_to\_edge}
${}$
\begin{lstlisting}
 connectivity matrix between vertices and adjacent edges

\end{lstlisting}
\subsection{vertex\_to\_element}
${}$
\begin{lstlisting}
 connectivity matrix between vertices and elements

\end{lstlisting}
\subsection{vertex\_to\_vertex}
${}$
\begin{lstlisting}
 connectivity matrix between vertices

\end{lstlisting}
\subsection{vertices\_1d}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{weighed\_laplacian\_smoothing}
${}$
\begin{lstlisting}
 weighed Laplacian smoothing

\end{lstlisting}
\subsection{xy2xys}
${}$
\begin{lstlisting}
 for boundary points: convert XY coordinate into a 1Dparametric coordinate,
 applied in mesh optimization, where movement of boundary points is
 constrained on the boundary

\end{lstlisting}
\subsection{xys2xy}
${}$
\begin{lstlisting}
 convert parametric 1D coordinate of boundary point back to cartesian XYc oordinate 

\end{lstlisting}
\section{lib/mesh/grid/@Grid1}
\subsection{Grid1}
${}$
\begin{lstlisting}
 lump spatiotemporal data into a 1-dimensional grid

\end{lstlisting}
\subsection{binop}
${}$
\begin{lstlisting}
 operate function fun on data val within the context of a grid cell
 (for fitting grid cell values from sampled values)

\end{lstlisting}
\subsection{build\_index}
${}$
\begin{lstlisting}

 compute the grid-cell index for samples sampled at points X1

 name : name of the index field
 X1 : coordinate of source points
 R  : cut off radius (if not supplied ident to mesh width)

\end{lstlisting}
\subsection{fit}
${}$
\begin{lstlisting}
 lump (fit) sampled values into the corresponding grid cell

\end{lstlisting}
\subsection{predict}
${}$
\begin{lstlisting}
 interpolate from lumped data to specified location

\end{lstlisting}
\section{lib/mesh/grid/@Grid2}
\subsection{Grid2}
${}$
\begin{lstlisting}
 lump spatiotemporal data into a 2-dimensional grid

\end{lstlisting}
\subsection{binop}
${}$
\begin{lstlisting}
 operate function fun on data val within the context of a grid cell
 (for fitting grid cell values from sampled values)

\end{lstlisting}
\subsection{build\_index}
${}$
\begin{lstlisting}

 compute the grid-cell index for samples sampled at points X1
 X1 : coordinate along first dimension
 X2 : coordinate along second dimension


\end{lstlisting}
\subsection{plot}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{predict}
${}$
\begin{lstlisting}
 interpolate from lumped data to specified location

\end{lstlisting}
\section{lib/mesh/grid/@Grid3}
\subsection{Grid3}
${}$
\begin{lstlisting}
 lump spatiotemporal data into a 3-dimensional grid

\end{lstlisting}
\subsection{build\_index}
${}$
\begin{lstlisting}
 compute the grid-cell index for samples sampled at points X1
 X1 : coordinate along first dimension
 X2 : coordinate along second dimension
 X3 : coordinate along third dimension

\end{lstlisting}
\section{lib/mesh/mesh1d}
\subsection{dxspace}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{dxspace2}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{dzmesh}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{mesh1}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{mesh1d}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{nlogstep}
${}$
\begin{lstlisting}

\end{lstlisting}
\section{lib/mesh/optimization}
\subsection{improve\_smooth\_insert}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{objective0\_angle1\_barycentric}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{objective0\_angle2\_barycentric}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{objective0\_angle2\_barycentric9}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{objective0\_angle\_2\_cartesian}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{objective0\_angle\_inf\_cartesian}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{objective0\_barycentric9}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{objective0\_pythagoras1\_barycentric9}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{objective0\_pythagoras1\_cartesian}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{objective0\_pythagoras2\_barycentric9}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{objective0\_pythagoras2\_cartesian}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{objective\_3\_angle}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{objective\_A\_bnd}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{objective\_P\_angle}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{objective\_P\_angle\_scaled}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{objective\_P\_angle\_scaled\_area}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{objective\_P\_midpoint}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{objective\_angle}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{objective\_angle2\_barycentric}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{objective\_angle\_p}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{objective\_angle\_scaled\_area}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{objective\_angle\_scaled\_circumference}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{objective\_cosa}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{objective\_cosa\_p}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{objective\_cosa\_scaled\_side\_length}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{objective\_distance\_edge\_centre}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{objective\_distance\_edge\_centre\_perpendicular}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{objective\_distance\_orthocentre\_excentre}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{objective\_incentre\_excentre}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{objective\_length\_min\_max}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{objective\_length\_var}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{objective\_thales}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{objective\_thales\_difference}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{test\_objective\_cosa\_p}
${}$
\begin{lstlisting}

\end{lstlisting}
\section{lib/mesh}
\begin{lstlisting}
mesh generation, manipulation, analysis, refinement and optimization


\end{lstlisting}
\subsection{preload\_msh}
${}$
\begin{lstlisting}

\end{lstlisting}
\section{lib/mesh/sparsemesh/@SparseMesh1}
\subsection{SparseMesh1}
${}$
\begin{lstlisting}
 lump time series of sampled spatial data in one dimension (projected)

\end{lstlisting}
\subsection{assign}
${}$
\begin{lstlisting}
 assign (lump) data "v0" sampled at sample times/location to field "field"


\end{lstlisting}
\subsection{assignS}
${}$
\begin{lstlisting}
 lump sequentially sampled data "v0" and assign to field "field"
 

\end{lstlisting}
\subsection{init}
${}$
\begin{lstlisting}
 initialize, segment sampling locations/times into blocks the sampled
 data is lumped to

\end{lstlisting}
\subsection{interp}
${}$
\begin{lstlisting}
 interpolate data stored in field "field" to coordinates Xi
 ingnore invalid data
 TODO, check if convex

\end{lstlisting}
\subsection{interpS}
${}$
\begin{lstlisting}
 interpolate data stored in field "field" to coordinates Xi,
 do not ignore invalid data

\end{lstlisting}
\subsection{rmse\_interp}
${}$
\begin{lstlisting}
 interpolation part of the error : 
 e ~ 1/2*d^2v/dx^2 * dx^2 + higher order terms
   ~ 1/2*d^2 v
 the other part of the error is the sampling error (gaussian noise)
 
 the mesh is optimal, when e_nois ~ e_interp


\end{lstlisting}
\section{lib/mesh/sparsemesh/@SparseMesh2}
\subsection{SparseMesh2}
${}$
\begin{lstlisting}
 lump time series of sampled spatial data (track recordings) along two dimensions,
 e.g 1 projected spatial dimension and one for time time
 TODO : better blocks (all neighbours within mahalanobis distance)
 TODO : do not use simple mean, but allow for least squares regression
 TODO : precompute the least squares weights for accummarray

\end{lstlisting}
\subsection{assign}
${}$
\begin{lstlisting}
 assign (lump) data "v0" sampled at sample times/location to field "field"

\end{lstlisting}
\subsection{assignS}
${}$
\begin{lstlisting}
 lump sequentially sampled data "v0" and assign to field "field"

\end{lstlisting}
\subsection{init}
${}$
\begin{lstlisting}
 initialize, segment sampling locations/times into blocks the sampled
 data is lumped to

\end{lstlisting}
\subsection{interp}
${}$
\begin{lstlisting}
 interpolate data stored in field "field" to coordinates Xi
 ingnore data outside of the domain (convex interpolation)

\end{lstlisting}
\subsection{interpS}
${}$
\begin{lstlisting}
 interpolate data stored in field "field" to coordinates Xi,
 extrapolate beyond domain

\end{lstlisting}
\subsection{rmse\_interp}
${}$
\begin{lstlisting}
 interpolation part of the error : 
 e ~ 1/2*d^2v/dx^2 * dx^2 + higher order terms
   ~ 1/2*d^2 v
 the other part of the error is the sampling error (gaussian noise)
 
 the mesh is optimal, when e_nois ~ e_interp

 TODO this is e ~ f', not f''

\end{lstlisting}
\section{lib/mesh/sparsemesh}
\begin{lstlisting}
lumping and interpolation of spatio-temporal data into a "mesh" that is spaced
optimally for the local density of sample points

allows for processing of large data sets with lower memory consumption and run time

intended for ADCP data processing

Overcomes the limitation of gridding, where some grid cells can have an insufficient
number of samples


\end{lstlisting}
\subsection{SparseMesh}
${}$
\begin{lstlisting}
 SparseMesh superclass

\end{lstlisting}
\section{lib/mesh/test}
\subsection{test\_MMesh\_segment}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{test\_derivative\_matrices\_curvilinear}
${}$
\begin{lstlisting}

\end{lstlisting}
\section{lib/mesh}
\begin{lstlisting}
mesh generation, manipulation, analysis, refinement and optimization


\end{lstlisting}
\subsection{test\_nxfun}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{trimesh\_fast}
${}$
\begin{lstlisting}

\end{lstlisting}
\section{lib/open-channel-flow/@Backwater1D}
\subsection{Backwater1D}
${}$
\begin{lstlisting}
 solve the gradually varied flow equation (backwater equation)
 in one dimension

 c.f. Chow, Bresse

\end{lstlisting}
\subsection{backwater\_approximation}
${}$
\begin{lstlisting}
 approximation of the backwater curve by an exponential function
 note: this is not necessarily a good approximation
 in the case of tide, Qt can be given

\end{lstlisting}
\subsection{backwater\_curve\_iterative}
${}$
\begin{lstlisting}

 analytic solution of the gradually varied flow equation
 c.f. Bresse, Chow

\end{lstlisting}
\subsection{backwater\_length}
${}$
\begin{lstlisting}
 backwater length

\end{lstlisting}
\subsection{dh\_dx}
${}$
\begin{lstlisting}
 change of depth along channel for the backwater equation
 beta : momentum coefficient
 this is effectively an equation in h^3

\end{lstlisting}
\subsection{dh\_dx\_}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{dzs\_dx}
${}$
\begin{lstlisting}
 change of surface elevation along channel

\end{lstlisting}
\subsection{gvf\_x\_chow}
${}$
\begin{lstlisting}
 analytical solution to the gradually varied flow equation (backwater equation)
 c.f. Chow, Bresse

\end{lstlisting}
\subsection{invert}
${}$
\begin{lstlisting}
 determine bed level from surface elevation
 (inverse backwater equation)
 this is ill conditioned, as the surface is smooth for subcritical flow,
 even if the bed is not smoth 

 C : chezy
 W : width
 Q : discharge
 S : bed slope
 y0 : surface elevation at outflow
 lateral inflow

\end{lstlisting}
\subsection{solve}
${}$
\begin{lstlisting}
 solve the gradually varied flow equation (backwater equation)
 C : chezy
 W : width
 Q : discharge
 S : bed slope
 y0 : surface elevation at outflow

\end{lstlisting}
\subsection{solve\_analytic}
${}$
\begin{lstlisting}
 analytical solution to the gradually varied flow equation (bresse method)
u_.^(n-m)./(1-u_.^n)

\end{lstlisting}
\subsection{solve\_matrix}
${}$
\begin{lstlisting}

\end{lstlisting}
\section{lib/open-channel-flow/bifurcations-and-weirs/@Lateral\_Diversion\_Finite\_Width}
\subsection{Jb}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{Lateral\_Diversion\_Finite\_Width}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{dR}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{derive}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{evalk}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{lateral\_outflow\_finite\_width1}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{load\_functions}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{stagnation\_point}
${}$
\begin{lstlisting}
	fdx    = isnan(x);

\end{lstlisting}
\subsection{streamline}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{streamline\_radius\_of\_curvature}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{u\_far}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{v\_far}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{velocity}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{velocity\_near\_bed}
${}$
\begin{lstlisting}

\end{lstlisting}
\section{lib/open-channel-flow/bifurcations-and-weirs/@Lateral\_Diversion\_Finite\_Width\_Gradual}
\subsection{Jb}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{Lateral\_Diversion\_Finite\_Width\_Gradual}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{coefficients}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{condA}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{dR}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{derive}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{evalk}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{evalk\_}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{lateral\_outflow\_finite\_width1}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{load\_functions}
${}$
\begin{lstlisting}

\end{lstlisting}
\section{lib/open-channel-flow/bifurcations-and-weirs/@Lateral\_Diversion\_Finite\_Width\_Gradual/old}
\subsection{coefficients\_old}
${}$
\begin{lstlisting}

\end{lstlisting}
\section{lib/open-channel-flow/bifurcations-and-weirs/@Lateral\_Diversion\_Finite\_Width\_Gradual}
\subsection{stagnation\_point}
${}$
\begin{lstlisting}
	fdx    = isnan(x);

\end{lstlisting}
\subsection{streamline}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{streamline\_radius\_of\_curvature}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{u\_far}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{uv1}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{uv\_side\_branch}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{v\_far}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{velocity}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{velocity\_linear}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{velocity\_near\_bed}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{xp}
${}$
\begin{lstlisting}

\end{lstlisting}
\section{lib/open-channel-flow/bifurcations-and-weirs/@Lateral\_Diversion\_Wide\_Channel}
\subsection{Lateral\_Diversion\_Wide\_Channel}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{derive\_lateral\_outflow}
${}$
\begin{lstlisting}
 derive potential flow solution to lateral outlfow from an infinitely
 wide main channel

\end{lstlisting}
\subsection{derive\_lateral\_outflow\_finite\_width}
${}$
\begin{lstlisting}

 derive coefficients for lateral outflow in the case of potential flow


\end{lstlisting}
\subsection{lateral\_outflow}
${}$
\begin{lstlisting}
 potential flow solution to the case of lateral outflow from an infinitely
 wide channel

\end{lstlisting}
\subsection{lateral\_outflow\_finite\_width}
${}$
\begin{lstlisting}

 analytical potential flow solution to lateral outflow from an infinitely
 wide channel

\end{lstlisting}
\section{lib/open-channel-flow/bifurcations-and-weirs/@Lateral\_Diversion\_Wide\_Channel\_Map}
\subsection{Lateral\_Diversion\_Wide\_Channel\_Map}
${}$
\begin{lstlisting}

 wrapper to store precomputed streamlines of potential flows


\end{lstlisting}
\subsection{streamline}
${}$
\begin{lstlisting}

\end{lstlisting}
\section{lib/open-channel-flow/bifurcations-and-weirs/@Side\_Weir}
\subsection{Side\_Weir}
${}$
\begin{lstlisting}
 side weir, analytical solution to (critical) lateral outflow

\end{lstlisting}
\subsection{dzs\_dx}
${}$
\begin{lstlisting}
 side weir, along channel surface gradient

\end{lstlisting}
\subsection{surface\_elevation}
${}$
\begin{lstlisting}
 along-channel surface elevation for (critical) lateral outflow over a side-weir

\end{lstlisting}
\section{lib/open-channel-flow/bifurcations-and-weirs}
\subsection{Lateral\_Diversion\_Finite\_Width\_Map}
${}$
\begin{lstlisting}

\end{lstlisting}
\section{lib/open-channel-flow}
\begin{lstlisting}
functions for open channel flow, sub modules:

@Backwater1D
	gradually varied flow in 1D (backwater)
@Potential_Flow
	depth averaged potential flow, numerical solution
@Potential_Flow_Analytic
	depth averaged potential flow, analytical solution
rating-curve
	empirical rating curves
@Side_Weir
	analytical solution to lateral outflow over a side weir
@SWE
	dynamical solution of the shallow water equation (saint-venant-equation)
	in 1D
@SWE_2d
	dynamical solution of the shallow water equation (saint-venant-equation)
	in 2D
velocity-profile
	vertical and transverse velocity profiles of the streamwise velocity


\end{lstlisting}
\subsection{hfilter}
${}$
\begin{lstlisting}

\end{lstlisting}
\section{lib/open-channel-flow/kinematik-and-diffusion-wave}
\subsection{diffusion\_wave}
${}$
\begin{lstlisting}
 propagation of a diffusion wave (flood wave), c.f. ponce
 advection
 diffusion
 where is the bed slope?
 friction slope
 eddy slope
 chow 1988
 d(A+A0)/dt + dQ/dx = q
 dQ/dt + d/dx betaQ^2/A + gA(dh/dx + Sf + Se) - beta q_i v_i + Wf B = 0
 A0 ignored
 inflow and wind shear ignored

\end{lstlisting}
\subsection{flood\_wave\_diffusion\_coefficient}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{linear\_wave}
${}$
\begin{lstlisting}
 linear wave routing (linearised kinematic wave)

\end{lstlisting}
\section{lib/open-channel-flow/meander-bend/@Equilibrium\_Bend}
\subsection{Equilibrium\_Bend}
${}$
\begin{lstlisting}
 Transverse profile of the bed level and bed material grain size in
 an equilibrium (infintely long) meander bend

\end{lstlisting}
\subsection{bed\_profile}
${}$
\begin{lstlisting}
 predict transverse bed profile of an equilibrium meander bend

\end{lstlisting}
\subsection{bed\_profile\_uniform}
${}$
\begin{lstlisting}
 transverse profile of the bed level of an equilibrium meander bend
 with uniform grain size

\end{lstlisting}
\subsection{calibrate}
${}$
\begin{lstlisting}
 calibrate bend geometry to given profile

\end{lstlisting}
\subsection{dD\_dr}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{dh\_dr}
${}$
\begin{lstlisting}
 across channel derivative of flow depth for a meandering river

\end{lstlisting}
\subsection{dh\_dr\_uniform}
${}$
\begin{lstlisting}
 transverse gradient of the bed level of an equilibrium meander bend
 for the case of uniform bed material

\end{lstlisting}
\subsection{grain\_size\_profile}
${}$
\begin{lstlisting}
 transverse (across channel) profile of the bed material grain size
 in a river meander

\end{lstlisting}
\section{lib/open-channel-flow/meander-bend}
\subsection{Kinoshita}
${}$
\begin{lstlisting}
% Public properties
% Public get properties
% Private properties
% Constructor
% Setters and getters
% generic methods

\end{lstlisting}
\subsection{bend\_transverse\_velocity}
${}$
\begin{lstlisting}
 transverse velocity profile in a meander bend

\end{lstlisting}
\subsection{bend\_velocity\_near\_bed}
${}$
\begin{lstlisting}
 near-bed-velocity in a meander bend

\end{lstlisting}
\subsection{kinoshita\_}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{random\_meander}
${}$
\begin{lstlisting}
 generate a pseudo random meander

\end{lstlisting}
\subsection{test\_rozovskii}
${}$
\begin{lstlisting}

\end{lstlisting}
\section{lib/open-channel-flow/potential-flow/@Potential\_Flow}
\subsection{Potential\_Flow}
${}$
\begin{lstlisting}
 numerical solution of the potential flow on a curvilinear grid
 (not necessarilly curvilinear)

\end{lstlisting}
\subsection{apply\_boundary\_potential\_old}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{assemble\_discretization\_matrix\_rectilinear}
${}$
\begin{lstlisting}
 assemble the discretisation matrix

\end{lstlisting}
\subsection{assemble\_potential\_matrix}
${}$
\begin{lstlisting}
 assemble the discretisation matrix for potential flow

\end{lstlisting}
\subsection{bc\_dirichlet}
${}$
\begin{lstlisting}
 apply Dirichlet boundary conditions

\end{lstlisting}
\subsection{boundary\_condition\_side\_outflow}
${}$
\begin{lstlisting}
 apply boundary conditions for side outflow
 p*phi + (1-p)*d/db phi = rhs
 y : along channel coordinate

\end{lstlisting}
\subsection{boundary\_condition\_side\_outflow\_1}
${}$
\begin{lstlisting}
 apply boundary conditions
 p*phi + (1-p)*d/db phi = rhs


\end{lstlisting}
\subsection{contour}
${}$
\begin{lstlisting}
 contour plot of the potential flow solution

\end{lstlisting}
\subsection{cut\_boundary}
${}$
\begin{lstlisting}
 cut the boundary from the domain
 wa : width of inlet to side channel
 wb : width of side channel

\end{lstlisting}
\subsection{cut\_rectangle}
${}$
\begin{lstlisting}
 cut a rectangle from the domain
 TODO, this requires also an adaptation of the derivative matrices
       -> step over to semi-unstructured mesh

\end{lstlisting}
\subsection{infer\_bed\_level}
${}$
\begin{lstlisting}
 note: this is pretty much a broken function for the inference of stationary
       morphology

 Missing:
 - rolling down of transverse slope to balance secondary flow in bends
 - quasi time steippong

 at stationary state:
 - changes of discharge along the streamlines of discharge are balanced
   by a change in depth, to keep the velocity and sediment transport constant along the streamline

 dz_b/dt = dqs/dx + dqs/dn = 0                    (i)
 TODO this only true for infinite bends, as sediment can also move to the side
 dqs/ds  = d/s(q/h) = 1/h dq/ds - q/h^2 dh/ds = 0
 TODO this is only true in an ifinite bend (ikeda)
 dqs/dn = 0
 streamlines along discharge or velocity -> does not matter eq (i) is direction independent

\end{lstlisting}
\subsection{infer\_bed\_level2}
${}$
\begin{lstlisting}
 infer the bed level

\end{lstlisting}
\subsection{infer\_bed\_level3}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{infer\_bed\_level\_loop}
${}$
\begin{lstlisting}
 the bed level does not completely converge but starts to oscillate,
 this is presumably due to the non-compact kernel implementation of the laplacian oberator

\end{lstlisting}
\subsection{objective\_bed\_level}
${}$
\begin{lstlisting}
 objective function for determining the bed level

\end{lstlisting}
\subsection{old}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{plot}
${}$
\begin{lstlisting}
 surface plot

\end{lstlisting}
\subsection{quiver}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{sediment\_transport}
${}$
\begin{lstlisting}
 compute the sediment transport

\end{lstlisting}
\subsection{solve\_potential}
${}$
\begin{lstlisting}
 solve for the flow potential

\end{lstlisting}
\subsection{streamline}
${}$
\begin{lstlisting}
 compute a streamline

\end{lstlisting}
\subsection{surface\_elevation}
${}$
\begin{lstlisting}
 compute surface elevation according to Bernoulli's law

\end{lstlisting}
\subsection{test}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{velocity\_near\_bed}
${}$
\begin{lstlisting}

 determine the velocity near the bed

\end{lstlisting}
\subsection{vertical\_velocity}
${}$
\begin{lstlisting}
 determine the vertical velocity from continuity

\end{lstlisting}
\section{lib/open-channel-flow/potential-flow/@Potential\_Flow\_Analytic}
\subsection{Potential\_Flow\_Analytic}
${}$
\begin{lstlisting}
 analytical solutions to various depth-averaged potential flow problems


\end{lstlisting}
\subsection{streamline}
${}$
\begin{lstlisting}
 numerically follow path along streamline by integrating the velocity

\end{lstlisting}
\section{lib/open-channel-flow/rating-curve}
\subsection{ChezyRatingCurve}
${}$
\begin{lstlisting}
 rating curve, Chezy formalism

\end{lstlisting}
\subsection{DynamicKeuleganRC}
${}$
\begin{lstlisting}
 Dynamic Rating Curve, Keulegan roughness formulation
 (dynamic = correction for hysteresis loop)

\end{lstlisting}
\subsection{DynamicManningRC}
${}$
\begin{lstlisting}
 Dynamic Rating Curve, Manning roughness formulation
 (dynamic = correction for hysteresis loop)

\end{lstlisting}
\subsection{DynamicPowerRC}
${}$
\begin{lstlisting}
 Dynamic Power Law Rating curve
 (dynamic = correction for hysteresis loop)

\end{lstlisting}
\subsection{KeuleganRatingCurve}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{ManningRatingCurve}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{PolyRatingCurve}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{PowerRatingCurve}
${}$
\begin{lstlisting}
 stationary rating curve, power law

\end{lstlisting}
\subsection{PowerRatingCurveOffset}
${}$
\begin{lstlisting}
 stationary rating curve, stage-discharge follows power law

\end{lstlisting}
\subsection{RatingCurve}
${}$
\begin{lstlisting}
 Fri Feb 13 10:02:52 CET 2015
 rating curve superclass

\end{lstlisting}
\subsection{csarea}
${}$
\begin{lstlisting}
 predict cross sectional area from transverse bed level profile
 and surface elevation

\end{lstlisting}
\subsection{csdischarge}
${}$
\begin{lstlisting}
 compute discharge

\end{lstlisting}
\subsection{csperimeter}
${}$
\begin{lstlisting}
 compute wetted perimeter

\end{lstlisting}
\subsection{csradius}
${}$
\begin{lstlisting}
 compute hydraulic radius of the cross section

\end{lstlisting}
\subsection{cswidth}
${}$
\begin{lstlisting}
 determine cross section width


\end{lstlisting}
\subsection{test\_PowerRatingCurve}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{wfunc}
${}$
\begin{lstlisting}
 determine channel width

\end{lstlisting}
\section{lib/open-channel-flow/shallow-water/@SWE}
\subsection{SWE}
${}$
\begin{lstlisting}
 Class to solve the (cross sectionally averaged) shallow water equation
 (st venant equation)

\end{lstlisting}
\subsection{bc\_incoming\_non\_reflecting}
${}$
\begin{lstlisting}
 set non-reflecting boundary condition for the 1D SWE

\end{lstlisting}
\subsection{bc\_inflow}
${}$
\begin{lstlisting}
 inflow boundary condition

\end{lstlisting}
\subsection{bc\_inflow\_low\_pass}
${}$
\begin{lstlisting}
 set low frequency Dirichlet, high frequency pass boundary condition

\end{lstlisting}
\subsection{bc\_inflow\_non\_reflecting}
${}$
\begin{lstlisting}
 set non-reflecting boundary condition

\end{lstlisting}
\subsection{bc\_level}
${}$
\begin{lstlisting}
 set surface level as Dirichlet boundary condition

\end{lstlisting}
\subsection{bc\_level\_sommerfeld}
${}$
\begin{lstlisting}
 set surface level as boundary condition by sommerfeld method

\end{lstlisting}
\subsection{bc\_nonreflecting}
${}$
\begin{lstlisting}
 set non-reflecting boundary condition
 extrapolate 0-order

\end{lstlisting}
\subsection{bc\_reflecting}
${}$
\begin{lstlisting}
 set reflecting boundary condition
 extrapolate 0-order and invert v

\end{lstlisting}
\subsection{dot}
${}$
\begin{lstlisting}
 time derivative
 (only for matlab internal ode-solver)
 TODO this is not swe specific
 continuity
 dA/dt + dQ/dx = I
 
 momentum
 dQ/dt + d/dx( Qu + 1/2 gh^2) = gA(S_f - S_b)
 S_b = dz_b/dx
 S_f = tau_x/rho_w = C_f u|u|

\end{lstlisting}
\subsection{dt\_cfl}
${}$
\begin{lstlisting}
 determine time step required by cfl

\end{lstlisting}
\subsection{energy}
${}$
\begin{lstlisting}
 determine total energy as sump of potential and kinetic energy
 this is preserved for fricitionless flows

\end{lstlisting}
\subsection{flux}
${}$
\begin{lstlisting}
 st venant's shallow water equation fluw

\end{lstlisting}
\subsection{flux\_lin}
${}$
\begin{lstlisting}
 linearised st-venant equation

\end{lstlisting}
\subsection{fluxmateig}
${}$
\begin{lstlisting}
 eigenvalues und vectors of the swe

\end{lstlisting}
\subsection{jacobian}
${}$
\begin{lstlisting}
 Jacobian of the SWE

 dq/dt + J dq/dx = sourceterm
 note: d/dx(A*q) = J dq/dx

\end{lstlisting}
\subsection{lindot}
${}$
\begin{lstlisting}
 linearised SWE
 width variation not included, goes into rhs force term

 [      0,  1] [A]    = [    Q]
 [ -u^2+gH, 2u] [Q]_dx   [Q^2/A+1/2gA^2/w]_dx - 1/2gA^2/w^2 dw/dx
                                               force term


\end{lstlisting}
\subsection{roe\_average}
${}$
\begin{lstlisting}
 roe average for the SWE

\end{lstlisting}
\subsection{solve\_analytic}
${}$
\begin{lstlisting}
 linearised analytic solution of the swe

\end{lstlisting}
\subsection{solve\_stationary}
${}$
\begin{lstlisting}
 stationary solution to the SWE

\end{lstlisting}
\subsection{source\_bed\_level}
${}$
\begin{lstlisting}
 source term of the SWE caused by a change of the bed level

 Note: this term causes splitting and averaging methods to fail to
       give accurate predictions of the smooth surface at steps of the bed

\end{lstlisting}
\subsection{source\_friction}
${}$
\begin{lstlisting}
 friction source term of the SWE

\end{lstlisting}
\subsection{source\_width}
${}$
\begin{lstlisting}
 source term (reaction term) for channels with variable width

\end{lstlisting}
\subsection{swe\_geometry}
${}$
\begin{lstlisting}
 predefined functions to set up channel geometry

\end{lstlisting}
\subsection{swe\_ic}
${}$
\begin{lstlisting}
 predefined functions of channel geometries

\end{lstlisting}
\section{lib/open-channel-flow/shallow-water/@SWE\_2d}
\subsection{SWE\_2d}
${}$
\begin{lstlisting}
 Dynamic solution of the shallow water equation (depth average, 2D)

\end{lstlisting}
\subsection{apply\_boundary\_condition\_stationary}
${}$
\begin{lstlisting}
 apply boundary condition for stationary flow

\end{lstlisting}
\subsection{assemble\_stationary}
${}$
\begin{lstlisting}
 TODO, g should be replaced by gx,gy,gz, see chaudhri
 assemble discretisation matrix for stationary flow

\end{lstlisting}
\subsection{solve\_stationary}
${}$
\begin{lstlisting}
 solve SWE for statinary flow (dU/dt = dQ/dt = 0)

\end{lstlisting}
\section{lib/open-channel-flow/shallow-water}
\subsection{sw\_reflection}
${}$
\begin{lstlisting}
 reflection coefficients of shallow water waves at a sudden change of the
 cross section (sudden change of admittance)
 c.f. lighthill, ippen-harleman

\end{lstlisting}
\subsection{sw\_reflection\_stepwise}
${}$
\begin{lstlisting}
 time passes and phase shifts
 transmission and reflection coefficient depend on direction !
 iterative (recursive) reflection and transmission

\end{lstlisting}
\section{lib/open-channel-flow/test/test\_Backwater1D}
\subsection{test\_bw1d\_solve\_matrix}
${}$
\begin{lstlisting}

\end{lstlisting}
\section{lib/open-channel-flow/test}
\subsection{test\_inverse\_backwater\_curve}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{test\_normal\_flow}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{test\_nse\_nz}
${}$
\begin{lstlisting}

\end{lstlisting}
\section{lib/open-channel-flow/uniform-stationary-flow}
\subsection{chezy2drag}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{chezy2f}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{chezy2manning}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{chezy2z0}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{critical\_flow\_depth}
${}$
\begin{lstlisting}
 critical flow depth in uniform stationary flow

\end{lstlisting}
\subsection{drag2chezy}
${}$
\begin{lstlisting}
 convert drag coefficient to chezy coefficient
 g dz_s/dx + cd w u^2/h   = 0 (swe formalism)
      - S  +  1/C^2 U^2/H = 0 (chezy formalism)

\end{lstlisting}
\subsection{f2chezy}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{ks2z0}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{manning2chezy}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{manning2drag}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{manning2z0}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{normal\_flow\_depth}
${}$
\begin{lstlisting}
 normal flow depth for uniform stationary flow
 function H = normal_flow_depth(Q,W,C,S)

\end{lstlisting}
\subsection{normal\_flow\_depth\_}
${}$
\begin{lstlisting}
 normal flow depth in uniform stationary flow

\end{lstlisting}
\subsection{normal\_flow\_discharge}
${}$
\begin{lstlisting}
 normal flow discharge for uniform stationary flow

\end{lstlisting}
\subsection{normal\_flow\_slope}
${}$
\begin{lstlisting}
 energy slope (surface slope) for uniform stationary flow
 normal flow slope in uniform stationary flow

\end{lstlisting}
\subsection{normal\_flow\_velocity}
${}$
\begin{lstlisting}
 normal flow velocity in uniform stationary flow

\end{lstlisting}
\subsection{normal\_shear\_velocity}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{shear\_velocity}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{z02chezy}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{z02ks}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{z0tochezy}
${}$
\begin{lstlisting}

\end{lstlisting}
\section{lib/open-channel-flow/velocity-profile/@Log\_profile}
\subsection{Log\_profile}
${}$
\begin{lstlisting}
 logarithmic profile of the streamwise velocity

\end{lstlisting}
\subsection{df\_dh}
${}$
\begin{lstlisting}
 sensitivity of profile with respect to depth

\end{lstlisting}
\subsection{df\_dh\_}
${}$
\begin{lstlisting}
 sensitivity of profile with respect to depth

\end{lstlisting}
\subsection{df\_dln\_z0}
${}$
\begin{lstlisting}
 sensitivity of velocity profile with respect to roughness length

\end{lstlisting}
\subsection{df\_dln\_z0\_}
${}$
\begin{lstlisting}
 sensitivity of profile with respect to roughness length

\end{lstlisting}
\subsection{profile}
${}$
\begin{lstlisting}
 vertical profile of the streamwise velocity

\end{lstlisting}
\subsection{profile\_}
${}$
\begin{lstlisting}
 scale of velocity at instrument depth to depth average velocity
 roughness length and associated standard error can change in time,
 i.e. may be passed as vectors

 zs    : [1xn] water surface level
 zb    : [1x1] bottom level
 za    : [1xn] or [1x1]
         level of velocity measurement,
         i.e. level of HADCP beam bin centre, coincides with instrument level,
         if the HADCP is horizontally aligned
         only needs to be passed as vector if instrument is redeployed or
         becomes misaligned
 ln_z0 : [1xn] or [1x1]
         natural logarithm of the roughness length
 s     : [1xn] or [1x1]
         standard error of ln_z0
 function [fz_mu fz_s fz_sp fz_bias fz_eps] = log_profile(zs,zb,za,ln_z0,s,sp,e)

\end{lstlisting}
\subsection{profile\_bias}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{regmtx}
${}$
\begin{lstlisting}
 regression matrix

\end{lstlisting}
\subsection{ubar}
${}$
\begin{lstlisting}
 depth averaged velocity

\end{lstlisting}
\section{lib/open-channel-flow/velocity-profile/@Log\_profile\_with\_bend\_correction}
\subsection{Log\_profile\_with\_bend\_correction}
${}$
\begin{lstlisting}
 vertical velocity profile corrected for bend flow

\end{lstlisting}
\subsection{df\_dc}
${}$
\begin{lstlisting}
 sensitivity of the velocity profile with respect to the bend correction
 parameter c

\end{lstlisting}
\subsection{df\_dc\_}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{du\_dz}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{fit}
${}$
\begin{lstlisting}
 fit the vertical velocity profile

\end{lstlisting}
\subsection{profile\_}
${}$
\begin{lstlisting}
 vertical velocity profile

\end{lstlisting}
\subsection{regmtx}
${}$
\begin{lstlisting}
 regression matrix

\end{lstlisting}
\subsection{u}
${}$
\begin{lstlisting}
 streamwise velocity

\end{lstlisting}
\subsection{u\_}
${}$
\begin{lstlisting}
 streamwise velocity

\end{lstlisting}
\section{lib/open-channel-flow/velocity-profile/@Log\_profile\_with\_cubic\_wake}
\subsection{Log\_profile\_with\_cubic\_wake}
${}$
\begin{lstlisting}
 log profile with cubic wake

\end{lstlisting}
\subsection{df\_dc}
${}$
\begin{lstlisting}
 sensitivity of profile with respect to wave parameter

\end{lstlisting}
\subsection{df\_dc\_}
${}$
\begin{lstlisting}
 sensitivity of profile with respect to wake parameter

\end{lstlisting}
\subsection{profile\_}
${}$
\begin{lstlisting}
 vertical velocity profile

\end{lstlisting}
\subsection{regmtx}
${}$
\begin{lstlisting}
 regression matrix

\end{lstlisting}
\section{lib/open-channel-flow/velocity-profile/@Log\_profile\_with\_dip}
\subsection{Log\_profile\_with\_dip}
${}$
\begin{lstlisting}
 Logarithmic profile with dip

\end{lstlisting}
\subsection{fit}
${}$
\begin{lstlisting}
 fit the vertical velocity profile

\end{lstlisting}
\section{lib/open-channel-flow/velocity-profile/@Log\_profile\_with\_linear\_bend\_correction}
\subsection{Log\_profile\_with\_linear\_bend\_correction}
${}$
\begin{lstlisting}
 log profile with linear bend correction

\end{lstlisting}
\subsection{df\_dc}
${}$
\begin{lstlisting}
 sensitivity of profile with respect to wake parameter

\end{lstlisting}
\subsection{df\_dc\_}
${}$
\begin{lstlisting}
 sensitivity of velocity profile with respect to wave parameter

\end{lstlisting}
\subsection{du\_dz}
${}$
\begin{lstlisting}
 velocity shear along vertical

\end{lstlisting}
\subsection{profile\_}
${}$
\begin{lstlisting}
 velocity profile

\end{lstlisting}
\subsection{regmtx}
${}$
\begin{lstlisting}
 regression matrix

\end{lstlisting}
\section{lib/open-channel-flow/velocity-profile/@Log\_profile\_with\_wake}
\subsection{Log\_profile\_with\_wake}
${}$
\begin{lstlisting}
 logarithmic velocity profile with wake correction
 c.f. coles

\end{lstlisting}
\subsection{df\_dc}
${}$
\begin{lstlisting}
 sensitivity of profile with respect to wake parameter

\end{lstlisting}
\subsection{df\_dc\_}
${}$
\begin{lstlisting}
 sensitivity of velocity profile with respect to wake parameter

\end{lstlisting}
\subsection{du\_dz}
${}$
\begin{lstlisting}
 velocity shear

\end{lstlisting}
\subsection{profile\_}
${}$
\begin{lstlisting}
 predict velocity profile

\end{lstlisting}
\subsection{regmtx}
${}$
\begin{lstlisting}
 log law with wake
 u = us/k ln(z) - us/k ln(z0) + us/k (2/H^2 z  - 3/H^3 z^2)

\end{lstlisting}
\section{lib/open-channel-flow/velocity-profile/@VP}
\subsection{VP}
${}$
\begin{lstlisting}
 velocity profile

\end{lstlisting}
\subsection{process\_joint}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{process\_transverse\_profile}
${}$
\begin{lstlisting}
 process the transverse velocity profile

\end{lstlisting}
\subsection{process\_vertical\_profile}
${}$
\begin{lstlisting}
 predict vertical profile error distribution parameter for HADCP error estimate

\end{lstlisting}
\subsection{profile\_prediction\_error}
${}$
\begin{lstlisting}
 input :
 U     : [nbin x nens]
         - values for each bin (or across section) and ensemble (or reference measurement)
         this are estimates estimates of the discharge or the cross sectional averaged
         velocity from the raw values
         - the profile should be limited to the effective profiling range,
         abobj 75-100m for a 600kHz ADCP
      
 dn    : distance between HADCP bins
 width : cross section width

 objput:
       sd_n : expected standard deviation for increasing profiling range
function [s_rel s_err s_dat rho res m2 u_pred fdx] = velocity_variation(U)
 hadcp_prediction_error
 TODO take scales and unscaled velocity to do combine with harmmean estimate
 note: previus versions:
	residual was computed with respect to the predicted local velocity
	mse was not upscaled to cs, as profile was expected to cover entire cs
	finite width of cs was not considered
 parametric estimate from moments, objliers should be filtered beforehand
 Note that the median absolute deviation is not a good estimate,
 because it may excludes rare events like reverse flow of floods
 thus, the only acceptible more robust estimate would be mean absolute deviation

\end{lstlisting}
\section{lib/open-channel-flow/velocity-profile/@Vertical\_profile}
\subsection{Vertical\_profile}
${}$
\begin{lstlisting}
 vertical profile of the streamwise velocity, superclass

\end{lstlisting}
\subsection{fit}
${}$
\begin{lstlisting}
 fit vertical velocity profile parameter

 function obj = fit(obj,U,S,h,binmask)

\end{lstlisting}
\subsection{u}
${}$
\begin{lstlisting}
 predict velocity along the vertical based on profile

\end{lstlisting}
\section{lib/open-channel-flow/velocity-profile}
\subsection{fit\_displacement\_profile}
${}$
\begin{lstlisting}
 fit the log profile to the vertical profile of the streamwise velocity

\end{lstlisting}
\subsection{lateral\_division\_method}
${}$
\begin{lstlisting}
 transverse (across channel) profile of the streamwise velocity
 in a straight channel
 numerical solution
 the eps seems incorrect, use better stationary_1d_swe

 rho g h S - beta q^2 f / (8 h^2)   + d/dy(eps_t dq/dy) = 0
 rho g h S - beta q^2 g / (C^2 h^2) + d/dy(eps_t dq/dy) = 0

\end{lstlisting}
\subsection{test\_law\_of\_the\_wall\_fit}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{transverse\_profile\_parameter}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{transverse\_velocity\_profile}
${}$
\begin{lstlisting}
 transverse profile of the streamwise velocity
 c.f. shiono knight

\end{lstlisting}
\subsection{transverse\_velocity\_profile\_olesen}
${}$
\begin{lstlisting}
 transverse profile of the streamwise velocity in a meander bend

\end{lstlisting}
\subsection{transverse\_velocity\_profile\_rozovskii}
${}$
\begin{lstlisting}
 transversal velocity distribution in a bend
 Rososkii,
 as in the book central differences along the radius and euler forward in space
 are used, note that since the advent of the computer more advanced schemes
 could be used (see build in solvers)
 cfl condition is not explicitely checked
 Rosovsky assumes a constant water level, e.g. does not consider superelevation

 I_theta = -1/r dz/d_theta	(p. 22)
 d_theta = 1/R ds|_R
 => I_theta = -R/r dz/ds = -R/r I_0
 It : (1.32) drop of level per unit angle, identical across section

\end{lstlisting}
\subsection{transverse\_velocity\_profile\_shiono\_knight}
${}$
\begin{lstlisting}
 transverse profile of the streamwise velocity, determined analytically
 by the method of shiono and knight
 shape of velocity profile only dependent on lambda, f, H, not slope

\end{lstlisting}
\subsection{transverse\_velocity\_profile\_tidal\_channel}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{transverse\_velocity\_profile\_with\_slope}
${}$
\begin{lstlisting}
 stationary 1D shallow water equation across a river section
 0 = - g h S0 - tau_b/rho + d/dn (nu h du/dn)
 0 = - g h S0 + g u^2/C^2 + d/dn (nu h du/dn)
 includes tranvese gradient term
 
 note that shiono/knight 1991 provide an _analytic_ solution,
 which takes the form of an expontially decaying side wall effect


\end{lstlisting}
\subsection{vertical\_profile\_of\_velocity\_vriend}
${}$
\begin{lstlisting}
 vertical profile of the streamwise velocity, method of de vriend

\end{lstlisting}
\subsection{vertical\_velocity\_profile}
${}$
\begin{lstlisting}
 vertical profile of the streamwise velocity in non-uniform flow

\end{lstlisting}
\subsection{z2s\_rational}
${}$
\begin{lstlisting}

\end{lstlisting}
\section{lib/open-channel-flow/wrapper}
\subsection{discharge2stage}
${}$
\begin{lstlisting}
 wrapper function

\end{lstlisting}
\subsection{stage2discharge}
${}$
\begin{lstlisting}

\end{lstlisting}
\section{lib/physics/@Constant}
\subsection{Constant}
${}$
\begin{lstlisting}
 Constant and physical standard quantities

\end{lstlisting}
\subsection{celsius\_to\_kelvin}
${}$
\begin{lstlisting}
 convert temperature from degree Celsius to Kelvin
 function t_K = celsius_to_kelvin(t_C)

\end{lstlisting}
\subsection{depth\_to\_pressure}
${}$
\begin{lstlisting}
 convert depth to pressure in fresh water at standard temperature
 
    z = (p - p0)/(rho g)
 => p = rho g z + p0

 input :
 p0 : nx1 or scalar, pressure at water surface in BAR
 d  : depth in metre

 output :
 p  : nx1, pressure at measurement depth in BAR


\end{lstlisting}
\subsection{kelvin\_to\_celsius}
${}$
\begin{lstlisting}
 convert temperature degree Kelvin to Celsius

\end{lstlisting}
\subsection{optical\_attenuation}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{pressure\_to\_depth}
${}$
\begin{lstlisting}
 convert pressure to depth in fresh water at standard temperature
 
 z = (p - p0)/(rho*g)

 input:
 p  : nx1, pressure at measurement depth in BAR
 p0 : nx1 or scalar, pressure at water surface in BAR

 output:
 d  : depth in metre

\end{lstlisting}
\subsection{saturation\_vapor\_pressure}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{sound\_absorption\_air}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{sound\_absorption\_water}
${}$
\begin{lstlisting}
 sound absrobption in water
 following Francois and Garrison, 1982
 
 
 function alpha = sound_absorption(f,S,D,T)

 input:
 f : frequency (Hz)
 S : salinity
 D : depth (m)
 T : temperature (degree C)

 output:
 alpha = sound attenuation in dB/m (not dB/km)

 function alpha = sound_absorption(f,S,D,T,model)

\end{lstlisting}
\subsection{sound\_velocity\_water}
${}$
\begin{lstlisting}
 sound velocity in water
 following Lubbers and Graaff (1998)
 this formula does not include depth and salinity effects

\end{lstlisting}
\subsection{viscosity\_dynamic\_water}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{viscosity\_kinematic\_water}
${}$
\begin{lstlisting}

\end{lstlisting}
\section{lib/physics}
\subsection{beam\_bending\_deflection}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{beam\_bending\_moment}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{beam\_bending\_strain}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{beam\_bending\_stress}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{bolt\_stress}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{drag\_force}
${}$
\begin{lstlisting}

\end{lstlisting}
\section{lib/physics/hydrogen-spectrum}
\subsection{hydrogen\_spectrum\_1d}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{hydrogen\_spectrum\_2012\_12\_02}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{hydrogen\_spectrum\_2d}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{hydrogen\_spectrum\_3d}
${}$
\begin{lstlisting}

\end{lstlisting}
\section{lib/physics}
\subsection{minimum\_cable\_diameter}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{moment\_of\_inertia\_rectangle}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{moment\_of\_inertia\_ring}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{parabolic\_reflector\_gain}
${}$
\begin{lstlisting}

\end{lstlisting}
\section{lib/physics/salinity}
\subsection{Salinity}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{Salinity78}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{canter\_cremer\_number}
${}$
\begin{lstlisting}
 Canter Cremer Number
 ratio of fresh water to sea water that flows into the estuary
 Qf : fresh water discharge
 T  : tidal period
 Pt : tidal prism
 Savenije, Salinity and tides, eq. 1.1, 2.35 and 5.67

\end{lstlisting}
\subsection{density2salinity}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{dispersion\_hws\_savenije}
${}$
\begin{lstlisting}
 Dispersion at river mouth during high water slack 

 v0 : tidal velocity scale
 E0 : tidal excursion
 h0 : depth
 a  : convergence length
 Nr : Richargson Number

 Savenije 1993c, Savenije, Salinity and Tides, eg. 5.70

\end{lstlisting}
\subsection{dispersion\_tda\_burgh}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{richardson\_number}
${}$
\begin{lstlisting}
 Estuarine Richardson Number
 potential energy due to mixing the entire fresh water with sea water
 ratio of potential energy and buoyancy 
 Savenije, Salinity and Tides, 2.36
 drho : difference of sea water and fresh water density
 rho  : fresh water density
 h    : depth
 v    : tidal velocity scale
 N    : Cramer number

\end{lstlisting}
\subsection{salinity}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{salinity\_intrusion\_length}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{sea\_water\_density}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{tidal\_discharge}
${}$
\begin{lstlisting}
 specific tidal discharge (discharge per unit width)
 

\end{lstlisting}
\subsection{tidal\_excursion}
${}$
\begin{lstlisting}
 Tidal excursion length
 Pt : tidal prism
 h0 : depth
 w0 : width

\end{lstlisting}
\subsection{tidal\_prism\_channel}
${}$
\begin{lstlisting}
 Tidal prism
 Pt = int_lsw^hws Q_t dt ~ A E
 z1 : tidal amplitude
 w0 : width of estuary at mouth
 b  : length of width convergence
 dH_dx = rate of damping of H
 c.f. Savenije 2.34, 2.64

\end{lstlisting}
\subsection{tidal\_prism\_estuary}
${}$
\begin{lstlisting}
 Tidal prism
 Pt = int_lsw^hws Q_t dt ~ A E
 z1 : tidal amplitude
 w0 : width of estuary at mouth
 b  : length of width convergence
 dH_dx = rate of damping of H
 c.f. Savenije 2.34, 2.64

\end{lstlisting}
\subsection{tidal\_velocity}
${}$
\begin{lstlisting}

\end{lstlisting}
\section{lib/physics}
\subsection{test\_sound\_absorption\_air}
${}$
\begin{lstlisting}

\end{lstlisting}
\section{lib/physics/turbulence}
\subsection{keps2nu}
${}$
\begin{lstlisting}

\end{lstlisting}
\section{lib/physics/wind-wave}
\subsection{short\_wave\_length}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{short\_wave\_shear\_velocity}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{wave\_height\_from\_wind\_speed}
${}$
\begin{lstlisting}

\end{lstlisting}
\section{lib/sediment-transport/@GrainSizeDistribution}
\subsection{GrainSizeDistribution}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{assign\_channel}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{bimodality}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{export\_csv}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{export\_shp}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{group\_channels}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{group\_curvature}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{group\_histograms}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{load\_coordinates}
${}$
\begin{lstlisting}

\end{lstlisting}
\section{lib/sediment-transport/@Hermite\_profile}
\subsection{Hermite\_profile}
${}$
\begin{lstlisting}
 suspended sedimen profile in form of a hermite polynomial

\end{lstlisting}
\subsection{fit}
${}$
\begin{lstlisting}
 fit suspended sediment profile

\end{lstlisting}
\subsection{predict}
${}$
\begin{lstlisting}
 predict suspended sediment concentration

\end{lstlisting}
\subsection{regmtx}
${}$
\begin{lstlisting}
 regression matrix

\end{lstlisting}
\subsection{transform}
${}$
\begin{lstlisting}
 hermite profile

\end{lstlisting}
\section{lib/sediment-transport/@Nodal\_Point}
\subsection{Adot}
${}$
\begin{lstlisting}
 ODE of the nodal point relation (time-derivative of branch cs-area)

\end{lstlisting}
\subsection{Nodal\_Point}
${}$
\begin{lstlisting}
 Nodal point relation for bifurcations, according to Wang

\end{lstlisting}
\subsection{Qs\_in}
${}$
\begin{lstlisting}
 sediment entering branches

\end{lstlisting}
\subsection{Qs\_out}
${}$
\begin{lstlisting}
 sediment leaving branches

\end{lstlisting}
\subsection{derive\_jacobian}
${}$
\begin{lstlisting}
 derive Jacobian of the nodal point relation

\end{lstlisting}
\subsection{discharge}
${}$
\begin{lstlisting}
 discharge through branches

\end{lstlisting}
\subsection{geometry}
${}$
\begin{lstlisting}
 cross section geometry of branches

\end{lstlisting}
\subsection{jacobian}
${}$
\begin{lstlisting}
 jacobian of the nodal point relation
 semi-autogenerated

\end{lstlisting}
\subsection{phase\_diagram}
${}$
\begin{lstlisting}
 phase diagram

\end{lstlisting}
\subsection{phase\_diagram\_wang}
${}$
\begin{lstlisting}
 phase diagram of Nodal point relation

\end{lstlisting}
\subsection{solve}
${}$
\begin{lstlisting}
 solve the nodal point relation for critical points

\end{lstlisting}
\subsection{stability\_analysis}
${}$
\begin{lstlisting}
 staility analysis for a given configuration

\end{lstlisting}
\section{lib/sediment-transport/@Parabolic\_Constant\_Profile}
\subsection{Parabolic\_Constant\_Profile}
${}$
\begin{lstlisting}
 parabolic-constant profile

\end{lstlisting}
\subsection{fit}
${}$
\begin{lstlisting}
 fit the suspended sediment concentration profile

\end{lstlisting}
\subsection{predict}
${}$
\begin{lstlisting}
 predict suspended sediment concentration

\end{lstlisting}
\subsection{regmtx}
${}$
\begin{lstlisting}
 regression matrix

\end{lstlisting}
\subsection{transform}
${}$
\begin{lstlisting}
 transformation of vertical coordinate

\end{lstlisting}
\section{lib/sediment-transport/@Rouse\_Profile}
\subsection{Rouse\_Profile}
${}$
\begin{lstlisting}
 suspended sediment concentration profile

\end{lstlisting}
\subsection{fit}
${}$
\begin{lstlisting}
 fit the suspended sediment concentration profile

\end{lstlisting}
\subsection{mean\_concentration}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{predict}
${}$
\begin{lstlisting}
 predict the suspended sediment concentration

\end{lstlisting}
\subsection{regmtx}
${}$
\begin{lstlisting}
 regression matrix

\end{lstlisting}
\subsection{rouse\_number}
${}$
\begin{lstlisting}
 rouse number (suspension number) for given grain siye and shear velocity

\end{lstlisting}
\subsection{rouse\_number\_to\_grain\_diameter}
${}$
\begin{lstlisting}
 convert known rous number (suspension parameter) to grain size diameter

\end{lstlisting}
\subsection{set\_parameters}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{transform}
${}$
\begin{lstlisting}
 transform the vertical coordinate

\end{lstlisting}
\section{lib/sediment-transport}
\begin{lstlisting}
analysis and prediction of fluvial sediment transport and morphodynamics


\end{lstlisting}
\subsection{Exponential\_SSC\_Profile}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{adaptation\_length\_bed}
${}$
\begin{lstlisting}
 adaptatoion lenght of bed morphology

\end{lstlisting}
\subsection{adaptation\_length\_flow}
${}$
\begin{lstlisting}
 adaption length of the flow

\end{lstlisting}
\subsection{bar\_mode\_crosato}
${}$
\begin{lstlisting}
 bar mode of a river according to crosato

\end{lstlisting}
\subsection{bed\_layer\_thickness}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{bed\_load\_einstein}
${}$
\begin{lstlisting}
 bed load transport according to einstein jr.

\end{lstlisting}
\subsection{bed\_load\_engelund\_fredsoe}
${}$
\begin{lstlisting}
 bed load transport according to engelund and fredsoe

\end{lstlisting}
\subsection{bed\_load\_transport\_mpm}
${}$
\begin{lstlisting}
 bed load transport rate according to meyer-peter-mueller

\end{lstlisting}
\subsection{bed\_load\_transport\_rijn}
${}$
\begin{lstlisting}
 bed load transport
 method of van Rijn (1984)

 function [Q_b q_b Phi_b] = bed_load_transport_rijn(C,d50,d90,U,d,b)

 d50 [mm] (converted to m)
 d90 [mm] (converted to m)

 d : depth
 b : width
 

\end{lstlisting}
\subsection{bed\_load\_transport\_wu}
${}$
\begin{lstlisting}
 bed load transport according to Wu

\end{lstlisting}
\subsection{bedform\_dimension\_rijn}
${}$
\begin{lstlisting}
 bed form dimensions
 cf. rijn 1984 iii

\end{lstlisting}
\subsection{bedform\_roughness\_rijn}
${}$
\begin{lstlisting}
 form drag according to van Rijn

\end{lstlisting}
\subsection{bedform\_roughness\_rijn\_2007}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{bedload\_direction}
${}$
\begin{lstlisting}
 bedload transport direction

\end{lstlisting}
\subsection{bedload\_layer\_thickness\_mclean}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{bifurcation\_critical\_aspect\_ratio}
${}$
\begin{lstlisting}
 critical aspect ratio of a bifurcation
 c.f. redolfi and pittaluga

\end{lstlisting}
\subsection{chezy\_einstein}
${}$
\begin{lstlisting}
 chezey coefficient according to Einstein

\end{lstlisting}
\subsection{chezy\_roughness\_engelund\_fredsoe}
${}$
\begin{lstlisting}
 chezy rougness according to engelund and fredsoe

\end{lstlisting}
\subsection{chezy\_to\_manning}
${}$
\begin{lstlisting}
 convert chezy to manning

\end{lstlisting}
\subsection{critical\_grain\_size}
${}$
\begin{lstlisting}
 critical grain size for a given shear velocity

\end{lstlisting}
\subsection{critical\_shear\_stress}
${}$
\begin{lstlisting}
 critical shear Stress

\end{lstlisting}
\subsection{critical\_shear\_stress\_ratio}
${}$
\begin{lstlisting}
 critical shields parameter
 aka critical shear stress ratio
 aka shields curve

\end{lstlisting}
\subsection{critical\_shear\_stress\_wu}
${}$
\begin{lstlisting}
 critical shear stress, according to wu

\end{lstlisting}
\subsection{critical\_shear\_velocity}
${}$
\begin{lstlisting}
 critical shear velocity

\end{lstlisting}
\subsection{derive\_mpm\_foramtive\_discharge}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{dimensionless\_grain\_size}
${}$
\begin{lstlisting}
 dimensionless grain size

\end{lstlisting}
\subsection{dune\_celerity}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{dynamic\_shear\_stress}
${}$
\begin{lstlisting}
 dynamic shear stress

\end{lstlisting}
\subsection{fractional\_transport\_engelund\_hansen}
${}$
\begin{lstlisting}
 fractional sediment transport according to engelund and hansen

\end{lstlisting}
\subsection{grain\_roughness\_mpm}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{grain\_roughness\_rijn}
${}$
\begin{lstlisting}
 grain roughness (skin friction) according to van Rijn

\end{lstlisting}
\subsection{grain\_roughness\_wu}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{hiding\_exposure\_wu}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{hydraulic\_radius}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{manning\_to\_chezy}
${}$
\begin{lstlisting}
 manning to chezy conversion

\end{lstlisting}
\subsection{mobility\_parameter\_rijn}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{mpm2diameter}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{mpm\_solve\_for\_dm}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{reference\_concentration\_rijn}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{reference\_concentration\_smith\_lean}
${}$
\begin{lstlisting}
 reference concentration according to smith and mclean

\end{lstlisting}
\subsection{reference\_height\_rijn}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{reference\_to\_flux\_averaged\_concentration\_rijn}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{saltation\_layer\_thickness}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{sediment\_transport\_directed}
${}$
\begin{lstlisting}
 directed sediment transport

\end{lstlisting}
\subsection{sediment\_transport\_engelund\_hansen\_2}
${}$
\begin{lstlisting}
 sediment transport according to engelund and hansen

\end{lstlisting}
\subsection{sediment\_transport\_relation\_fit}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{sediment\_transport\_relation\_predict}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{sediment\_transport\_scale}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{sediment\_transport\_waves}
${}$
\begin{lstlisting}
 sediment transport by waves

\end{lstlisting}
\subsection{settling\_velocity}
${}$
\begin{lstlisting}
 Settling velocity
 5.23d in julien-2010
 settling velocity in water
 settling velocity according to cheng
 stokes settling velocity
 d : [mm] diameter of sediment particle
 ws : [m/s] settling velocity
            signed ws < 0 : falling
 (Note: was R, radius in m)

 valid for small particles

\end{lstlisting}
\subsection{settling\_velocity\_to\_diameter}
${}$
\begin{lstlisting}
 invert settling velocity to diameter

\end{lstlisting}
\subsection{shields\_number}
${}$
\begin{lstlisting}
 normalized shear stress, shear stress ratio

\end{lstlisting}
\subsection{skin\_2\_total\_friction\_eh}
${}$
\begin{lstlisting}
 skin friction to total friction conversion according to engelund and hansen
 function [theta,C] = skin_2_total_friction_eh(theta_t,Ct)

\end{lstlisting}
\subsection{suspended\_grain\_size}
${}$
\begin{lstlisting}
 suspended grain size distribution based on bed material grain size distribution
 
 assumes that probability of suspension is inverse proportional to grain diameter
 as in Engelund-Hansen transport relation
 - no hiding effects considered
 - no threshold for large grains applied
 - no flocking considered
 note: actual distribution varies with the depth

 d     : [1xnd]  grain size in arbitrary units (on linear, not on log scale)
 h_bed : [nsxnd] fractions of sediment of size d

\end{lstlisting}
\subsection{suspended\_grain\_size\_non\_linear}
${}$
\begin{lstlisting}
 suspended grain size distribution based on bed material grain size distribution
 
 assumes that probability of suspension is inverse proportional to grain diameter
 as in Engelund-Hansen transport relation
 - no hiding effects considered
 - no threshold for large grains applied
 - no flocking considered
 note: actual distribution varies with the depth

 d     : [1xnd]  grain size in arbitrary units (on linear, not on log scale)
 h_bed : [nsxnd] fractions of sediment of size d

\end{lstlisting}
\subsection{suspended\_grain\_size\_rijn}
${}$
\begin{lstlisting}
 grain size of the suspended sediment according to van rijn, empirical

\end{lstlisting}
\subsection{suspended\_transport\_mclean}
${}$
\begin{lstlisting}
 vertical profile of the suspended sediment according to McLean
 u := us/kappa*log(z/z0);
 I = 1/(int_a^h c dz int_a^h u dz) int_a^h c u dz

\end{lstlisting}
\subsection{suspended\_transport\_rijn}
${}$
\begin{lstlisting}
 suspended load transport according to van Rijn

\end{lstlisting}
\subsection{suspended\_transport\_wu}
${}$
\begin{lstlisting}
 suspended sediment transport according to widthu

\end{lstlisting}
\subsection{suspension\_parameter\_rijn}
${}$
\begin{lstlisting}

\end{lstlisting}
\section{lib/sediment-transport/test}
\subsection{test\_adaptation\_length\_bed}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{test\_critical\_shear\_stress}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{test\_settling\_velocity\_to\_diameter}
${}$
\begin{lstlisting}

\end{lstlisting}
\section{lib/sediment-transport}
\begin{lstlisting}
analysis and prediction of fluvial sediment transport and morphodynamics


\end{lstlisting}
\subsection{test\_sediment\_transport\_relation}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{total\_roughness\_engelund\_fredsoe}
${}$
\begin{lstlisting}
 roughness lenght according to engelund and fredsoe

\end{lstlisting}
\subsection{total\_roughness\_rijn}
${}$
\begin{lstlisting}
 total roughness according to van rijn

\end{lstlisting}
\subsection{total\_transport\_ackers\_white}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{total\_transport\_bagnold}
${}$
\begin{lstlisting}
 total sediment transport accoding to bagnold

\end{lstlisting}
\subsection{total\_transport\_eh\_distribution}
${}$
\begin{lstlisting}
 total sediment transport according to engelund hansen
 for a given graqin size distribution

\end{lstlisting}
\subsection{total\_transport\_engelund\_hansen}
${}$
\begin{lstlisting}
 total sediment transport according to Engelund and Hansen

\end{lstlisting}
\subsection{total\_transport\_rijn}
${}$
\begin{lstlisting}
 total sediment transport according to van rijn

\end{lstlisting}
\subsection{total\_transport\_wu}
${}$
\begin{lstlisting}
 total sediment transport according to wu 2000b

\end{lstlisting}
\subsection{total\_transport\_yang}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{transport\_stage\_mclean}
${}$
\begin{lstlisting}
 transport stage according to McLean

\end{lstlisting}
\subsection{transport\_stage\_rijn}
${}$
\begin{lstlisting}
 transport stage as defined by van Rijn

\end{lstlisting}
\subsection{vertical\_ssc\_profile\_mclean}
${}$
\begin{lstlisting}
 vertical profile of the suspended sediment according to McLean

\end{lstlisting}
\section{lib/tide/@T\_Tide}
\subsection{T\_Tide}
${}$
\begin{lstlisting}
 wrapper for TPXO generated tidal time series

\end{lstlisting}
\subsection{build\_index}
${}$
\begin{lstlisting}
 build a structure whose field names contain the index

\end{lstlisting}
\subsection{from\_tpxo}
${}$
\begin{lstlisting}
 read TPXO output into tidetable object

\end{lstlisting}
\subsection{get\_constituents}
${}$
\begin{lstlisting}
 extract constituents of tpxo object

\end{lstlisting}
\subsection{reorder}
${}$
\begin{lstlisting}
 order constituents as specified by "name"

\end{lstlisting}
\subsection{select}
${}$
\begin{lstlisting}
 select a subsect of constituents

\end{lstlisting}
\subsection{shift\_time\_zone}
${}$
\begin{lstlisting}
 shift phase according to time zone

\end{lstlisting}
\section{lib/tide/@Tidal\_Envelope}
\subsection{Tidal\_Envelope}
${}$
\begin{lstlisting}
 process tidal data to extrac the tidal envelope

\end{lstlisting}
\subsection{init}
${}$
\begin{lstlisting}
 initialize with data

\end{lstlisting}
\section{lib/tide/@Tide\_wft}
\begin{lstlisting}
wavelet analysis of tidal data


\end{lstlisting}
\subsection{Tide\_wft}
${}$
\begin{lstlisting}
 wavelet transform of tidal time series

\end{lstlisting}
\subsection{transform}
${}$
\begin{lstlisting}
 wavelet transform tidal time series
 input:
 time   : [1xn] abszissa of input vector, for example time, must be equally spaced
 val    : [1xn] signal, input data series (e.g water level or velocity)
 F      : [1xm] base frequencies, 1, 1, 2, ... for mean level, diurnal, semidirunal ...
 		base periods from base frequencies T=1/F
 n      : [1xm] wavelet window length in multiple of periods
 fc, nc : [scalar] low frequency cutoff and window length in periods
 winstr : [char] fourier windows (kaiser (recommended), hanning, box, etc)
 dt_max : [scalar] maximum time to fill gaps in input data series (recommended 3/24 for tide)
 output:
 tide   : struct with fields
          w_coeff   : [1xn] wavelet coefficients (complex)
          amplitude : amplitude
          phase     : phase
          range     :
          h_tide    :
          h_low     :
          h

\end{lstlisting}
\section{lib/tide/@Tidetable}
\begin{lstlisting}
class for generating tidetable data


\end{lstlisting}
\subsection{Tidetable}
${}$
\begin{lstlisting}
 Tide table

\end{lstlisting}
\subsection{analyze}
${}$
\begin{lstlisting}
 extract tidal envelope from time series

\end{lstlisting}
\subsection{export\_csv}
${}$
\begin{lstlisting}
 export tide table to csv file

\end{lstlisting}
\subsection{generate}
${}$
\begin{lstlisting}
 run TPXO to generate time series

\end{lstlisting}
\subsection{generate\_tpxo\_input}
${}$
\begin{lstlisting}
 generate tpxo input table
 Note: superseeded by perl script

\end{lstlisting}
\subsection{import\_tpxo}
${}$
\begin{lstlisting}
 import TPXO data into tidetable object 

\end{lstlisting}
\subsection{plot\_neap\_spring}
${}$
\begin{lstlisting}
 plot average neap and spring tide

\end{lstlisting}
\section{lib/tide}
\begin{lstlisting}
analysis prediction of tides in rivers and estuaries by empirical and theoretical methods


\end{lstlisting}
\subsection{constituents}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{doodson}
${}$
\begin{lstlisting}
 frequency of tidal constituents
 method of doodson
 source: wikipedia

\end{lstlisting}
\subsection{envelope\_amplitude}
${}$
\begin{lstlisting}
 compute envelopes of hw and low water

\end{lstlisting}
\subsection{envelope\_slack\_water}
${}$
\begin{lstlisting}
 slack water envelope of the tide

\end{lstlisting}
\subsection{interval\_extrema}
${}$
\begin{lstlisting}
 times and evelations for high and low water

\end{lstlisting}
\subsection{interval\_extrema2}
${}$
\begin{lstlisting}
 mimimum and maximum within intervals of constant length,
 intended for periodic functions

\end{lstlisting}
\subsection{interval\_zeros}
${}$
\begin{lstlisting}
 times of slack water determined frim velocity u

\end{lstlisting}
\subsection{lunar\_phase}
${}$
\begin{lstlisting}
 lunar phase

\end{lstlisting}
\subsection{rayleigh\_criterion}
${}$
\begin{lstlisting}
 raleigh criterion for resolving tidal constituents
 T > 1/|f1-f2|

\end{lstlisting}
\section{lib/tide/river-tide/@River\_Tide}
\begin{lstlisting}
predict tide in a backwater affected river with a sloping/varying bed

Assumptions and capabilities:
	- tidal dynamics follow the 1D-Shallow-Water-Equation
	  (depth and cross-sectionally averaged Navier-Stokes-Equation)
	- rectangular cross section
	- width can vary along the channel
	- friction coefficient (cd) constant along channel and over time (Chezy)
	- advective accelleration term is considered, but can be deactivated
	- vertical profile of streamwise velocity is constant
	  (Boussinesq coefficient is unity (1))

Limitations / TODO list:
	- single channel dynamics only (no tidal networks)
	- no wind-shear stress (no storm surges)
	- no tidal flats / intertidal areas (width constant in time)
	- no flood-plain during high-river flow
	- no stratification or along-channel salinty gradient
	- negligible head loss in channel bends
	- negligible feed-back of the sediment concentration on the propagation of the tide
	- low Froude Number (no hydraulic jumps due to cataracts or tidal bores)	

- At present, only two tidal components are supported
  (either D1 with D2 or D2 with D4, in addition to the mean water level z0),
  for mixed diurnal-semidiurnal cases with dominant semidiurnal component,
  the class has to be extended to support three components (D1, D2 and D4)

- At present, the tripel overtide is not computed (D3 for diurnal, D6 for semindiurnal tide),
  note that this is the main overtide for the case of low river flow

- At present, the 1/h non-linearity is only included in the approximations of
  the backwater curve, but not it's influence on the tidal frequency components

Method:

This class calls numerical solvers for second order ordinary differential
equation boundary value problems

Tides is represented as exponential series in form of total discharge Q = sum Q_i = Q_0 + Q_1 + Q_2,
as discharge is conserved (balanced), the equations are simpler than for level z and velocity u,
and the frequency components of z are straight forward determined by differentiation of Q

Class and function structure:
	River_Tide :
		computes river tide, provides the ode coefficients to the boundary value solver
	bvp2c, bvp2fdm :
		solve the underlying second order boundary value problem
	River_Tide_Map :
		provides convenient batch runs and processing of River_Tide instances

Minimum working example, c.f. example_rive_tide.m and example_river_tide_map.m

	input:

	Q0    : scalar, river discharge (m^3/s)
	omega : scalar, angular frequency main tidal species in (1/seconds)
	x     : 2x1 vector, left and right end of computational domain of the river (m)
	w(x)  : function of width along the river (m)
	cd(x) : function of drag coefficient along the river (1)
	zb(x) : function of bed level along the river (m)

	opt   : structure with options
	opt.model_str = 'wave' (other solver are not supported at the moment)
	opt.solver = @bvp2c or @bvp2fdm
	opt.nx : number of grid points along channel
	opt.ns : base for logarithmic spacing of grid points, 1 : linear spacing	

	bc  : structure array of boundary conditions
		r, row 1..2 : left and right end, respectively
		c, column 1 : mean (river) component
		          2..n : condition form column-1 frequency component

		(       q(1)*(p(1) y^-(x0) + p(2) dy^-/dx(x0) ...
                     +  q(2)*(p(1) y^+(x0) + p(2) dy^+/dx(x0) ) = bc(c,r).val
                           = val(0)

	bc(c,r).var : Quantity, either 'z' or 'Q'
	bc(c,r).val : complex amplitude of chosen variable
                      (c.f. (1 + 0i) [m] for surface elevation amplitude of 1m)
		      (value has to be real for mean component)
		      mean component requires z and Q to be specified at opposit ends
	bc(c,r).p   : factor for Dirichlet p(1) or Neumann p(2) condition
		      p = [1,0] : pure Dirichlet 
		      p = [0,1] : pure Neumann
		      sum of abs(p) must be nonzero for each end and each frequency component
	bc(c,r).q   : factor for left and right going wave, only available for bvp2c
		      q = [1,1] : total water level / discharge
		      q = [1,0] : only left going wave
		      q = [0,1] : only right going wave
		      q has no meaning for the mean component and is ignored
		      q is only supported by bvp2c,
                      bvpfdm uses default q = [1,1]
		      sum of abs(q) for each frequency component must be zero


\end{lstlisting}
\subsection{River\_Tide}
${}$
\begin{lstlisting}
 river tide in a single 1D channel
 TODO split in two classes:
 one that stores data (RT_Solve), one that provides equations (RT_Analytic)

\end{lstlisting}
\subsection{bc\_transformation}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{bcfun}
${}$
\begin{lstlisting}
 Robin (mixed) boundary conditions for the river tide,
 supplied for each frequency component,
 wrapper that copies values are from the member struct "bc"

       q*(p*Q_1^- + (1-p)*dQ_1^-/dx 
 input :
	x       : coordinate (left or right end)
	id,ccdx : frequency component index
                (1 = 0 omega (mean), 2 : 1 omega, 3 : 2 omega, ...
 columns of bc : frequency
 rows of bc, left, right boundary
 output :
 	p : [2x1] linear combination of Dirichlet and Neumann boundary condition
          p(1) -> weight Dirichlet boundary condition
	    p(2) -> weight Neumann boundary condition
      q linear combination of left and right travelling (incoming and outgoing) wave
	    q(1) weight left going wave
          q(2) weight right going wave
 	rhs = 0 -> homogeneous boundary condition


 function [rhs, p, q, obj] = bcfun(obj,x,y,ccdx)

\end{lstlisting}
\subsection{check\_continuity}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{check\_momentum}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{d2au1\_dx2}
${}$
\begin{lstlisting}
 second derivative of the tidal velocity magnitude

 note: this is for finding zeros,
       the true derivative has to be scaled  up by z

\end{lstlisting}
\subsection{d2az1\_dx2}
${}$
\begin{lstlisting}
 second derivative of the tidal surface elevation

 note: this is for finding zeros,
       the true derivative has to be scaled  up by z

\end{lstlisting}
\subsection{decompose}
${}$
\begin{lstlisting}
 decompose the tide into a right and left travelling wave,
 i.e. into incoming and reflected wave
 TODO subtract forcing term

\end{lstlisting}
\subsection{discharge2level}
${}$
\begin{lstlisting}
 tidal component of surface elevation determined from tidal discharge

 by continuity :

 dz/dt + dq/dx = 0
 => i o z = - dq/dx
 =>     z = -1/(io) dq/dx
 =>     z = 1i/o dq/dx

 TODO allow Q as input
 TODO rename into Q1_to_z1
 Mon  7 Oct 19:04:14 PST 2019 : added correction for change of width

\end{lstlisting}
\subsection{dkq\_dx}
${}$
\begin{lstlisting}
 along-channel derivative of the wave number of the discharge
 neglects width variation

 TODO, rederive with g as variable

\end{lstlisting}
\subsection{dkz\_dx}
${}$
\begin{lstlisting}
 along channel derivative of the wave number of the tidal surface elevation
 ignores width variation dh/dx and second order depth variation (d^2h/dx^2)
 TODO rederive with g symbolic

\end{lstlisting}
\subsection{even\_overtide\_analytic}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{friction\_coefficient\_dronkers}
${}$
\begin{lstlisting}
 friction coefficient according to Dronkers

 the coefficients are semi-autogenerated

 c.f. dronkers 1964
 c.f. Cai 2016

 p = [p0,p1,p2,p3];
 alpha = Ur/Ut = river velocity / tidal velocity amplitude = (umax+umin)/(umax-umin)

 function p = friction_coefficient_dronkers(alpha,order)


\end{lstlisting}
\subsection{friction\_coefficient\_godin}
${}$
\begin{lstlisting}
 friction coefficient according to Godin
 these coefficients are identical to Dronker's for U_R = phi = 0

 function G = friction_coefficient_godin(obj,phi)

\end{lstlisting}
\subsection{friction\_coefficient\_lorentz}
${}$
\begin{lstlisting}
 friction coefficient according to Lorent'z
 identical to Dronker's coefficient for zero river flow
 and a single frequency component
 c.f. Cai
 c.f. Dronkers 

 function L = friction_coefficient_lorentz(obj,phi)

\end{lstlisting}
\subsection{friction\_dronkers}
${}$
\begin{lstlisting}
 friction determined by Dronker's method

 input :
         u    : velocity time series
	   Umid : arithmetic mean of mininmum and maximum velocity
                (not the mean of the velocity, usually non-zero even without river flow)
         Uhr  : half-range of the velocity, less than the sum of
                the frequency amplitudes, except at perigean spring tides

 function [uau_sum uau p] = friction_dronkers(u,Umid,Uhr,order)

\end{lstlisting}
\subsection{friction\_exponential\_dronkers}
${}$
\begin{lstlisting}
 friction coefficicients for the frequency components computed by Dronkers method
 c.f. Dronker's 1964 eq 8.2 and 8.4
 Note: Cai dennominates alpha as phi

 function [c uau uau_ p] = friction_trigonometric_dronkers(u,dp,Umid,Uhr,order,psym)

\end{lstlisting}
\subsection{friction\_godin}
${}$
\begin{lstlisting}
 compute friction with the method of Godin

\end{lstlisting}
\subsection{friction\_lorentz}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{friction\_quadratic}
${}$
\begin{lstlisting}
 friction determined by Dronker's method

\end{lstlisting}
\subsection{friction\_trigonometric\_dronkers}
${}$
\begin{lstlisting}
 friction computed by the method of Dronkers
 expressed as coefficients for the frequency components
 c.f. dronkers 1964 eq 8.2 and 8.4
 Note: Cai dennominates alpha as phi

\end{lstlisting}
\subsection{friction\_trigonometric\_godin}
${}$
\begin{lstlisting}
 friction computed by the method of Godin
 expressed as coefficients of the frequency components (trigonometric form)

  function [c, uau] = friction_trigonometric_godin(obj,u,dp,Umax)

\end{lstlisting}
\subsection{friction\_trigonometric\_lorentz}
${}$
\begin{lstlisting}
 friction computed by the method of Lorent'z
 expressed as coefficients of the frequency components (trigonometric form)
 

\end{lstlisting}
\subsection{generate\_delft3d}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{init}
${}$
\begin{lstlisting}
 provide initial condition by solving the backwater equation for surface level
 TODO this should not be solved as a ivp but included in the bvp iteration
 TODO generate the mesh here and precompute fixed values instead of passing functions
 TODO Q0 should not be a function
 function obj = init(obj, Xi)

\end{lstlisting}
\subsection{mwl\_offset}
${}$
\begin{lstlisting}
 offset of the tidally averaged surface elevation caused by tidal friction
 Linear estimate of the mean water level offset (ignoring feed-back of tide)

\end{lstlisting}
\subsection{mwl\_offset\_2}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{mwl\_offset\_analytic}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{odefun}
${}$
\begin{lstlisting}
 coefficients of the backwater and wave equation for river-tides

\end{lstlisting}
\subsection{odefun0}
${}$
\begin{lstlisting}
 coefficients of the backwater equation for the river tide
 TODO merge with backwater

\end{lstlisting}
\subsection{odefun\_advective\_acceleration}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{odefun\_friction}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{odefun\_ghof}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{odefun\_swe\_jacobian}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{odefun\_width}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{odefunk}
${}$
\begin{lstlisting}

 coefficients of the ordinary differential equation of the k-th freqeuncy
 component of the tide

 f1 Q'' + f2 Q' + f3 Q + f4 = 0

 TODO rename f into c
 TODO better pass dzb_dx instead of dz0_dx
 TODO aa, oh and gh terms are not tested for width ~= 1


\end{lstlisting}
\subsection{solve}
${}$
\begin{lstlisting}
 call stationary or non-stationary solver respectively

 function obj   = solve(obj)

\end{lstlisting}
\subsection{solve\_swe}
${}$
\begin{lstlisting}
 determine river tide by the fully non-stationary FVM and then extract the tide
  this is experimental and not yet fully working

\end{lstlisting}
\subsection{solve\_wave}
${}$
\begin{lstlisting}
 solve for the oscillatory (tidal) componets

 function obj   = solve_wave(obj)

\end{lstlisting}
\subsection{wave\_number\_analytic}
${}$
\begin{lstlisting}
 analytic expression of the wave number

 valid for both tidally, river dominated and low friction conditions
 and converging channels

 k      : complex wave number in a reach with constant width and bed slope
 im(k)  : damping modulus (rate of amplitude change)
 re(k)  : actual wave number (rate of phase change)

 c.f. derive_wave_number


\end{lstlisting}
\subsection{wave\_number\_approximation}
${}$
\begin{lstlisting}
 approximate wave number of the left and right traveling wave for variable coefficients

 TODO merge with wave_number_analytic

 function [k, k0, dk0_dx_rel, obj] = wave_numer_aproximation(obj)

\end{lstlisting}
\section{lib/tide/river-tide/@River\_Tide\_Cai}
\begin{lstlisting}
Prediction of river tide by the method of Cai
c.f. Cai 2013, Cai 2015


\end{lstlisting}
\subsection{Gamma}
${}$
\begin{lstlisting}
 Gamma parameter for tidal propagation
 c.f. Cai 2014

\end{lstlisting}
\subsection{River\_Tide\_Cai}
${}$
\begin{lstlisting}
 prediction of river tide by the method of Cai (2014)

\end{lstlisting}
\subsection{river\_tide\_cai\_}
${}$
\begin{lstlisting}
 determine the surface amplitude of the river-tide
 c.f. Cai

\end{lstlisting}
\subsection{rt\_quantities}
${}$
\begin{lstlisting}
 determine the quantities that determine the tidal propagation
 c.f. Cai
 
 Note: this computes 4 unknowns following Cai, however,
 lambda, mu and epsilon can be substituted
 making it an equation in one unknown (delta) only

\end{lstlisting}
\section{lib/tide/river-tide/@River\_Tide\_Empirical}
\begin{lstlisting}
Empirical fit to measurement and prediction (from tide at sea and river discharge)
of the river tide


\end{lstlisting}
\subsection{River\_Tide\_Empirical}
${}$
\begin{lstlisting}
 class for fitting models to at-a-station time series of tidal elevation

\end{lstlisting}
\subsection{fit\_amplitude}
${}$
\begin{lstlisting}
 fit the oscillatory components

\end{lstlisting}
\subsection{fit\_mwl}
${}$
\begin{lstlisting}
 fit the tidally averaged water level

\end{lstlisting}
\subsection{fit\_phase}
${}$
\begin{lstlisting}
 fit the phase of the oscillatory components

\end{lstlisting}
\subsection{fit\_range}
${}$
\begin{lstlisting}
 fit the tidal range

\end{lstlisting}
\subsection{predict\_amplitude}
${}$
\begin{lstlisting}
 predict the oscillatory components

\end{lstlisting}
\subsection{predict\_mwl}
${}$
\begin{lstlisting}
 predict the mean water level

\end{lstlisting}
\subsection{predict\_phase}
${}$
\begin{lstlisting}
 predict tidal phase 

\end{lstlisting}
\subsection{predict\_range}
${}$
\begin{lstlisting}
 predict the tidal range

\end{lstlisting}
\subsection{rt\_model}
${}$
\begin{lstlisting}
 select the model for fitting

\end{lstlisting}
\section{lib/tide/river-tide/@River\_Tide\_JK}
\begin{lstlisting}
empirical analysis and prediction of river tides by the method of Jay and Kukulka


\end{lstlisting}
\subsection{River\_Tide\_JK}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{damping\_modulus}
${}$
\begin{lstlisting}
 damping modulus of the river tide
 c.f. Jay and Kukula
 function r = damping_modulus(obj,h0,b,Qr)

\end{lstlisting}
\subsection{mean\_level}
${}$
\begin{lstlisting}
 tidally averaged surface elevation
 c.f. Jay and Kukulka

\end{lstlisting}
\subsection{rivertide\_predict}
${}$
\begin{lstlisting}
 predict river tide by the method of jay and kukulka
 TODO rename

\end{lstlisting}
\subsection{rivertide\_regress}
${}$
\begin{lstlisting}
 Regression of tidal coefficients according to Jay & Kulkulka

 coefficients of the r-regression factor 2 apart for specis (jay C7)
 this can be repeated for each tidal species (diurnal, semidiurnal)

\end{lstlisting}
\subsection{tidal\_discharge}
${}$
\begin{lstlisting}
 tidal discharge
 c.f. Jay and Kukulka
 function Qt = tidal_discharge(obj,x,R0,h0,b,Qr)

\end{lstlisting}
\subsection{tidal\_range}
${}$
\begin{lstlisting}
 predict tidal range

\end{lstlisting}
\section{lib/tide/river-tide/@River\_Tide\_Map}
\begin{lstlisting}
hash container for a set of River_Tide predictions for different boundary conditions


\end{lstlisting}
\subsection{River\_Tide\_Map}
${}$
\begin{lstlisting}
 container class to store individual river tide scenarios

\end{lstlisting}
\subsection{fun}
${}$
\begin{lstlisting}
 compute river tide for a scenario with specific boundary conditions and store it in the hash,
 or retrive the scenario, if it was already computed

\end{lstlisting}
\subsection{key}
${}$
\begin{lstlisting}
 key for storing a scenario

 function [key obj] = key(obj,varargin)

\end{lstlisting}
\subsection{plot}
${}$
\begin{lstlisting}
 quick plot of scenario result

 function obj = plot(obj,Xi,Q0,W0,S0,z1_downstream,cd,zb_downstream,omega,q,opt)

\end{lstlisting}
\section{lib/tide/river-tide/@River\_Tide\_Network}
\begin{lstlisting}
predict tides in a fluvial channel network

\end{lstlisting}
\subsection{River\_Tide\_Network}
${}$
\begin{lstlisting}
 tide in a fluvial delta channel network, extension of 1D river tide
 the network is a directed graph
 TODO convert from trig-to exponential form

\end{lstlisting}
\subsection{discharge\_amplitude}
${}$
\begin{lstlisting}
 discharge amplitude

\end{lstlisting}
\subsection{mean\_water\_level}
${}$
\begin{lstlisting}
 predict the mean water level

\end{lstlisting}
\subsection{plot\_mean\_water\_level}
${}$
\begin{lstlisting}
 plot tidally averaged water level

\end{lstlisting}
\subsection{plot\_water\_level\_amplitude}
${}$
\begin{lstlisting}
 plot surface elevation amplitude

\end{lstlisting}
\subsection{solve}
${}$
\begin{lstlisting}
 solve for the tide in a fluvial chanel network

 boundary condition at end points not connected to junctions
 	[ channel 1 id, endpoint id (1 or 2), s0, c0
        ...
         channel n id, endpoint id (1 or 2), s0, c0]

 conditions at junctions are specified as cells
	 each cell contains an nx2 array
	 n : number of connecting channels
	 [channel id1, endpoint id (1 or 2), ...
         channel idn, endpoint id (1 or 2)]

 every tidal species for each channel has 4 unknowns
 these are 2x2 unknowns for the sin + cos of left and right going wave

\end{lstlisting}
\subsection{water\_level\_amplitude}
${}$
\begin{lstlisting}
 predict the surface elevation amplitude

\end{lstlisting}
\section{lib/tide/river-tide}
\begin{lstlisting}
analysis and prediction of river tides

Sub-Classes:
 
@River_Tide
	- prediction of river tide in a backwater affected river with a sloping bed
@River_Tide_Cai
	- prediction of river tide, method of Cai
@River_Tide_Empirical
	- prediction of river tide, empirical
@River_Tide_JK
	- prediction of river tide, empirical after Jay and Kukulka
@River_Tide_Map
	- mulitple-scenaria container for River_Tide
@River_Tide_Network
	- extension of River_Tide to networks


\end{lstlisting}
\subsection{damped\_wave\_bvp}
${}$
\begin{lstlisting}
 solved damped wave equation
 z'' + a z = 0
 z(0) = z0, z(L) = 0

\end{lstlisting}
\subsection{damped\_wave\_ivp}
${}$
\begin{lstlisting}
 linearly damped wave in rectangular channel
 solve tide as initial value problem
 damped wave approximation

 z'' + a z = 0

 x_t = Ax + b

\end{lstlisting}
\subsection{damping\_modulus\_river}
${}$
\begin{lstlisting}
 damping modulus of the tidal wave for river flow only

\end{lstlisting}
\subsection{rdamping\_to\_cdrag\_tide}
${}$
\begin{lstlisting}
 converts damping rate to drag coefficient
 c.f. friedrichs, ippen harleman

\end{lstlisting}
\subsection{river\_tide\_godin}
${}$
\begin{lstlisting}
 analytic solution to the river tide formulated as boundary value problem
 in a river with finite length

 c.f. Godin 1986


\end{lstlisting}
\subsection{rt\_celerity}
${}$
\begin{lstlisting}
 celerity of the tidal wave

\end{lstlisting}
\subsection{rt\_quasi\_stationary\_complex}
${}$
\begin{lstlisting}
 quasi-stationary solution of the SWE
 TODO staggered grid does not help: q1' needed

\end{lstlisting}
\subsection{rt\_quasi\_stationary\_trigonometric}
${}$
\begin{lstlisting}
 quasi statinary form of the SWE

\end{lstlisting}
\subsection{rt\_reflection\_coefficient\_gradual}
${}$
\begin{lstlisting}
 reflection coefficient for gradual varying cross section geometry
 without damping

\end{lstlisting}
\subsection{rt\_wave\_equation}
${}$
\begin{lstlisting}
 solve river tide as boundary value problem

 input:
 omega : [nfx1] angluar frequency of tidal component, zero for mean flow
 reach : [nrx1] struct
 .L    : [1x1]  length of reaches
	 .width(x,h)	width
	 .bed(x,h)	bed level
	 .surface(x,h)	surface elevation
	 .Cd(x,h)	drag coefficient
 .bc   : [nd,nf] boundary/junction conditions
	  bc(id,if).type : {surface, velocity, discharge} (dirichlet)
	  bc(id,if).val  : value
 opt   : [1x1] struct
	- constant surface elevation
	- deactivative advective acceleration
 	.dx : spatial resolution

 dimensions:
	nr : nurmber or reaches
	nd : upstream/downstream index
	nf : frequency index

\end{lstlisting}
\subsection{rt\_z2q}
${}$
\begin{lstlisting}
 determine tidal discharge from water level for tidal wave

\end{lstlisting}
\section{lib/tide/river-tide/test/test}
\subsection{test\_bvp2c\_sym}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{test\_celerity}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{test\_characteristic\_rate\_of\_change}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{test\_dronkers\_compound}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{test\_friction\_dronkers}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{test\_friction\_dronkers2}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{test\_fv\_compare\_schemes}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{test\_fv\_convergence}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{test\_power\_series}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{test\_reflection\_coefficient\_gradual}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{test\_ricatti}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{test\_river\_tide\_models}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{test\_rt\_reflection}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{test\_rt\_zs0}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{test\_swe}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{test\_utm2latlon}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{test\_wave\_twopass}
${}$
\begin{lstlisting}

\end{lstlisting}
\section{lib/tide/river-tide/test}
\subsection{test\_bvp2c2}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{test\_complex\_even\_overtide}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{test\_fourier\_power\_exp}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{test\_friction}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{test\_reflection}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{test\_rt\_wave\_number}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{test\_tidal\_river\_network}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{test\_tidal\_river\_network\_z0}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{test\_tide\_slack\_exp}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{test\_wave\_number\_godin}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{test\_wave\_numer\_aproximation}
${}$
\begin{lstlisting}

\end{lstlisting}
\section{lib/tide/river-tide}
\begin{lstlisting}
analysis and prediction of river tides

Sub-Classes:
 
@River_Tide
	- prediction of river tide in a backwater affected river with a sloping bed
@River_Tide_Cai
	- prediction of river tide, method of Cai
@River_Tide_Empirical
	- prediction of river tide, empirical
@River_Tide_JK
	- prediction of river tide, empirical after Jay and Kukulka
@River_Tide_Map
	- mulitple-scenaria container for River_Tide
@River_Tide_Network
	- extension of River_Tide to networks


\end{lstlisting}
\subsection{tidal\_ellipse}
${}$
\begin{lstlisting}
 tidal ellipse, numerical ode solution

\end{lstlisting}
\subsection{tide\_slack\_exp}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{wave\_number\_tide}
${}$
\begin{lstlisting}
 wave number of the tide without river flow
 c.f. friedrichs, ippen harleman
 output :
 k : wave number, such that
                  z(t,x) = z1(t,0) exp(1i*(omega*t-k*x))

  re(k) : rate of phase change
 -im(k) : damping rate

 function [k k_low k_high] = damping_modulus_tide(omega,cd,h0,az1)

\end{lstlisting}
\subsection{wavetrainz}
${}$
\begin{lstlisting}
 determine river tide by iterated integration of the surface elevation

\end{lstlisting}
\subsection{wavetwopassz}
${}$
\begin{lstlisting}
 two pass solution for the linearised wave equation, for surface elevation

\end{lstlisting}
\section{lib/tide/test/river-tide}
\subsection{example\_river\_tide}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{example\_river\_tide\_map}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{river\_tide\_test}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{river\_tide\_test\_01}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{river\_tide\_test\_02}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{river\_tide\_test\_03}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{river\_tide\_test\_04}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{river\_tide\_test\_05}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{river\_tide\_test\_06}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{river\_tide\_test\_07}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{river\_tide\_test\_08}
${}$
\begin{lstlisting}
		hold on;
		plot(x,abs(z),'--');
		hold on;
		plot(x,angle(z),'--');

\end{lstlisting}
\subsection{river\_tide\_test\_09}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{river\_tide\_test\_10}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{river\_tide\_test\_11}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{river\_tide\_test\_12}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{river\_tide\_test\_13}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{river\_tide\_test\_plot}
${}$
\begin{lstlisting}

\end{lstlisting}
\section{lib/tide/test}
\subsection{test\_tidal\_harmonic\_analysis}
${}$
\begin{lstlisting}

\end{lstlisting}
\section{lib/tide}
\begin{lstlisting}
analysis prediction of tides in rivers and estuaries by empirical and theoretical methods


\end{lstlisting}
\subsection{tidal\_constituents}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{tidal\_energy\_transport\_1d}
${}$
\begin{lstlisting}
 energy transport of a tidal wave

\end{lstlisting}
\subsection{tidal\_envelope}
${}$
\begin{lstlisting}
 envelope of the tide

 input : t time in days
         f surface elevation
 ouput : tl time of low water
         vl surface elevation at low water
         ldx index of low water
         th time of high water
         vh surface elevation at high water
         hdx index of high water
         ndx neap index
         sdx spring index
         dmax:
         drange: range per day

\end{lstlisting}
\subsection{tidal\_envelope2}
${}$
\begin{lstlisting}
 surface levelation envelope of the tide
 low water, high water and tidal range for lunar each day
 

 input:
        time  : 
        L     : surface elevation
        order : interpolation order (default 2)
 ouput:
        timei : vector eqispaced
        lmini : minimum level
        lmaxi : maximum level
        rangei : range
        midrangei : (min + max)/2, usually different from mean
        phii  : pseudo phase

 Note: the pseudo phase phi jumps, this is because if the tide is semidiurnal,
       sometimes the lower hw becomes the next day higher then than the 
	current high water, e.g. there is no smooth transition by
       51min but a jump by 12h

\end{lstlisting}
\subsection{tidal\_harmonic\_analysis}
${}$
\begin{lstlisting}
 tidal_harmonic analysis

\end{lstlisting}
\subsection{tidal\_range\_exp}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{tidal\_range\_tri}
${}$
\begin{lstlisting}

\end{lstlisting}
\section{lib/tide/tide-savenije}
\subsection{savenije\_phase\_lag}
${}$
\begin{lstlisting}
 phase lag of high and low water

 phi : u_river/u_tide < 1

 delta_eps_hw = omega*(t_hws - t_hw)
 delta_eps_hw = omega*(t_lws - t_lw)

 c.f. savenije

\end{lstlisting}
\subsection{savenije\_tidal\_range}
${}$
\begin{lstlisting}
 tidal range

 based on Savenije 2012

 x    : distance to river mouth
 eta  : range
 eta0 : range at river mouth
 hbar : mean water depth
 phi  : velocity ratio u_tide/u_river 
	 note: this varies in strongly convergent estuaries
 K    : mannings coefficient
 I    : residual surface slope I

\end{lstlisting}
\subsection{savenije\_tidal\_range1}
${}$
\begin{lstlisting}
 tidal range

 based on Horrevoets/Savenije, 2004

 H0   : tidal range at river mouth
 h0   : initial water depth
 v    : velocity scale
 b    : convergence length
 sine : phase lag
 K    : Mannings coefficient
 Q_r   : river discharge

\end{lstlisting}
\subsection{savenije\_timing\_hw\_lw}
${}$
\begin{lstlisting}
 time of high water and low water
 c.f. savenije 2012

\end{lstlisting}
\subsection{tide-savenije}
${}$
\begin{lstlisting}

\end{lstlisting}
\section{lib/tide}
\begin{lstlisting}
analysis prediction of tides in rivers and estuaries by empirical and theoretical methods


\end{lstlisting}
\subsection{tide\_low\_high\_exp}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{tide\_low\_high\_tri}
${}$
\begin{lstlisting}

\end{lstlisting}
\section{root}
\begin{lstlisting}
Root folder of the source code belonging to the doctoral thesis:

"Multi-Scale Monitoring and Modelling of the Kapuas River Delta", Karl K\"aster, 2019,

and master thesis:

"Computing the Spectrum of the Confined Hydrogen Atom", Karl K\"astner, 2012.

Copyright (C) 2010-2019 Karl K\"astner

Installation instructions:
	
1) Install Matlab
2) Install subversion (svn) and add subversion to the search path, so that
   it can be called from Matlab
3) Checkout this umbrella-project:
   svn checkout https://github.com/karlkastner/root/trunk root/
4) Start Matlab
5) Change into this directory ('root/')
6) Run the Matlab script "startup" located in this directory

The script then fetches the sub-repositories and adds them to the
Matlab search path
	
Note:

The code upload is work in progress, more parts will be subsequently
documented, added and tested.

This is experimental code. Use it wisely and at your own risk.

Licence:

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <https://www.gnu.org/licenses/>.


\end{lstlisting}
\subsection{load\_svn\_externals}
${}$
\begin{lstlisting}
 script emulating svn:external, which is not supported by GitHub

\end{lstlisting}
\subsection{quick\_data\_download}
${}$
\begin{lstlisting}

\end{lstlisting}
\section{sanggau}
\begin{lstlisting}
processing of sanggau water level, adcp and hadcp measurements
processing of measurements of Sanggau station, Kapuas River km 290, Kalimantan Barat, Indonesia


\end{lstlisting}
\subsection{sanggau\_align\_transect}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{sanggau\_backscatter\_coefficient}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{sanggau\_batch}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{sanggau\_boat\_velocity}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{sanggau\_calib\_table}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{sanggau\_check\_error}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{sanggau\_compare\_hadcp2rc}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{sanggau\_compare\_hadcp2rc\_2}
${}$
\begin{lstlisting}
ytick(-15:5:15); ylim([-20 15]); yticklabel(sprintf('%d%%\n',(-15:5:15)'))

\end{lstlisting}
\subsection{sanggau\_compare\_hadcp2rc\_3}
${}$
\begin{lstlisting}
yticklabel(sprintf('%d%%\n',(-15:5:15)'))

\end{lstlisting}
\subsection{sanggau\_compare\_models}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{sanggau\_critical\_flow\_depth}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{sanggau\_cs\_area}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{sanggau\_dgps\_bt\_comparison}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{sanggau\_energy\_slope}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{sanggau\_error\_correlation}
${}$
\begin{lstlisting}
% mode 2 : direct residuals of f_z and not those given by lienarisation are used

\end{lstlisting}
\subsection{sanggau\_error\_h\_u}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{sanggau\_error\_in\_area}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{sanggau\_export\_coordinates}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{sanggau\_gsd}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{sanggau\_hadcp\_calibration}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{sanggau\_hadcp\_correction\_data}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{sanggau\_hadcp\_velocity\_variation}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{sanggau\_instationary\_rating\_curve}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{sanggau\_ivm}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{sanggau\_load\_bed\_level\_2016}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{sanggau\_load\_gsd}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{sanggau\_load\_hadcp}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{sanggau\_load\_pilot}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{sanggau\_maximum\_vs\_average\_velocity}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{sanggau\_mean\_discharge}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{sanggau\_metadata}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{sanggau\_optimal\_filter\_length}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{sanggau\_photmoetric\_level\_2016\_11}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{sanggau\_plot\_backscatter}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{sanggau\_plot\_backscatter\_flux}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{sanggau\_plot\_bathymetry\_2d}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{sanggau\_plot\_bathymetry\_2d\_1}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{sanggau\_plot\_bathymetry\_curvature}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{sanggau\_plot\_bed\_profile\_1d}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{sanggau\_plot\_bed\_profile\_1d\_2}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{sanggau\_plot\_bed\_profile\_1d\_3}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{sanggau\_plot\_bottom\_track}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{sanggau\_plot\_cross\_section}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{sanggau\_plot\_discharge\_bart}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{sanggau\_plot\_error}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{sanggau\_plot\_hadcp\_discharge}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{sanggau\_plot\_rating\_curve}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{sanggau\_plot\_rc\_mcmc}
${}$
\begin{lstlisting}




\end{lstlisting}
\subsection{sanggau\_plot\_stage\_change}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{sanggau\_plot\_surface\_slope}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{sanggau\_plot\_transverse\_velocity\_profile}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{sanggau\_plot\_velocity\_nz}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{sanggau\_plot\_vertical\_profile}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{sanggau\_plot\_vertical\_profile\_parameter}
${}$
\begin{lstlisting}
% split

\end{lstlisting}
\subsection{sanggau\_plot\_z0\_2d}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{sanggau\_plots}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{sanggau\_process\_discharge}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{sanggau\_process\_discharge\_bart}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{sanggau\_quick\_plot}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{sanggau\_rating\_curve}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{sanggau\_rc\_mcmc}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{sanggau\_rc\_vs\_ivm}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{sanggau\_redistribution\_by\_bathymetry}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{sanggau\_rouse\_profile}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{sanggau\_sdm\_scale\_vs\_depth}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{sanggau\_stage\_acf}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{sanggau\_std\_u\_and\_z}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{sanggau\_test\_discharge}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{sanggau\_theoretic\_sediment\_transport}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{sanggau\_transverse\_velocity\_profile}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{sanggau\_velocity\_direction}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{sanggau\_velocity\_profile}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{sanggau\_veloctiy\_profile\_rozovskii}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{sanggau\_z\_0\_campaigns}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{sanggau\_z\_0\_convergence}
${}$
\begin{lstlisting}

\end{lstlisting}
\subsection{sanggau\_z\_0\_optimal\_R}
${}$
\begin{lstlisting}
	fprintf('progress: %d%%\n',round(100*(idx-1)/length(R)));

\end{lstlisting}
\section{root}
\begin{lstlisting}
Root folder of the source code belonging to the doctoral thesis:

"Multi-Scale Monitoring and Modelling of the Kapuas River Delta", Karl K\"aster, 2019,

and master thesis:

"Computing the Spectrum of the Confined Hydrogen Atom", Karl K\"astner, 2012.

Copyright (C) 2010-2019 Karl K\"astner

Installation instructions:
	
1) Install Matlab
2) Install subversion (svn) and add subversion to the search path, so that
   it can be called from Matlab
3) Checkout this umbrella-project:
   svn checkout https://github.com/karlkastner/root/trunk root/
4) Start Matlab
5) Change into this directory ('root/')
6) Run the Matlab script "startup" located in this directory

The script then fetches the sub-repositories and adds them to the
Matlab search path
	
Note:

The code upload is work in progress, more parts will be subsequently
documented, added and tested.

This is experimental code. Use it wisely and at your own risk.

Licence:

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <https://www.gnu.org/licenses/>.


\end{lstlisting}
\subsection{startup}
${}$
\begin{lstlisting}

\end{lstlisting}
\end{document}
